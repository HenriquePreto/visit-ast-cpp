[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/blocksort.c#750:1#mainSort",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Int32 i, j, k, ss, sb;\n    Int32 runningOrder[256];\n    Bool bigDone[256];\n    Int32 copyStart[256];\n    Int32 copyEnd[256];\n    UChar c1;\n    Int32 numQSorted;\n    UInt16 s;\n    if (verb >= 4)\n        fprintf(__stderrp, \"        main sort initialise ...\\n\");\n    for (i = 65536; i >= 0; i--)\n        ftab[i] = 0;\n    j = block[0] << 8;\n    i = nblock - 1;\n    for (; i >= 3; i -= 4) {\n        quadrant[i] = 0;\n        j = (j >> 8) | (((UInt16)block[i]) << 8);\n        ftab[j]++;\n        quadrant[i - 1] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 1]) << 8);\n        ftab[j]++;\n        quadrant[i - 2] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 2]) << 8);\n        ftab[j]++;\n        quadrant[i - 3] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 3]) << 8);\n        ftab[j]++;\n    }\n    for (; i >= 0; i--) {\n        quadrant[i] = 0;\n        j = (j >> 8) | (((UInt16)block[i]) << 8);\n        ftab[j]++;\n    }\n    for (i = 0; i < (2 + 12 + 18 + 2); i++) {\n        block[nblock + i] = block[i];\n        quadrant[nblock + i] = 0;\n    }\n    if (verb >= 4)\n        fprintf(__stderrp, \"        bucket sorting ...\\n\");\n    for (i = 1; i <= 65536; i++)\n        ftab[i] += ftab[i - 1];\n    s = block[0] << 8;\n    i = nblock - 1;\n    for (; i >= 3; i -= 4) {\n        s = (s >> 8) | (block[i] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i;\n        s = (s >> 8) | (block[i - 1] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 1;\n        s = (s >> 8) | (block[i - 2] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 2;\n        s = (s >> 8) | (block[i - 3] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 3;\n    }\n    for (; i >= 0; i--) {\n        s = (s >> 8) | (block[i] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i;\n    }\n    for (i = 0; i <= 255; i++) {\n        bigDone[i] = ((Bool)0);\n        runningOrder[i] = i;\n    }\n    {\n        Int32 vv;\n        Int32 h = 1;\n        do \n            h = 3 * h + 1;\n        while (h <= 256);\n        do {\n            h = h / 3;\n            for (i = h; i <= 255; i++) {\n                vv = runningOrder[i];\n                j = i;\n                while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))\n                    {\n                        runningOrder[j] = runningOrder[j - h];\n                        j = j - h;\n                        if (j <= (h - 1))\n                            goto zero;\n                    }\n              zero:\n                runningOrder[j] = vv;\n            }\n        } while (h != 1);\n    }\n    numQSorted = 0;\n    for (i = 0; i <= 255; i++) {\n        ss = runningOrder[i];\n        for (j = 0; j <= 255; j++) {\n            if (j != ss) {\n                sb = (ss << 8) + j;\n                if (!(ftab[sb] & (1 << 21))) {\n                    Int32 lo = ftab[sb] & (~((1 << 21)));\n                    Int32 hi = (ftab[sb + 1] & (~((1 << 21)))) - 1;\n                    if (hi > lo) {\n                        if (verb >= 4)\n                            fprintf(__stderrp, \"        qsort [0x%x, 0x%x]   done %d   this %d\\n\", ss, j, numQSorted, hi - lo + 1);\n                        mainQSort3(ptr, block, quadrant, nblock, lo, hi, 2, budget);\n                        numQSorted += (hi - lo + 1);\n                        if (*budget < 0)\n                            return;\n                    }\n                }\n                ftab[sb] |= (1 << 21);\n            }\n        }\n        {\n            if (!(!bigDone[ss]))\n                BZ2_bz__AssertH__fail(1006);\n        }\n        ;\n        {\n            for (j = 0; j <= 255; j++) {\n                copyStart[j] = ftab[(j << 8) + ss] & (~((1 << 21)));\n                copyEnd[j] = (ftab[(j << 8) + ss + 1] & (~((1 << 21)))) - 1;\n            }\n            for (j = ftab[ss << 8] & (~((1 << 21))); j < copyStart[ss]; j++) {\n                k = ptr[j] - 1;\n                if (k < 0)\n                    k += nblock;\n                c1 = block[k];\n                if (!bigDone[c1])\n                    ptr[copyStart[c1]++] = k;\n            }\n            for (j = (ftab[(ss + 1) << 8] & (~((1 << 21)))) - 1; j > copyEnd[ss]; j--) {\n                k = ptr[j] - 1;\n                if (k < 0)\n                    k += nblock;\n                c1 = block[k];\n                if (!bigDone[c1])\n                    ptr[copyEnd[c1]--] = k;\n            }\n        }\n        {\n            if (!((copyStart[ss] - 1 == copyEnd[ss]) || (copyStart[ss] == 0 && copyEnd[ss] == nblock - 1)))\n                BZ2_bz__AssertH__fail(1007);\n        }\n        for (j = 0; j <= 255; j++)\n            ftab[(j << 8) + ss] |= (1 << 21);\n        bigDone[ss] = ((Bool)1);\n        if (i < 255) {\n            Int32 bbStart = ftab[ss << 8] & (~((1 << 21)));\n            Int32 bbSize = (ftab[(ss + 1) << 8] & (~((1 << 21)))) - bbStart;\n            Int32 shifts = 0;\n            while ((bbSize >> shifts) > 65534)\n                shifts++;\n            for (j = bbSize - 1; j >= 0; j--) {\n                Int32 a2update = ptr[bbStart + j];\n                UInt16 qVal = (UInt16)(j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < (2 + 12 + 18 + 2))\n                    quadrant[a2update + nblock] = qVal;\n            }\n            {\n                if (!(((bbSize - 1) >> shifts) <= 65535))\n                    BZ2_bz__AssertH__fail(1002);\n            }\n            ;\n        }\n    }\n    if (verb >= 4)\n        fprintf(__stderrp, \"        %d pointers, %d sorted, %d scanned\\n\", nblock, numQSorted, nblock - numQSorted);\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzlib.c#1301:1#BZ2_bzBuffToBuffDecompress",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    bz_stream strm;\n    int ret;\n    if (dest == ((void *)0) || destLen == ((void *)0) || source == ((void *)0) || (small != 0 && small != 1) || verbosity < 0 || verbosity > 4)\n        return (-2);\n    strm.bzalloc = ((void *)0);\n    strm.bzfree = ((void *)0);\n    strm.opaque = ((void *)0);\n    ret = BZ2_bzDecompressInit(&strm, verbosity, small);\n    if (ret != 0)\n        return ret;\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzDecompress(&strm);\n    if (ret == 0)\n        goto output_overflow_or_eof;\n    if (ret != 4)\n        goto errhandler;\n    *destLen -= strm.avail_out;\n    BZ2_bzDecompressEnd(&strm);\n    return 0;\n  output_overflow_or_eof:\n    if (strm.avail_out > 0) {\n        BZ2_bzDecompressEnd(&strm);\n        return (-7);\n    } else {\n        BZ2_bzDecompressEnd(&strm);\n        return (-8);\n    }\n    ;\n  errhandler:\n    BZ2_bzDecompressEnd(&strm);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzlib.c#537:1#unRLE_obuf_to_output_FAST",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    UChar k1;\n    if (s->blockRandomised) {\n        while (((Bool)1))\n            {\n                while (((Bool)1))\n                    {\n                        if (s->strm->avail_out == 0)\n                            return ((Bool)0);\n                        if (s->state_out_len == 0)\n                            break;\n                        *((UChar *)(s->strm->next_out)) = s->state_out_ch;\n                        {\n                            s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ ((UChar)s->state_out_ch)];\n                        }\n                        ;\n                        s->state_out_len--;\n                        s->strm->next_out++;\n                        s->strm->avail_out--;\n                        s->strm->total_out_lo32++;\n                        if (s->strm->total_out_lo32 == 0)\n                            s->strm->total_out_hi32++;\n                    }\n                if (s->nblock_used == s->save_nblock + 1)\n                    return ((Bool)0);\n                if (s->nblock_used > s->save_nblock + 1)\n                    return ((Bool)1);\n                s->state_out_len = 1;\n                s->state_out_ch = s->k0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                s->state_out_len = 2;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                s->state_out_len = 3;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                s->state_out_len = ((Int32)k1) + 4;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n            }\n    } else {\n        UInt32 c_calculatedBlockCRC = s->calculatedBlockCRC;\n        UChar c_state_out_ch = s->state_out_ch;\n        Int32 c_state_out_len = s->state_out_len;\n        Int32 c_nblock_used = s->nblock_used;\n        Int32 c_k0 = s->k0;\n        UInt32 *c_tt = s->tt;\n        UInt32 c_tPos = s->tPos;\n        char *cs_next_out = s->strm->next_out;\n        unsigned int cs_avail_out = s->strm->avail_out;\n        Int32 ro_blockSize100k = s->blockSize100k;\n        UInt32 avail_out_INIT = cs_avail_out;\n        Int32 s_save_nblockPP = s->save_nblock + 1;\n        unsigned int total_out_lo32_old;\n        while (((Bool)1))\n            {\n                if (c_state_out_len > 0) {\n                    while (((Bool)1))\n                        {\n                            if (cs_avail_out == 0)\n                                goto return_notr;\n                            if (c_state_out_len == 1)\n                                break;\n                            *((UChar *)(cs_next_out)) = c_state_out_ch;\n                            {\n                                c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ ((UChar)c_state_out_ch)];\n                            }\n                            ;\n                            c_state_out_len--;\n                            cs_next_out++;\n                            cs_avail_out--;\n                        }\n                  s_state_out_len_eq_one:\n                    {\n                        if (cs_avail_out == 0) {\n                            c_state_out_len = 1;\n                            goto return_notr;\n                        }\n                        ;\n                        *((UChar *)(cs_next_out)) = c_state_out_ch;\n                        {\n                            c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ ((UChar)c_state_out_ch)];\n                        }\n                        ;\n                        cs_next_out++;\n                        cs_avail_out--;\n                    }\n                }\n                if (c_nblock_used > s_save_nblockPP)\n                    return ((Bool)1);\n                if (c_nblock_used == s_save_nblockPP) {\n                    c_state_out_len = 0;\n                    goto return_notr;\n                }\n                ;\n                c_state_out_ch = c_k0;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    goto s_state_out_len_eq_one;\n                }\n                ;\n                if (c_nblock_used == s_save_nblockPP)\n                    goto s_state_out_len_eq_one;\n                c_state_out_len = 2;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (c_nblock_used == s_save_nblockPP)\n                    continue;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    continue;\n                }\n                ;\n                c_state_out_len = 3;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (c_nblock_used == s_save_nblockPP)\n                    continue;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    continue;\n                }\n                ;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                c_state_out_len = ((Int32)k1) + 4;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                c_k0 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n            }\n      return_notr:\n        total_out_lo32_old = s->strm->total_out_lo32;\n        s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);\n        if (s->strm->total_out_lo32 < total_out_lo32_old)\n            s->strm->total_out_hi32++;\n        s->calculatedBlockCRC = c_calculatedBlockCRC;\n        s->state_out_ch = c_state_out_ch;\n        s->state_out_len = c_state_out_len;\n        s->nblock_used = c_nblock_used;\n        s->k0 = c_k0;\n        s->tt = c_tt;\n        s->tPos = c_tPos;\n        s->strm->next_out = cs_next_out;\n        s->strm->avail_out = cs_avail_out;\n    }\n    return ((Bool)0);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzlib.c#1249:1#BZ2_bzBuffToBuffCompress",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    bz_stream strm;\n    int ret;\n    if (dest == ((void *)0) || destLen == ((void *)0) || source == ((void *)0) || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250)\n        return (-2);\n    if (workFactor == 0)\n        workFactor = 30;\n    strm.bzalloc = ((void *)0);\n    strm.bzfree = ((void *)0);\n    strm.opaque = ((void *)0);\n    ret = BZ2_bzCompressInit(&strm, blockSize100k, verbosity, workFactor);\n    if (ret != 0)\n        return ret;\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzCompress(&strm, 2);\n    if (ret == 3)\n        goto output_overflow;\n    if (ret != 4)\n        goto errhandler;\n    *destLen -= strm.avail_out;\n    BZ2_bzCompressEnd(&strm);\n    return 0;\n  output_overflow:\n    BZ2_bzCompressEnd(&strm);\n    return (-8);\n  errhandler:\n    BZ2_bzCompressEnd(&strm);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzlib.c#409:1#BZ2_bzCompress",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Bool progress;\n    EState *s;\n    if (strm == ((void *)0))\n        return (-2);\n    s = strm->state;\n    if (s == ((void *)0))\n        return (-2);\n    if (s->strm != strm)\n        return (-2);\n  preswitch:\n    switch (s->mode) {\n      case 1:\n        return (-1);\n      case 2:\n        if (action == 0) {\n            progress = handle_compress(strm);\n            return progress ? 1 : (-2);\n        } else if (action == 1) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 3;\n            goto preswitch;\n        } else if (action == 2) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 4;\n            goto preswitch;\n        } else\n            return (-2);\n      case 3:\n        if (action != 1)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 2;\n        s->mode = 2;\n        return 1;\n      case 4:\n        if (action != 2)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (!progress)\n            return (-1);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 3;\n        s->mode = 1;\n        return 4;\n    }\n    return 0;\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/decompress.c#106:1#BZ2_decompress",
    "gotos": 85,
    "labels": 2,
    "body": "{\n    UChar uc;\n    Int32 retVal;\n    Int32 minLen, maxLen;\n    bz_stream *strm = s->strm;\n    Int32 i;\n    Int32 j;\n    Int32 t;\n    Int32 alphaSize;\n    Int32 nGroups;\n    Int32 nSelectors;\n    Int32 EOB;\n    Int32 groupNo;\n    Int32 groupPos;\n    Int32 nextSym;\n    Int32 nblockMAX;\n    Int32 nblock;\n    Int32 es;\n    Int32 N;\n    Int32 curr;\n    Int32 zt;\n    Int32 zn;\n    Int32 zvec;\n    Int32 zj;\n    Int32 gSel;\n    Int32 gMinlen;\n    Int32 *gLimit;\n    Int32 *gBase;\n    Int32 *gPerm;\n    if (s->state == 10) {\n        s->save_i = 0;\n        s->save_j = 0;\n        s->save_t = 0;\n        s->save_alphaSize = 0;\n        s->save_nGroups = 0;\n        s->save_nSelectors = 0;\n        s->save_EOB = 0;\n        s->save_groupNo = 0;\n        s->save_groupPos = 0;\n        s->save_nextSym = 0;\n        s->save_nblockMAX = 0;\n        s->save_nblock = 0;\n        s->save_es = 0;\n        s->save_N = 0;\n        s->save_curr = 0;\n        s->save_zt = 0;\n        s->save_zn = 0;\n        s->save_zvec = 0;\n        s->save_zj = 0;\n        s->save_gSel = 0;\n        s->save_gMinlen = 0;\n        s->save_gLimit = ((void *)0);\n        s->save_gBase = ((void *)0);\n        s->save_gPerm = ((void *)0);\n    }\n    i = s->save_i;\n    j = s->save_j;\n    t = s->save_t;\n    alphaSize = s->save_alphaSize;\n    nGroups = s->save_nGroups;\n    nSelectors = s->save_nSelectors;\n    EOB = s->save_EOB;\n    groupNo = s->save_groupNo;\n    groupPos = s->save_groupPos;\n    nextSym = s->save_nextSym;\n    nblockMAX = s->save_nblockMAX;\n    nblock = s->save_nblock;\n    es = s->save_es;\n    N = s->save_N;\n    curr = s->save_curr;\n    zt = s->save_zt;\n    zn = s->save_zn;\n    zvec = s->save_zvec;\n    zj = s->save_zj;\n    gSel = s->save_gSel;\n    gMinlen = s->save_gMinlen;\n    gLimit = s->save_gLimit;\n    gBase = s->save_gBase;\n    gPerm = s->save_gPerm;\n    retVal = 0;\n    switch (s->state) {\n      case 10:\n        s->state = 10;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 66) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 11:\n        s->state = 11;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 90) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 12:\n        s->state = 12;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (uc != 104) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 13:\n        s->state = 13;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    s->blockSize100k = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (s->blockSize100k < (48 + 1) || s->blockSize100k > (48 + 9)) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->blockSize100k -= 48;\n        if (s->smallDecompress) {\n            s->ll16 = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(UInt16)), 1);\n            s->ll4 = (strm->bzalloc)(strm->opaque, (((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)), 1);\n            if (s->ll16 == ((void *)0) || s->ll4 == ((void *)0)) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        } else {\n            s->tt = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(Int32)), 1);\n            if (s->tt == ((void *)0)) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n      case 14:\n        s->state = 14;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc == 23)\n            goto endhdr_2;\n        if (uc != 49) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 15:\n        s->state = 15;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 65) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 16:\n        s->state = 16;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 17:\n        s->state = 17;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 38) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 18:\n        s->state = 18;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 83) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 19:\n        s->state = 19;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->currBlockNo++;\n        if (s->verbosity >= 2)\n            fprintf(__stderrp, \"\\n    [%d: huff+mtf \", s->currBlockNo);\n        s->storedBlockCRC = 0;\n      case 20:\n        s->state = 20;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 21:\n        s->state = 21;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 22:\n        s->state = 22;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 23:\n        s->state = 23;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 24:\n        s->state = 24;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 1) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                    s->bsLive -= 1;\n                    s->blockRandomised = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = 0;\n      case 25:\n        s->state = 25;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 26:\n        s->state = 26;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 27:\n        s->state = 27;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n        if (s->origPtr < 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        if (s->origPtr > 10 + 100000 * s->blockSize100k) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < 16; i++) {\n          case 28:\n            s->state = 28;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 1) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                        s->bsLive -= 1;\n                        uc = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            if (uc == 1)\n                s->inUse16[i] = ((Bool)1);\n            else\n                s->inUse16[i] = ((Bool)0);\n        }\n        for (i = 0; i < 256; i++)\n            s->inUse[i] = ((Bool)0);\n        for (i = 0; i < 16; i++)\n            if (s->inUse16[i])\n                for (j = 0; j < 16; j++) {\n                  case 29:\n                    s->state = 29;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 1)\n                        s->inUse[i * 16 + j] = ((Bool)1);\n                }\n        makeMaps_d(s);\n        if (s->nInUse == 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        alphaSize = s->nInUse + 2;\n      case 30:\n        s->state = 30;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 3) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 3)) & ((1 << 3) - 1);\n                    s->bsLive -= 3;\n                    nGroups = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nGroups < 2 || nGroups > 6) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 31:\n        s->state = 31;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 15) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 15)) & ((1 << 15) - 1);\n                    s->bsLive -= 15;\n                    nSelectors = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nSelectors < 1) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < nSelectors; i++) {\n            j = 0;\n            while (((Bool)1))\n                {\n                  case 32:\n                    s->state = 32;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 0)\n                        break;\n                    j++;\n                    if (j >= nGroups) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                }\n            if (i < (2 + (900000 / 50)))\n                s->selectorMtf[i] = j;\n        }\n        if (nSelectors > (2 + (900000 / 50)))\n            nSelectors = (2 + (900000 / 50));\n        {\n            UChar pos[6], tmp, v;\n            for (v = 0; v < nGroups; v++)\n                pos[v] = v;\n            for (i = 0; i < nSelectors; i++) {\n                v = s->selectorMtf[i];\n                tmp = pos[v];\n                while (v > 0)\n                    {\n                        pos[v] = pos[v - 1];\n                        v--;\n                    }\n                pos[0] = tmp;\n                s->selector[i] = tmp;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n          case 33:\n            s->state = 33;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 5) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 5)) & ((1 << 5) - 1);\n                        s->bsLive -= 5;\n                        curr = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            for (i = 0; i < alphaSize; i++) {\n                while (((Bool)1))\n                    {\n                        if (curr < 1 || curr > 20) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                      case 34:\n                        s->state = 34;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            break;\n                      case 35:\n                        s->state = 35;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            curr++;\n                        else\n                            curr--;\n                    }\n                s->len[t][i] = curr;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (s->len[t][i] > maxLen)\n                    maxLen = s->len[t][i];\n                if (s->len[t][i] < minLen)\n                    minLen = s->len[t][i];\n            }\n            BZ2_hbCreateDecodeTables(&(s->limit[t][0]), &(s->base[t][0]), &(s->perm[t][0]), &(s->len[t][0]), minLen, maxLen, alphaSize);\n            s->minLens[t] = minLen;\n        }\n        EOB = s->nInUse + 1;\n        nblockMAX = 100000 * s->blockSize100k;\n        groupNo = -1;\n        groupPos = 0;\n        for (i = 0; i <= 255; i++)\n            s->unzftab[i] = 0;\n        {\n            Int32 ii, jj, kk;\n            kk = 4096 - 1;\n            for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                for (jj = 16 - 1; jj >= 0; jj--) {\n                    s->mtfa[kk] = (UChar)(ii * 16 + jj);\n                    kk--;\n                }\n                s->mtfbase[ii] = kk + 1;\n            }\n        }\n        nblock = 0;\n        {\n            if (groupPos == 0) {\n                groupNo++;\n                if (groupNo >= nSelectors) {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                groupPos = 50;\n                gSel = s->selector[groupNo];\n                gMinlen = s->minLens[gSel];\n                gLimit = &(s->limit[gSel][0]);\n                gPerm = &(s->perm[gSel][0]);\n                gBase = &(s->base[gSel][0]);\n            }\n            groupPos--;\n            zn = gMinlen;\n          case 36:\n            s->state = 36;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= zn) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                        s->bsLive -= zn;\n                        zvec = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            while (1)\n                {\n                    if (zn > 20) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    if (zvec <= gLimit[zn])\n                        break;\n                    zn++;\n                  case 37:\n                    s->state = 37;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                zj = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    zvec = (zvec << 1) | zj;\n                }\n            ;\n            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n            nextSym = gPerm[zvec - gBase[zn]];\n        }\n        ;\n        while (((Bool)1))\n            {\n                if (nextSym == EOB)\n                    break;\n                if (nextSym == 0 || nextSym == 1) {\n                    es = -1;\n                    N = 1;\n                    do {\n                        if (N >= 2 * 1024 * 1024) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        if (nextSym == 0)\n                            es = es + (0 + 1) * N;\n                        else if (nextSym == 1)\n                            es = es + (1 + 1) * N;\n                        N = N * 2;\n                        {\n                            if (groupPos == 0) {\n                                groupNo++;\n                                if (groupNo >= nSelectors) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                groupPos = 50;\n                                gSel = s->selector[groupNo];\n                                gMinlen = s->minLens[gSel];\n                                gLimit = &(s->limit[gSel][0]);\n                                gPerm = &(s->perm[gSel][0]);\n                                gBase = &(s->base[gSel][0]);\n                            }\n                            groupPos--;\n                            zn = gMinlen;\n                          case 38:\n                            s->state = 38;\n                            while (((Bool)1))\n                                {\n                                    if (s->bsLive >= zn) {\n                                        UInt32 v;\n                                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                        s->bsLive -= zn;\n                                        zvec = v;\n                                        break;\n                                    }\n                                    if (s->strm->avail_in == 0) {\n                                        retVal = 0;\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                    s->bsLive += 8;\n                                    s->strm->next_in++;\n                                    s->strm->avail_in--;\n                                    s->strm->total_in_lo32++;\n                                    if (s->strm->total_in_lo32 == 0)\n                                        s->strm->total_in_hi32++;\n                                }\n                            ;\n                            while (1)\n                                {\n                                    if (zn > 20) {\n                                        retVal = (-4);\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    if (zvec <= gLimit[zn])\n                                        break;\n                                    zn++;\n                                  case 39:\n                                    s->state = 39;\n                                    while (((Bool)1))\n                                        {\n                                            if (s->bsLive >= 1) {\n                                                UInt32 v;\n                                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                                s->bsLive -= 1;\n                                                zj = v;\n                                                break;\n                                            }\n                                            if (s->strm->avail_in == 0) {\n                                                retVal = 0;\n                                                goto save_state_and_return;\n                                            }\n                                            ;\n                                            ;\n                                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                            s->bsLive += 8;\n                                            s->strm->next_in++;\n                                            s->strm->avail_in--;\n                                            s->strm->total_in_lo32++;\n                                            if (s->strm->total_in_lo32 == 0)\n                                                s->strm->total_in_hi32++;\n                                        }\n                                    ;\n                                    zvec = (zvec << 1) | zj;\n                                }\n                            ;\n                            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            nextSym = gPerm[zvec - gBase[zn]];\n                        }\n                        ;\n                    } while (nextSym == 0 || nextSym == 1);\n                    es++;\n                    uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];\n                    s->unzftab[uc] += es;\n                    if (s->smallDecompress)\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->ll16[nblock] = (UInt16)uc;\n                                nblock++;\n                                es--;\n                            }\n                    else\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->tt[nblock] = (UInt32)uc;\n                                nblock++;\n                                es--;\n                            }\n                    ;\n                    continue;\n                } else {\n                    if (nblock >= nblockMAX) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    {\n                        Int32 ii, jj, kk, pp, lno, off;\n                        UInt32 nn;\n                        nn = (UInt32)(nextSym - 1);\n                        if (nn < 16) {\n                            pp = s->mtfbase[0];\n                            uc = s->mtfa[pp + nn];\n                            while (nn > 3)\n                                {\n                                    Int32 z = pp + nn;\n                                    s->mtfa[(z)] = s->mtfa[(z) - 1];\n                                    s->mtfa[(z) - 1] = s->mtfa[(z) - 2];\n                                    s->mtfa[(z) - 2] = s->mtfa[(z) - 3];\n                                    s->mtfa[(z) - 3] = s->mtfa[(z) - 4];\n                                    nn -= 4;\n                                }\n                            while (nn > 0)\n                                {\n                                    s->mtfa[(pp + nn)] = s->mtfa[(pp + nn) - 1];\n                                    nn--;\n                                }\n                            ;\n                            s->mtfa[pp] = uc;\n                        } else {\n                            lno = nn / 16;\n                            off = nn % 16;\n                            pp = s->mtfbase[lno] + off;\n                            uc = s->mtfa[pp];\n                            while (pp > s->mtfbase[lno])\n                                {\n                                    s->mtfa[pp] = s->mtfa[pp - 1];\n                                    pp--;\n                                }\n                            ;\n                            s->mtfbase[lno]++;\n                            while (lno > 0)\n                                {\n                                    s->mtfbase[lno]--;\n                                    s->mtfa[s->mtfbase[lno]] = s->mtfa[s->mtfbase[lno - 1] + 16 - 1];\n                                    lno--;\n                                }\n                            s->mtfbase[0]--;\n                            s->mtfa[s->mtfbase[0]] = uc;\n                            if (s->mtfbase[0] == 0) {\n                                kk = 4096 - 1;\n                                for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                                    for (jj = 16 - 1; jj >= 0; jj--) {\n                                        s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                                        kk--;\n                                    }\n                                    s->mtfbase[ii] = kk + 1;\n                                }\n                            }\n                        }\n                    }\n                    s->unzftab[s->seqToUnseq[uc]]++;\n                    if (s->smallDecompress)\n                        s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]);\n                    else\n                        s->tt[nblock] = (UInt32)(s->seqToUnseq[uc]);\n                    nblock++;\n                    {\n                        if (groupPos == 0) {\n                            groupNo++;\n                            if (groupNo >= nSelectors) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            groupPos = 50;\n                            gSel = s->selector[groupNo];\n                            gMinlen = s->minLens[gSel];\n                            gLimit = &(s->limit[gSel][0]);\n                            gPerm = &(s->perm[gSel][0]);\n                            gBase = &(s->base[gSel][0]);\n                        }\n                        groupPos--;\n                        zn = gMinlen;\n                      case 40:\n                        s->state = 40;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= zn) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                    s->bsLive -= zn;\n                                    zvec = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        while (1)\n                            {\n                                if (zn > 20) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                if (zvec <= gLimit[zn])\n                                    break;\n                                zn++;\n                              case 41:\n                                s->state = 41;\n                                while (((Bool)1))\n                                    {\n                                        if (s->bsLive >= 1) {\n                                            UInt32 v;\n                                            v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                            s->bsLive -= 1;\n                                            zj = v;\n                                            break;\n                                        }\n                                        if (s->strm->avail_in == 0) {\n                                            retVal = 0;\n                                            goto save_state_and_return;\n                                        }\n                                        ;\n                                        ;\n                                        s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                        s->bsLive += 8;\n                                        s->strm->next_in++;\n                                        s->strm->avail_in--;\n                                        s->strm->total_in_lo32++;\n                                        if (s->strm->total_in_lo32 == 0)\n                                            s->strm->total_in_hi32++;\n                                    }\n                                ;\n                                zvec = (zvec << 1) | zj;\n                            }\n                        ;\n                        if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        nextSym = gPerm[zvec - gBase[zn]];\n                    }\n                    ;\n                    continue;\n                }\n            }\n        if (s->origPtr < 0 || s->origPtr >= nblock) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i <= 255; i++) {\n            if (s->unzftab[i] < 0 || s->unzftab[i] > nblock) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n        s->cftab[0] = 0;\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] = s->unzftab[i - 1];\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] += s->cftab[i - 1];\n        for (i = 0; i <= 256; i++) {\n            if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        for (i = 1; i <= 256; i++) {\n            if (s->cftab[i - 1] > s->cftab[i]) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        s->state_out_len = 0;\n        s->state_out_ch = 0;\n        {\n            s->calculatedBlockCRC = 4294967295L;\n        }\n        ;\n        s->state = 2;\n        if (s->verbosity >= 2)\n            fprintf(__stderrp, \"rt+rld\");\n        if (s->smallDecompress) {\n            for (i = 0; i <= 256; i++)\n                s->cftabCopy[i] = s->cftab[i];\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->ll16[i]);\n                {\n                    s->ll16[i] = (UInt16)(s->cftabCopy[uc] & 65535);\n                    {\n                        if (((i) & 1) == 0)\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 240) | (s->cftabCopy[uc] >> 16);\n                        else\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 15) | ((s->cftabCopy[uc] >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                s->cftabCopy[uc]++;\n            }\n            i = s->origPtr;\n            j = (((UInt32)s->ll16[i]) | (((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 4)) & 15) << 16));\n            do {\n                Int32 tmp = (((UInt32)s->ll16[j]) | (((((UInt32)(s->ll4[(j) >> 1])) >> (((j) << 2) & 4)) & 15) << 16));\n                {\n                    s->ll16[j] = (UInt16)(i & 65535);\n                    {\n                        if (((j) & 1) == 0)\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 240) | (i >> 16);\n                        else\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 15) | ((i >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                i = j;\n                j = tmp;\n            } while (i != s->origPtr);\n            s->tPos = s->origPtr;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n            }\n        } else {\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->tt[i] & 255);\n                s->tt[s->cftab[uc]] |= (i << 8);\n                s->cftab[uc]++;\n            }\n            s->tPos = s->tt[s->origPtr] >> 8;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n            }\n        }\n        {\n            retVal = 0;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      endhdr_2:\n      case 42:\n        s->state = 42;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 114) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 43:\n        s->state = 43;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 69) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 44:\n        s->state = 44;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 56) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 45:\n        s->state = 45;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 80) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 46:\n        s->state = 46;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 144) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->storedCombinedCRC = 0;\n      case 47:\n        s->state = 47;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 48:\n        s->state = 48;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 49:\n        s->state = 49;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 50:\n        s->state = 50;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n        s->state = 1;\n        {\n            retVal = 4;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      default:\n        {\n            if (!(((Bool)0)))\n                BZ2_bz__AssertH__fail(4001);\n        }\n        ;\n    }\n    {\n        if (!(((Bool)0)))\n            BZ2_bz__AssertH__fail(4002);\n    }\n    ;\n  save_state_and_return:\n    s->save_i = i;\n    s->save_j = j;\n    s->save_t = t;\n    s->save_alphaSize = alphaSize;\n    s->save_nGroups = nGroups;\n    s->save_nSelectors = nSelectors;\n    s->save_EOB = EOB;\n    s->save_groupNo = groupNo;\n    s->save_groupPos = groupPos;\n    s->save_nextSym = nextSym;\n    s->save_nblockMAX = nblockMAX;\n    s->save_nblock = nblock;\n    s->save_es = es;\n    s->save_N = N;\n    s->save_curr = curr;\n    s->save_zt = zt;\n    s->save_zn = zn;\n    s->save_zvec = zvec;\n    s->save_zj = zj;\n    s->save_gSel = gSel;\n    s->save_gMinlen = gMinlen;\n    s->save_gLimit = gLimit;\n    s->save_gBase = gBase;\n    s->save_gPerm = gPerm;\n    return retVal;\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#415:1#uncompressStream",
    "gotos": 15,
    "labels": 4,
    "body": "{\n    BZFILE *bzf = ((void *)0);\n    Int32 bzerr, bzerr_dummy, ret, nread, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    ;\n    ;\n    if (ferror(stream))\n        goto errhandler_io;\n    if (ferror(zStream))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = BZ2_bzReadOpen(&bzerr, zStream, verbosity, (int)smallMode, unused, nUnused);\n            if (bzf == ((void *)0) || bzerr != 0)\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    nread = BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto trycat;\n                    if ((bzerr == 0 || bzerr == 4) && nread > 0)\n                        fwrite(obuf, sizeof(UChar), nread, stream);\n                    if (ferror(stream))\n                        goto errhandler_io;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            if (nUnused == 0 && myfeof(zStream))\n                break;\n        }\n  closeok:\n    if (ferror(zStream))\n        goto errhandler_io;\n    if (stream != __stdoutp) {\n        Int32 fd = fileno(stream);\n        if (fd < 0)\n            goto errhandler_io;\n        applySavedFileAttrToOutputFile(fd);\n    }\n    ret = fclose(zStream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (ferror(stream))\n        goto errhandler_io;\n    ret = fflush(stream);\n    if (ret != 0)\n        goto errhandler_io;\n    if (stream != __stdoutp) {\n        ret = fclose(stream);\n        outputHandleJustInCase = ((void *)0);\n        if (ret == (-1))\n            goto errhandler_io;\n    }\n    outputHandleJustInCase = ((void *)0);\n    if (verbosity >= 2)\n        fprintf(__stderrp, \"\\n    \");\n    return ((Bool)1);\n  trycat:\n    if (forceOverwrite) {\n        rewind(zStream);\n        while (((Bool)1))\n            {\n                if (myfeof(zStream))\n                    break;\n                nread = fread(obuf, sizeof(UChar), 5000, zStream);\n                if (ferror(zStream))\n                    goto errhandler_io;\n                if (nread > 0)\n                    fwrite(obuf, sizeof(UChar), nread, stream);\n                if (ferror(stream))\n                    goto errhandler_io;\n            }\n        goto closeok;\n    }\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        crcError();\n      case (-3):\n        outOfMemory();\n      case (-7):\n        compressedStreamEOF();\n      case (-5):\n        if (zStream != __stdinp)\n            fclose(zStream);\n        if (stream != __stdoutp)\n            fclose(stream);\n        if (streamNo == 1) {\n            return ((Bool)0);\n        } else {\n            if (noisy)\n                fprintf(__stderrp, \"\\n%s: %s: trailing garbage after EOF ignored\\n\", progName, inName);\n            return ((Bool)1);\n        }\n      default:\n        panic(\"decompress:unexpected error\");\n    }\n    panic(\"decompress:end\");\n    return ((Bool)1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#1304:1#uncompress",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    FILE *inStr;\n    FILE *outStr;\n    Int32 n, i;\n    Bool magicNumberOK;\n    Bool cantGuess;\n    struct stat statBuf;\n    deleteOutputOnInterrupt = ((Bool)0);\n    if (name == ((void *)0) && srcMode != 1)\n        panic(\"uncompress: bad modes\\n\");\n    cantGuess = ((Bool)0);\n    switch (srcMode) {\n      case 1:\n        copyFileName(inName, (Char *)\"(stdin)\");\n        copyFileName(outName, (Char *)\"(stdout)\");\n        break;\n      case 3:\n        copyFileName(inName, name);\n        copyFileName(outName, name);\n        for (i = 0; i < 4; i++)\n            if (mapSuffix(outName, zSuffix[i], unzSuffix[i]))\n                goto zzz;\n        cantGuess = ((Bool)1);\n        __builtin___strcat_chk(outName, \".out\", __builtin_object_size(outName, 2 > 1 ? 1 : 0));\n        break;\n      case 2:\n        copyFileName(inName, name);\n        copyFileName(outName, (Char *)\"(stdout)\");\n        break;\n    }\n  zzz:\n    if (srcMode != 1 && containsDubiousChars(inName)) {\n        if (noisy)\n            fprintf(__stderrp, \"%s: There are no files matching `%s'.\\n\", progName, inName);\n        setExit(1);\n        return;\n    }\n    if (srcMode != 1 && !fileExists(inName)) {\n        fprintf(__stderrp, \"%s: Can't open input file %s: %s.\\n\", progName, inName, strerror((*__error())));\n        setExit(1);\n        return;\n    }\n    if (srcMode == 3 || srcMode == 2) {\n        stat(inName, &statBuf);\n        if ((((statBuf.st_mode) & 61440) == 16384)) {\n            fprintf(__stderrp, \"%s: Input file %s is a directory.\\n\", progName, inName);\n            setExit(1);\n            return;\n        }\n    }\n    if (srcMode == 3 && !forceOverwrite && notAStandardFile(inName)) {\n        if (noisy)\n            fprintf(__stderrp, \"%s: Input file %s is not a normal file.\\n\", progName, inName);\n        setExit(1);\n        return;\n    }\n    if (cantGuess) {\n        if (noisy)\n            fprintf(__stderrp, \"%s: Can't guess original name for %s -- using %s\\n\", progName, inName, outName);\n    }\n    if (srcMode == 3 && fileExists(outName)) {\n        if (forceOverwrite) {\n            remove(outName);\n        } else {\n            fprintf(__stderrp, \"%s: Output file %s already exists.\\n\", progName, outName);\n            setExit(1);\n            return;\n        }\n    }\n    if (srcMode == 3 && !forceOverwrite && (n = countHardLinks(inName)) > 0) {\n        fprintf(__stderrp, \"%s: Input file %s has %d other link%s.\\n\", progName, inName, n, n > 1 ? \"s\" : \"\");\n        setExit(1);\n        return;\n    }\n    if (srcMode == 3) {\n        saveInputFileMetaInfo(inName);\n    }\n    switch (srcMode) {\n      case 1:\n        inStr = __stdinp;\n        outStr = __stdoutp;\n        if (isatty(fileno(__stdinp))) {\n            fprintf(__stderrp, \"%s: I won't read compressed data from a terminal.\\n\", progName);\n            fprintf(__stderrp, \"%s: For help, type: `%s --help'.\\n\", progName, progName);\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      case 2:\n        inStr = fopen(inName, \"rb\");\n        outStr = __stdoutp;\n        if (inStr == ((void *)0)) {\n            fprintf(__stderrp, \"%s: Can't open input file %s:%s.\\n\", progName, inName, strerror((*__error())));\n            if (inStr != ((void *)0))\n                fclose(inStr);\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      case 3:\n        inStr = fopen(inName, \"rb\");\n        outStr = fopen_output_safely(outName, \"wb\");\n        if (outStr == ((void *)0)) {\n            fprintf(__stderrp, \"%s: Can't create output file %s: %s.\\n\", progName, outName, strerror((*__error())));\n            if (inStr != ((void *)0))\n                fclose(inStr);\n            setExit(1);\n            return;\n        }\n        if (inStr == ((void *)0)) {\n            fprintf(__stderrp, \"%s: Can't open input file %s: %s.\\n\", progName, inName, strerror((*__error())));\n            if (outStr != ((void *)0))\n                fclose(outStr);\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      default:\n        panic(\"uncompress: bad srcMode\");\n        break;\n    }\n    if (verbosity >= 1) {\n        fprintf(__stderrp, \"  %s: \", inName);\n        pad(inName);\n        fflush(__stderrp);\n    }\n    outputHandleJustInCase = outStr;\n    deleteOutputOnInterrupt = ((Bool)1);\n    magicNumberOK = uncompressStream(inStr, outStr);\n    outputHandleJustInCase = ((void *)0);\n    if (magicNumberOK) {\n        if (srcMode == 3) {\n            applySavedTimeInfoToOutputFile(outName);\n            deleteOutputOnInterrupt = ((Bool)0);\n            if (!keepInputFiles) {\n                IntNative retVal = remove(inName);\n                {\n                    if ((retVal) != 0)\n                        ioError();\n                }\n                ;\n            }\n        }\n    } else {\n        unzFailsExist = ((Bool)1);\n        deleteOutputOnInterrupt = ((Bool)0);\n        if (srcMode == 3) {\n            IntNative retVal = remove(outName);\n            {\n                if ((retVal) != 0)\n                    ioError();\n            }\n            ;\n        }\n    }\n    deleteOutputOnInterrupt = ((Bool)0);\n    if (magicNumberOK) {\n        if (verbosity >= 1)\n            fprintf(__stderrp, \"done\\n\");\n    } else {\n        setExit(2);\n        if (verbosity >= 1)\n            fprintf(__stderrp, \"not a bzip2 file.\\n\");\n        else\n            fprintf(__stderrp, \"%s: %s is not a bzip2 file.\\n\", progName, inName);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#311:1#compressStream",
    "gotos": 12,
    "labels": 2,
    "body": "{\n    BZFILE *bzf = ((void *)0);\n    UChar ibuf[5000];\n    Int32 nIbuf;\n    UInt32 nbytes_in_lo32, nbytes_in_hi32;\n    UInt32 nbytes_out_lo32, nbytes_out_hi32;\n    Int32 bzerr, bzerr_dummy, ret;\n    ;\n    ;\n    if (ferror(stream))\n        goto errhandler_io;\n    if (ferror(zStream))\n        goto errhandler_io;\n    bzf = BZ2_bzWriteOpen(&bzerr, zStream, blockSize100k, verbosity, workFactor);\n    if (bzerr != 0)\n        goto errhandler;\n    if (verbosity >= 2)\n        fprintf(__stderrp, \"\\n\");\n    while (((Bool)1))\n        {\n            if (myfeof(stream))\n                break;\n            nIbuf = fread(ibuf, sizeof(UChar), 5000, stream);\n            if (ferror(stream))\n                goto errhandler_io;\n            if (nIbuf > 0)\n                BZ2_bzWrite(&bzerr, bzf, (void *)ibuf, nIbuf);\n            if (bzerr != 0)\n                goto errhandler;\n        }\n    BZ2_bzWriteClose64(&bzerr, bzf, 0, &nbytes_in_lo32, &nbytes_in_hi32, &nbytes_out_lo32, &nbytes_out_hi32);\n    if (bzerr != 0)\n        goto errhandler;\n    if (ferror(zStream))\n        goto errhandler_io;\n    ret = fflush(zStream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (zStream != __stdoutp) {\n        Int32 fd = fileno(zStream);\n        if (fd < 0)\n            goto errhandler_io;\n        applySavedFileAttrToOutputFile(fd);\n        ret = fclose(zStream);\n        outputHandleJustInCase = ((void *)0);\n        if (ret == (-1))\n            goto errhandler_io;\n    }\n    outputHandleJustInCase = ((void *)0);\n    if (ferror(stream))\n        goto errhandler_io;\n    ret = fclose(stream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (verbosity >= 1) {\n        if (nbytes_in_lo32 == 0 && nbytes_in_hi32 == 0) {\n            fprintf(__stderrp, \" no data compressed.\\n\");\n        } else {\n            Char buf_nin[32], buf_nout[32];\n            UInt64 nbytes_in, nbytes_out;\n            double nbytes_in_d, nbytes_out_d;\n            uInt64_from_UInt32s(&nbytes_in, nbytes_in_lo32, nbytes_in_hi32);\n            uInt64_from_UInt32s(&nbytes_out, nbytes_out_lo32, nbytes_out_hi32);\n            nbytes_in_d = uInt64_to_double(&nbytes_in);\n            nbytes_out_d = uInt64_to_double(&nbytes_out);\n            uInt64_toAscii(buf_nin, &nbytes_in);\n            uInt64_toAscii(buf_nout, &nbytes_out);\n            fprintf(__stderrp, \"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\\n\", nbytes_in_d / nbytes_out_d, (8. * nbytes_out_d) / nbytes_in_d, 100. * (1. - nbytes_out_d / nbytes_in_d), buf_nin, buf_nout);\n        }\n    }\n    return;\n  errhandler:\n    BZ2_bzWriteClose64(&bzerr_dummy, bzf, 1, &nbytes_in_lo32, &nbytes_in_hi32, &nbytes_out_lo32, &nbytes_out_hi32);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-3):\n        outOfMemory();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      default:\n        panic(\"compress:unexpected error\");\n    }\n    panic(\"compress:end\");\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#536:1#testStream",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    BZFILE *bzf = ((void *)0);\n    Int32 bzerr, bzerr_dummy, ret, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    ;\n    if (ferror(zStream))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = BZ2_bzReadOpen(&bzerr, zStream, verbosity, (int)smallMode, unused, nUnused);\n            if (bzf == ((void *)0) || bzerr != 0)\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto errhandler;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            if (nUnused == 0 && myfeof(zStream))\n                break;\n        }\n    if (ferror(zStream))\n        goto errhandler_io;\n    ret = fclose(zStream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (verbosity >= 2)\n        fprintf(__stderrp, \"\\n    \");\n    return ((Bool)1);\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    if (verbosity == 0)\n        fprintf(__stderrp, \"%s: %s: \", progName, inName);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        fprintf(__stderrp, \"data integrity (CRC) error in data\\n\");\n        return ((Bool)0);\n      case (-3):\n        outOfMemory();\n      case (-7):\n        fprintf(__stderrp, \"file ends unexpectedly\\n\");\n        return ((Bool)0);\n      case (-5):\n        if (zStream != __stdinp)\n            fclose(zStream);\n        if (streamNo == 1) {\n            fprintf(__stderrp, \"bad magic number (file not created by bzip2)\\n\");\n            return ((Bool)0);\n        } else {\n            if (noisy)\n                fprintf(__stderrp, \"trailing garbage after EOF ignored\\n\");\n            return ((Bool)1);\n        }\n      default:\n        panic(\"test:unexpected error\");\n    }\n    panic(\"test:end\");\n    return ((Bool)1);\n}\n"
  }
]
[
  {
    "id": "sqlite3.c#200322:1#jsonSetFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    int bApnd;\n    int bIsSet = sqlite3_user_data(ctx) != 0;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, bIsSet ? \"set\" : \"insert\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    ((void)0);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        bApnd = 0;\n        pNode = jsonLookup(&x, zPath, &bApnd, ctx);\n        if (x.oom) {\n            sqlite3_result_error_nomem(ctx);\n            goto jsonSetDone;\n        } else if (x.nErr) {\n            goto jsonSetDone;\n        } else if (pNode && (bApnd || bIsSet)) {\n            ;\n            ((void)0);\n            ;\n            pNode->jnFlags |= (u8)8;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        ((void)0);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  jsonSetDone:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "sqlite3.c#200270:1#jsonReplaceFunc",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, \"replace\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    ((void)0);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto replace_err;\n        if (pNode) {\n            ((void)0);\n            ;\n            pNode->jnFlags |= (u8)8;\n            ;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        ((void)0);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  replace_err:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "sqlite3.c#200237:1#jsonRemoveFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    ((void)0);\n    for (i = 1; i < (u32)argc; i++) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        if (zPath == 0)\n            goto remove_done;\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto remove_done;\n        if (pNode)\n            pNode->jnFlags |= 4;\n    }\n    if ((x.aNode[0].jnFlags & 4) == 0) {\n        jsonReturnJson(x.aNode, ctx, 0);\n    }\n  remove_done:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "sqlite3.c#199753:1#jsonLookup",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const char *zErr = 0;\n    JsonNode *pNode = 0;\n    char *zMsg;\n    if (zPath == 0)\n        return 0;\n    if (zPath[0] != '$') {\n        zErr = zPath;\n        goto lookup_err;\n    }\n    zPath++;\n    pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);\n    if (zErr == 0)\n        return pNode;\n  lookup_err:\n    pParse->nErr++;\n    ((void)0);\n    zMsg = jsonPathSyntaxError(zErr);\n    if (zMsg) {\n        sqlite3_result_error(pCtx, zMsg, -1);\n        sqlite3_free(zMsg);\n    } else {\n        sqlite3_result_error_nomem(pCtx);\n    }\n    return 0;\n}\n"
  },
  {
    "id": "sqlite3.c#198992:1#jsonReturn",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    switch (pNode->eType) {\n      default:\n        {\n            ((void)0);\n            sqlite3_result_null(pCtx);\n            break;\n        }\n      case 1:\n        {\n            sqlite3_result_int(pCtx, 1);\n            break;\n        }\n      case 2:\n        {\n            sqlite3_result_int(pCtx, 0);\n            break;\n        }\n      case 3:\n        {\n            sqlite3_int64 i = 0;\n            const char *z;\n            ((void)0);\n            z = pNode->u.zJContent;\n            if (z[0] == '-') {\n                z++;\n            }\n            while (z[0] >= '0' && z[0] <= '9')\n                {\n                    unsigned int v = *(z++) - '0';\n                    if (i >= (4294967295U | (((i64)2147483647) << 32)) / 10) {\n                        if (i > (4294967295U | (((i64)2147483647) << 32)) / 10)\n                            goto int_as_real;\n                        if (z[0] >= '0' && z[0] <= '9')\n                            goto int_as_real;\n                        if (v == 9)\n                            goto int_as_real;\n                        if (v == 8) {\n                            if (pNode->u.zJContent[0] == '-') {\n                                sqlite3_result_int64(pCtx, (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))));\n                                goto int_done;\n                            } else {\n                                goto int_as_real;\n                            }\n                        }\n                    }\n                    i = i * 10 + v;\n                }\n            if (pNode->u.zJContent[0] == '-') {\n                i = -i;\n            }\n            sqlite3_result_int64(pCtx, i);\n          int_done:\n            break;\n          int_as_real:\n            ;\n        }\n      case 4:\n        {\n            double r;\n            const char *z;\n            ((void)0);\n            z = pNode->u.zJContent;\n            sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);\n            sqlite3_result_double(pCtx, r);\n            break;\n        }\n      case 5:\n        {\n            ((void)0);\n            if ((pNode->jnFlags & 2) == 0) {\n                ((void)0);\n                sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2, ((sqlite3_destructor_type)-1));\n            } else {\n                u32 i;\n                u32 n = pNode->n;\n                const char *z;\n                char *zOut;\n                u32 j;\n                ((void)0);\n                z = pNode->u.zJContent;\n                zOut = sqlite3_malloc(n + 1);\n                if (zOut == 0) {\n                    sqlite3_result_error_nomem(pCtx);\n                    break;\n                }\n                for (i = 1 , j = 0; i < n - 1; i++) {\n                    char c = z[i];\n                    if (c != '\\\\') {\n                        zOut[j++] = c;\n                    } else {\n                        c = z[++i];\n                        if (c == 'u') {\n                            u32 v = jsonHexToInt4(z + i + 1);\n                            i += 4;\n                            if (v == 0)\n                                break;\n                            if (v <= 127) {\n                                zOut[j++] = (char)v;\n                            } else if (v <= 2047) {\n                                zOut[j++] = (char)(192 | (v >> 6));\n                                zOut[j++] = 128 | (v & 63);\n                            } else {\n                                u32 vlo;\n                                if ((v & 64512) == 55296 && i < n - 6 && z[i + 1] == '\\\\' && z[i + 2] == 'u' && ((vlo = jsonHexToInt4(z + i + 3)) & 64512) == 56320) {\n                                    v = ((v & 1023) << 10) + (vlo & 1023) + 65536;\n                                    i += 6;\n                                    zOut[j++] = 240 | (v >> 18);\n                                    zOut[j++] = 128 | ((v >> 12) & 63);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                } else {\n                                    zOut[j++] = 224 | (v >> 12);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                }\n                            }\n                        } else {\n                            if (c == 'b') {\n                                c = '\\b';\n                            } else if (c == 'f') {\n                                c = '\\f';\n                            } else if (c == 'n') {\n                                c = '\\n';\n                            } else if (c == 'r') {\n                                c = '\\r';\n                            } else if (c == 't') {\n                                c = '\\t';\n                            }\n                            zOut[j++] = c;\n                        }\n                    }\n                }\n                zOut[j] = 0;\n                sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n            }\n            break;\n        }\n      case 6:\n      case 7:\n        {\n            jsonReturnJson(pNode, pCtx, aReplace);\n            break;\n        }\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#175640:1#createFunctionApi",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc = 1;\n    FuncDestructor *pArg = 0;\n    sqlite3_mutex_enter(db->mutex);\n    if (xDestroy) {\n        pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));\n        if (!pArg) {\n            sqlite3OomFault(db);\n            xDestroy(p);\n            goto out;\n        }\n        pArg->nRef = 0;\n        pArg->xDestroy = xDestroy;\n        pArg->pUserData = p;\n    }\n    rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, xValue, xInverse, pArg);\n    if (pArg && pArg->nRef == 0) {\n        ((void)0);\n        xDestroy(p);\n        sqlite3_free(pArg);\n    }\n  out:\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3WindowAlloc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Window *pWin = 0;\n    int bImplicitFrame = 0;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (eType == 0) {\n        bImplicitFrame = 1;\n        eType = 89;\n    }\n    if ((eStart == 85 && eEnd == 88) || (eStart == 86 && (eEnd == 88 || eEnd == 85))) {\n        sqlite3ErrorMsg(pParse, \"unsupported frame specification\");\n        goto windowAllocErr;\n    }\n    pWin = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n    if (pWin == 0)\n        goto windowAllocErr;\n    pWin->eFrmType = eType;\n    pWin->eStart = eStart;\n    pWin->eEnd = eEnd;\n    if (eExclude == 0 && (((pParse->db)->dbOptFlags & (2)) != 0)) {\n        eExclude = 66;\n    }\n    pWin->eExclude = eExclude;\n    pWin->bImplicitFrame = bImplicitFrame;\n    pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);\n    pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);\n    return pWin;\n  windowAllocErr:\n    sqlite3ExprDelete(pParse->db, pEnd);\n    sqlite3ExprDelete(pParse->db, pStart);\n    return 0;\n}\n"
  },
  {
    "id": "sqlite3.c#163608:1#nth_valueStepFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    struct NthValueCtx *p;\n    p = (struct NthValueCtx *)sqlite3_aggregate_context(pCtx, sizeof (*p));\n    if (p) {\n        i64 iVal;\n        switch (sqlite3_value_numeric_type(apArg[1])) {\n          case 1:\n            iVal = sqlite3_value_int64(apArg[1]);\n            break;\n          case 2:\n            {\n                double fVal = sqlite3_value_double(apArg[1]);\n                if (((i64)fVal) != fVal)\n                    goto error_out;\n                iVal = (i64)fVal;\n                break;\n            }\n          default:\n            goto error_out;\n        }\n        if (iVal <= 0)\n            goto error_out;\n        p->nStep++;\n        if (iVal == p->nStep) {\n            p->pValue = sqlite3_value_dup(apArg[0]);\n            if (!p->pValue) {\n                sqlite3_result_error_nomem(pCtx);\n            }\n        }\n    }\n    (void)(nArg);\n    (void)(apArg);\n    return;\n  error_out:\n    sqlite3_result_error(pCtx, \"second argument to nth_value must be a positive integer\", -1);\n}\n"
  },
  {
    "id": "sqlite3.c#157512:1#constructAutomaticIndex",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int nKeyCol;\n    WhereTerm *pTerm;\n    WhereTerm *pWCEnd;\n    Index *pIdx;\n    Vdbe *v;\n    int addrInit;\n    Table *pTable;\n    int addrTop;\n    int regRecord;\n    int n;\n    int i;\n    int mxBitCol;\n    CollSeq *pColl;\n    WhereLoop *pLoop;\n    char *zNotUsed;\n    Bitmask idxCols;\n    Bitmask extraCols;\n    u8 sentWarning = 0;\n    Expr *pPartial = 0;\n    int iContinue = 0;\n    SrcItem *pTabItem;\n    int addrCounter = 0;\n    int regBase;\n    v = pParse->pVdbe;\n    ((void)0);\n    addrInit = sqlite3VdbeAddOp0(v, 15);\n    ;\n    nKeyCol = 0;\n    pTable = pSrc->pTab;\n    pWCEnd = &pWC->a[pWC->nTerm];\n    pLoop = pLevel->pWLoop;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        Expr *pExpr = pTerm->pExpr;\n        if ((pTerm->wtFlags & 2) == 0 && sqlite3ExprIsTableConstraint(pExpr, pSrc)) {\n            pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse->db, pExpr, 0));\n        }\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            ((void)0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if (!sentWarning) {\n                sqlite3_log((28 | (1 << 8)), \"automatic index on %s(%s)\", pTable->zName, pTable->aCol[iCol].zCnName);\n                sentWarning = 1;\n            }\n            if ((idxCols & cMask) == 0) {\n                if (whereLoopResize(pParse->db, pLoop, nKeyCol + 1)) {\n                    goto end_auto_index_create;\n                }\n                pLoop->aLTerm[nKeyCol++] = pTerm;\n                idxCols |= cMask;\n            }\n        }\n    }\n    ((void)0);\n    pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;\n    pLoop->wsFlags = 1 | 64 | 512 | 16384;\n    extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)));\n    mxBitCol = ((((int)(sizeof(Bitmask) * 8)) - 1) < (pTable->nCol) ? (((int)(sizeof(Bitmask) * 8)) - 1) : (pTable->nCol));\n    ;\n    ;\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i)))\n            nKeyCol++;\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        nKeyCol += pTable->nCol - ((int)(sizeof(Bitmask) * 8)) + 1;\n    }\n    pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol + 1, 0, &zNotUsed);\n    if (pIdx == 0)\n        goto end_auto_index_create;\n    pLoop->u.btree.pIndex = pIdx;\n    pIdx->zName = \"auto-index\";\n    pIdx->pTable = pTable;\n    n = 0;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            ((void)0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if ((idxCols & cMask) == 0) {\n                Expr *pX = pTerm->pExpr;\n                idxCols |= cMask;\n                pIdx->aiColumn[n] = pTerm->u.x.leftColumn;\n                pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n                ((void)0);\n                pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;\n                n++;\n            }\n        }\n    }\n    ((void)0);\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i))) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        for (i = ((int)(sizeof(Bitmask) * 8)) - 1; i < pTable->nCol; i++) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    ((void)0);\n    pIdx->aiColumn[n] = (-1);\n    pIdx->azColl[n] = sqlite3StrBINARY;\n    ;\n    ((void)0);\n    pLevel->iIdxCur = pParse->nTab++;\n    sqlite3VdbeAddOp2(v, 116, pLevel->iIdxCur, nKeyCol + 1);\n    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n    ;\n    if ((((pParse->db)->dbOptFlags & (524288)) == 0)) {\n        pLevel->regFilter = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 77, 10000, pLevel->regFilter);\n    }\n    pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        addrCounter = sqlite3VdbeAddOp2(v, 71, 0, 0);\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        addrTop = sqlite3VdbeAddOp1(v, 12, regYield);\n        ;\n        ;\n    } else {\n        addrTop = sqlite3VdbeAddOp1(v, 36, pLevel->iTabCur);\n        ;\n    }\n    if (pPartial) {\n        iContinue = sqlite3VdbeMakeLabel(pParse);\n        sqlite3ExprIfFalse(pParse, pPartial, iContinue, 16);\n        pLoop->wsFlags |= 131072;\n    }\n    regRecord = sqlite3GetTempReg(pParse);\n    regBase = sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0);\n    if (pLevel->regFilter) {\n        sqlite3VdbeAddOp4Int(v, 180, pLevel->regFilter, 0, regBase, pLoop->u.btree.nEq);\n    }\n    ;\n    sqlite3VdbeAddOp2(v, 138, pLevel->iIdxCur, regRecord);\n    sqlite3VdbeChangeP5(v, 16);\n    if (pPartial)\n        sqlite3VdbeResolveLabel(v, iContinue);\n    if (pTabItem->fg.viaCoroutine) {\n        sqlite3VdbeChangeP2(v, addrCounter, regBase + n);\n        ;\n        ((void)0);\n        translateColumnToCopy(pParse, addrTop, pLevel->iTabCur, pTabItem->regResult, pLevel->iIdxCur);\n        sqlite3VdbeGoto(v, addrTop);\n        pTabItem->fg.viaCoroutine = 0;\n    } else {\n        sqlite3VdbeAddOp2(v, 39, pLevel->iTabCur, addrTop + 1);\n        ;\n        sqlite3VdbeChangeP5(v, 3);\n    }\n    sqlite3VdbeJumpHere(v, addrTop);\n    sqlite3ReleaseTempReg(pParse, regRecord);\n    sqlite3VdbeJumpHere(v, addrInit);\n    ;\n  end_auto_index_create:\n    sqlite3ExprDelete(pParse->db, pPartial);\n}\n"
  },
  {
    "id": "sqlite3.c#156844:1#whereOrInsert",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u16 i;\n    WhereOrCost *p;\n    for (i = pSet->n , p = pSet->a; i > 0; i-- , p++) {\n        if (rRun <= p->rRun && (prereq & p->prereq) == prereq) {\n            goto whereOrInsert_done;\n        }\n        if (p->rRun <= rRun && (p->prereq & prereq) == p->prereq) {\n            return 0;\n        }\n    }\n    if (pSet->n < 3) {\n        p = &pSet->a[pSet->n++];\n        p->nOut = nOut;\n    } else {\n        p = pSet->a;\n        for (i = 1; i < pSet->n; i++) {\n            if (p->rRun > pSet->a[i].rRun)\n                p = pSet->a + i;\n        }\n        if (p->rRun <= rRun)\n            return 0;\n    }\n  whereOrInsert_done:\n    p->prereq = prereq;\n    p->rRun = rRun;\n    if (p->nOut > nOut)\n        p->nOut = nOut;\n    return 1;\n}\n"
  },
  {
    "id": "#23:25#sqlite3RunVacuum",
    "gotos": 12,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    Btree *pMain;\n    Btree *pTemp;\n    u32 saved_mDbFlags;\n    u64 saved_flags;\n    i64 saved_nChange;\n    i64 saved_nTotalChange;\n    u32 saved_openFlags;\n    u8 saved_mTrace;\n    Db *pDb = 0;\n    int isMemDb;\n    int nRes;\n    int nDb;\n    const char *zDbMain;\n    const char *zOut;\n    u32 pgflags = 1;\n    if (!db->autoCommit) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM from within a transaction\");\n        return 1;\n    }\n    if (db->nVdbeActive > 1) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM - SQL statements in progress\");\n        return 1;\n    }\n    saved_openFlags = db->openFlags;\n    if (pOut) {\n        if (sqlite3_value_type(pOut) != 3) {\n            sqlite3SetString(pzErrMsg, db, \"non-text filename\");\n            return 1;\n        }\n        zOut = (const char *)sqlite3_value_text(pOut);\n        db->openFlags &= ~1;\n        db->openFlags |= 4 | 2;\n    } else {\n        zOut = \"\";\n    }\n    saved_flags = db->flags;\n    saved_mDbFlags = db->mDbFlags;\n    saved_nChange = db->nChange;\n    saved_nTotalChange = db->nTotalChange;\n    saved_mTrace = db->mTrace;\n    db->flags |= 1 | 512;\n    db->mDbFlags |= 2 | 4;\n    db->flags &= ~(u64)(16384 | 4096 | 268435456 | ((u64)(1) << 32));\n    db->mTrace = 0;\n    zDbMain = db->aDb[iDb].zDbSName;\n    pMain = db->aDb[iDb].pBt;\n    isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));\n    nDb = db->nDb;\n    rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut);\n    db->openFlags = saved_openFlags;\n    if (rc != 0)\n        goto end_of_vacuum;\n    ((void)0);\n    pDb = &db->aDb[nDb];\n    ((void)0);\n    pTemp = pDb->pBt;\n    if (pOut) {\n        sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));\n        i64 sz = 0;\n        if (id->pMethods != 0 && (sqlite3OsFileSize(id, &sz) != 0 || sz > 0)) {\n            rc = 1;\n            sqlite3SetString(pzErrMsg, db, \"output file already exists\");\n            goto end_of_vacuum;\n        }\n        db->mDbFlags |= 8;\n        pgflags = db->aDb[iDb].safety_level | (db->flags & 56);\n    }\n    nRes = sqlite3BtreeGetRequestedReserve(pMain);\n    sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);\n    sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain, 0));\n    sqlite3BtreeSetPagerFlags(pTemp, pgflags | 32);\n    rc = execSql(db, pzErrMsg, \"BEGIN\");\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = sqlite3BtreeBeginTrans(pMain, pOut == 0 ? 2 : 0, 0);\n    if (rc != 0)\n        goto end_of_vacuum;\n    if (sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain)) == 5 && pOut == 0) {\n        db->nextPagesize = 0;\n    }\n    if (sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0)) || (db->mallocFailed)) {\n        rc = 7;\n        goto end_of_vacuum;\n    }\n    sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac >= 0 ? db->nextAutovac : sqlite3BtreeGetAutoVacuum(pMain));\n    db->init.iDb = nDb;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='index'\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    db->init.iDb = 0;\n    rc = execSqlF(db, pzErrMsg, \"SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\\\"%w\\\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)>0\", zDbMain);\n    ((void)0);\n    db->mDbFlags &= ~4;\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \\\"%w\\\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)\", zDbMain);\n    if (rc)\n        goto end_of_vacuum;\n    {\n        u32 meta;\n        int i;\n        static const unsigned char aCopy[] = {1, 1, 3, 0, 5, 0, 6, 0, 8, 0};\n        ((void)0);\n        ((void)0);\n        for (i = 0; i < ((int)(sizeof (aCopy) / sizeof (aCopy[0]))); i += 2) {\n            sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);\n            rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta + aCopy[i + 1]);\n            if ((rc != 0))\n                goto end_of_vacuum;\n        }\n        if (pOut == 0) {\n            rc = sqlite3BtreeCopyFile(pMain, pTemp);\n        }\n        if (rc != 0)\n            goto end_of_vacuum;\n        rc = sqlite3BtreeCommit(pTemp);\n        if (rc != 0)\n            goto end_of_vacuum;\n        if (pOut == 0) {\n            sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));\n        }\n    }\n    ((void)0);\n    if (pOut == 0) {\n        nRes = sqlite3BtreeGetRequestedReserve(pTemp);\n        rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1);\n    }\n  end_of_vacuum:\n    db->init.iDb = 0;\n    db->mDbFlags = saved_mDbFlags;\n    db->flags = saved_flags;\n    db->nChange = saved_nChange;\n    db->nTotalChange = saved_nTotalChange;\n    db->mTrace = saved_mTrace;\n    sqlite3BtreeSetPageSize(pMain, -1, 0, 1);\n    db->autoCommit = 1;\n    if (pDb) {\n        sqlite3BtreeClose(pDb->pBt);\n        pDb->pBt = 0;\n        pDb->pSchema = 0;\n    }\n    sqlite3ResetAllSchemasOfConnection(db);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Vacuum",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    int iDb = 0;\n    if (v == 0)\n        goto build_vacuum_end;\n    if (pParse->nErr)\n        goto build_vacuum_end;\n    if (pNm) {\n        iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);\n        if (iDb < 0)\n            goto build_vacuum_end;\n    }\n    if (iDb != 1) {\n        int iIntoReg = 0;\n        if (pInto && sqlite3ResolveSelfReference(pParse, 0, 0, pInto, 0) == 0) {\n            iIntoReg = ++pParse->nMem;\n            sqlite3ExprCode(pParse, pInto, iIntoReg);\n        }\n        sqlite3VdbeAddOp2(v, 5, iDb, iIntoReg);\n        sqlite3VdbeUsesBtree(v, iDb);\n    }\n  build_vacuum_end:\n    sqlite3ExprDelete(pParse->db, pInto);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Update",
    "gotos": 13,
    "labels": 1,
    "body": "{\n    int i, j, k;\n    Table *pTab;\n    int addrTop = 0;\n    WhereInfo *pWInfo = 0;\n    Vdbe *v;\n    Index *pIdx;\n    Index *pPk;\n    int nIdx;\n    int nAllIdx;\n    int iBaseCur;\n    int iDataCur;\n    int iIdxCur;\n    sqlite3 *db;\n    int *aRegIdx = 0;\n    int *aXRef = 0;\n    u8 *aToOpen;\n    u8 chngPk;\n    u8 chngRowid;\n    u8 chngKey;\n    Expr *pRowidExpr = 0;\n    int iRowidExpr = -1;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int eOnePass;\n    int hasFK;\n    int labelBreak;\n    int labelContinue;\n    int flags;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    int newmask;\n    int iEph = 0;\n    int nKey = 0;\n    int aiCurOnePass[2];\n    int addrOpen = 0;\n    int iPk = 0;\n    i16 nPk = 0;\n    int bReplace = 0;\n    int bFinishSeek = 1;\n    int nChangeFrom = 0;\n    int regRowCount = 0;\n    int regOldRowid = 0;\n    int regNewRowid = 0;\n    int regNew = 0;\n    int regOld = 0;\n    int regRowSet = 0;\n    int regKey = 0;\n    __builtin___memset_chk(&sContext, 0, sizeof (sContext), __builtin_object_size(&sContext, 0));\n    db = pParse->db;\n    ((void)0);\n    if (pParse->nErr) {\n        goto update_cleanup;\n    }\n    ((void)0);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto update_cleanup;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 129, pChanges, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    ((void)0);\n    nChangeFrom = (pTabList->nSrc > 1) ? pChanges->nExpr : 0;\n    ((void)0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto update_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto update_cleanup;\n    }\n    iBaseCur = iDataCur = pParse->nTab++;\n    iIdxCur = iDataCur + 1;\n    pPk = (((pTab)->tabFlags & 128) == 0) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n    ;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        if (pPk == pIdx) {\n            iDataCur = pParse->nTab;\n        }\n        pParse->nTab++;\n    }\n    if (pUpsert) {\n        iDataCur = pUpsert->iDataCur;\n        iIdxCur = pUpsert->iIdxCur;\n        pParse->nTab = iBaseCur;\n    }\n    pTabList->a[0].iCursor = iDataCur;\n    aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol + nIdx + 1) + nIdx + 2);\n    if (aXRef == 0)\n        goto update_cleanup;\n    aRegIdx = aXRef + pTab->nCol;\n    aToOpen = (u8 *)(aRegIdx + nIdx + 1);\n    __builtin___memset_chk(aToOpen, 1, nIdx + 1, __builtin_object_size(aToOpen, 0));\n    aToOpen[nIdx + 1] = 0;\n    for (i = 0; i < pTab->nCol; i++)\n        aXRef[i] = -1;\n    __builtin___memset_chk(&sNC, 0, sizeof (sNC), __builtin_object_size(&sNC, 0));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pUpsert = pUpsert;\n    sNC.ncFlags = 512;\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto update_cleanup;\n    chngRowid = chngPk = 0;\n    for (i = 0; i < pChanges->nExpr; i++) {\n        u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);\n        if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr)) {\n            goto update_cleanup;\n        }\n        for (j = 0; j < pTab->nCol; j++) {\n            if (pTab->aCol[j].hName == hCol && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName) == 0) {\n                if (j == pTab->iPKey) {\n                    chngRowid = 1;\n                    pRowidExpr = pChanges->a[i].pExpr;\n                    iRowidExpr = i;\n                } else if (pPk && (pTab->aCol[j].colFlags & 1) != 0) {\n                    chngPk = 1;\n                } else if (pTab->aCol[j].colFlags & 96) {\n                    ;\n                    ;\n                    sqlite3ErrorMsg(pParse, \"cannot UPDATE generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                    goto update_cleanup;\n                }\n                aXRef[j] = i;\n                break;\n            }\n        }\n        if (j >= pTab->nCol) {\n            if (pPk == 0 && sqlite3IsRowid(pChanges->a[i].zEName)) {\n                j = -1;\n                chngRowid = 1;\n                pRowidExpr = pChanges->a[i].pExpr;\n                iRowidExpr = i;\n            } else {\n                sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);\n                pParse->checkSchema = 1;\n                goto update_cleanup;\n            }\n        }\n        {\n            int rc;\n            rc = sqlite3AuthCheck(pParse, 23, pTab->zName, j < 0 ? \"ROWID\" : pTab->aCol[j].zCnName, db->aDb[iDb].zDbSName);\n            if (rc == 1) {\n                goto update_cleanup;\n            } else if (rc == 2) {\n                aXRef[j] = -1;\n            }\n        }\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    chngKey = chngRowid + chngPk;\n    if (pTab->tabFlags & 96) {\n        int bProgress;\n        ;\n        ;\n        do {\n            bProgress = 0;\n            for (i = 0; i < pTab->nCol; i++) {\n                if (aXRef[i] >= 0)\n                    continue;\n                if ((pTab->aCol[i].colFlags & 96) == 0)\n                    continue;\n                if (sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &pTab->aCol[i]), aXRef, chngRowid)) {\n                    aXRef[i] = 99999;\n                    bProgress = 1;\n                }\n            }\n        } while (bProgress);\n    }\n    pTabList->a[0].colUsed = ((pTab)->eTabType == 1) ? ((Bitmask)-1) : 0;\n    hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);\n    if (onError == 5)\n        bReplace = 1;\n    for (nAllIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nAllIdx++) {\n        int reg;\n        if (chngKey || hasFK > 1 || pIdx == pPk || indexWhereClauseMightChange(pIdx, aXRef, chngRowid)) {\n            reg = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        } else {\n            reg = 0;\n            for (i = 0; i < pIdx->nKeyCol; i++) {\n                if (indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid)) {\n                    reg = ++pParse->nMem;\n                    pParse->nMem += pIdx->nColumn;\n                    if (onError == 11 && pIdx->onError == 5) {\n                        bReplace = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (reg == 0)\n            aToOpen[nAllIdx + 1] = 0;\n        aRegIdx[nAllIdx] = reg;\n    }\n    aRegIdx[nAllIdx] = ++pParse->nMem;\n    if (bReplace) {\n        __builtin___memset_chk(aToOpen, 1, nIdx + 1, __builtin_object_size(aToOpen, 0));\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);\n    if (!((pTab)->eTabType == 1)) {\n        ((void)0);\n        regRowSet = aRegIdx[nAllIdx];\n        regOldRowid = regNewRowid = ++pParse->nMem;\n        if (chngPk || pTrigger || hasFK) {\n            regOld = pParse->nMem + 1;\n            pParse->nMem += pTab->nCol;\n        }\n        if (chngKey || pTrigger || hasFK) {\n            regNewRowid = ++pParse->nMem;\n        }\n        regNew = pParse->nMem + 1;\n        pParse->nMem += pTab->nCol;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    if (nChangeFrom == 0 && isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iDataCur);\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto update_cleanup;\n    }\n    if (((pTab)->eTabType == 1)) {\n        updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, onError);\n        goto update_cleanup;\n    }\n    labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (nChangeFrom == 0 && (((pTab)->tabFlags & 128) == 0)) {\n        sqlite3VdbeAddOp3(v, 75, 0, regRowSet, regOldRowid);\n        iEph = pParse->nTab++;\n        addrOpen = sqlite3VdbeAddOp3(v, 118, iEph, 0, regRowSet);\n    } else {\n        ((void)0);\n        nPk = pPk ? pPk->nKeyCol : 0;\n        iPk = pParse->nMem + 1;\n        pParse->nMem += nPk;\n        pParse->nMem += nChangeFrom;\n        regKey = ++pParse->nMem;\n        if (pUpsert == 0) {\n            int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);\n            iEph = pParse->nTab++;\n            if (pPk)\n                sqlite3VdbeAddOp3(v, 75, 0, iPk, iPk + nPk - 1);\n            addrOpen = sqlite3VdbeAddOp2(v, 118, iEph, nEphCol);\n            if (pPk) {\n                KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);\n                if (pKeyInfo) {\n                    pKeyInfo->nAllField = nEphCol;\n                    sqlite3VdbeAppendP4(v, pKeyInfo, (-8));\n                }\n            }\n            if (nChangeFrom) {\n                updateFromSelect(pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);\n                if (isView)\n                    iDataCur = iEph;\n            }\n        }\n    }\n    if (nChangeFrom) {\n        sqlite3MultiWrite(pParse);\n        eOnePass = 0;\n        nKey = nPk;\n        regKey = iPk;\n    } else {\n        if (pUpsert) {\n            pWInfo = 0;\n            eOnePass = 1;\n            sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 16);\n            bFinishSeek = 0;\n        } else {\n            flags = 4;\n            if (!pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace) {\n                flags |= 8;\n            }\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, flags, iIdxCur);\n            if (pWInfo == 0)\n                goto update_cleanup;\n            eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n            bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n            if (eOnePass != 1) {\n                sqlite3MultiWrite(pParse);\n                if (eOnePass == 2) {\n                    int iCur = aiCurOnePass[1];\n                    if (iCur >= 0 && iCur != iDataCur && aToOpen[iCur - iBaseCur]) {\n                        eOnePass = 0;\n                    }\n                    ((void)0);\n                }\n            }\n        }\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iDataCur, regOldRowid);\n            if (eOnePass == 0) {\n                aRegIdx[nAllIdx] = ++pParse->nMem;\n                sqlite3VdbeAddOp3(v, 128, iEph, regRowSet, regOldRowid);\n            } else {\n                if ((addrOpen))\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n            }\n        } else {\n            for (i = 0; i < nPk; i++) {\n                ((void)0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pPk->aiColumn[i], iPk + i);\n            }\n            if (eOnePass) {\n                if (addrOpen)\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n                nKey = nPk;\n                regKey = iPk;\n            } else {\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, regKey, sqlite3IndexAffinityStr(db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEph, regKey, iPk, nPk);\n            }\n        }\n    }\n    if (pUpsert == 0) {\n        if (nChangeFrom == 0 && eOnePass != 2) {\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int addrOnce = 0;\n            if (eOnePass != 0) {\n                if (aiCurOnePass[0] >= 0)\n                    aToOpen[aiCurOnePass[0] - iBaseCur] = 0;\n                if (aiCurOnePass[1] >= 0)\n                    aToOpen[aiCurOnePass[1] - iBaseCur] = 0;\n            }\n            if (eOnePass == 2 && (nIdx - (aiCurOnePass[1] >= 0)) > 0) {\n                addrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, iBaseCur, aToOpen, 0, 0);\n            if (addrOnce) {\n                sqlite3VdbeJumpHereOrPopInst(v, addrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            if (aiCurOnePass[0] != iDataCur && aiCurOnePass[1] != iDataCur) {\n                ((void)0);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey, nKey);\n                ;\n            }\n            if (eOnePass != 1) {\n                labelContinue = sqlite3VdbeMakeLabel(pParse);\n            }\n            sqlite3VdbeAddOp2(v, 50, pPk ? regKey : regOldRowid, labelBreak);\n            ;\n            ;\n        } else if (pPk || nChangeFrom) {\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            addrTop = sqlite3VdbeCurrentAddr(v);\n            if (nChangeFrom) {\n                if (!isView) {\n                    if (pPk) {\n                        for (i = 0; i < nPk; i++) {\n                            sqlite3VdbeAddOp3(v, 94, iEph, i, iPk + i);\n                        }\n                        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, iPk, nPk);\n                        ;\n                    } else {\n                        sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n                        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                        ;\n                    }\n                }\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEph, regKey);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, 0);\n                ;\n            }\n        } else {\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            addrTop = sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n            ;\n            sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            ;\n        }\n    }\n    ((void)0);\n    if (chngRowid) {\n        ((void)0);\n        if (nChangeFrom == 0) {\n            sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 94, iEph, iRowidExpr, regNewRowid);\n        }\n        sqlite3VdbeAddOp1(v, 13, regNewRowid);\n        ;\n    }\n    if (chngPk || hasFK || pTrigger) {\n        u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);\n        oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 1 | 2, pTab, onError);\n        for (i = 0; i < pTab->nCol; i++) {\n            u32 colFlags = pTab->aCol[i].colFlags;\n            k = sqlite3TableColumnToStorage(pTab, i) + regOld;\n            if (oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0) || (colFlags & 1) != 0) {\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n        if (chngRowid == 0 && pPk == 0) {\n            sqlite3VdbeAddOp2(v, 80, regOldRowid, regNewRowid);\n        }\n    }\n    newmask = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError);\n    for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp2(v, 75, 0, k);\n        } else if ((pTab->aCol[i].colFlags & 96) != 0) {\n            if (pTab->aCol[i].colFlags & 32)\n                k--;\n        } else {\n            j = aXRef[i];\n            if (j >= 0) {\n                if (nChangeFrom) {\n                    int nOff = (isView ? pTab->nCol : nPk);\n                    ((void)0);\n                    sqlite3VdbeAddOp3(v, 94, iEph, nOff + j, k);\n                } else {\n                    sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n                }\n            } else if (0 == (tmask & 1) || i > 31 || (newmask & (((unsigned int)1) << (i)))) {\n                ;\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                bFinishSeek = 0;\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n    }\n    if (pTab->tabFlags & 96) {\n        ;\n        ;\n        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n    }\n    if (tmask & 1) {\n        sqlite3TableAffinity(v, pTab, regNew);\n        sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 1, pTab, regOldRowid, onError, labelContinue);\n        if (!isView) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n                ;\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                ;\n            }\n            for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    if (pTab->aCol[i].colFlags & 32)\n                        k--;\n                } else if (aXRef[i] < 0 && i != pTab->iPKey) {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                }\n            }\n            if (pTab->tabFlags & 96) {\n                ;\n                ;\n                sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n            }\n        }\n    }\n    if (!isView) {\n        ((void)0);\n        sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace, aXRef, 0);\n        if (bReplace || chngKey) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            }\n            ;\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);\n        }\n        sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);\n        if (bFinishSeek) {\n            sqlite3VdbeAddOp1(v, 143, iDataCur);\n        }\n        ((void)0);\n        if (hasFK > 1 || chngKey) {\n            sqlite3VdbeAddOp2(v, 130, iDataCur, 0);\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);\n        }\n        sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx, 4 | (eOnePass == 2 ? 2 : 0), 0, 0);\n        if (hasFK) {\n            sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 2, pTab, regOldRowid, onError, labelContinue);\n    if (eOnePass == 1) {\n    } else if (eOnePass == 2) {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3WhereEnd(pWInfo);\n    } else {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3VdbeAddOp2(v, 39, iEph, addrTop);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, labelBreak);\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0 && pUpsert == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows updated\");\n    }\n  update_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3DbFree(db, aXRef);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pChanges);\n    sqlite3ExprDelete(db, pWhere);\n    return;\n}\n"
  },
  {
    "id": "sqlite3.c#147199:1#triggersReallyExist",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int mask = 0;\n    Trigger *pList = 0;\n    Trigger *p;\n    pList = sqlite3TriggerList(pParse, pTab);\n    ((void)0);\n    if (pList != 0) {\n        p = pList;\n        if ((pParse->db->flags & 262144) == 0 && pTab->pTrigger != 0) {\n            if (pList == pTab->pTrigger) {\n                pList = 0;\n                goto exit_triggers_exist;\n            }\n            while ((p->pNext) && p->pNext != pTab->pTrigger)\n                p = p->pNext;\n            p->pNext = 0;\n            p = pList;\n        }\n        do {\n            if (p->op == op && checkColumnOverlap(p->pColumns, pChanges)) {\n                mask |= p->tr_tm;\n            } else if (p->op == 150) {\n                ((void)0);\n                p->op = op;\n                if (((pTab)->eTabType == 1)) {\n                    if (op != 127) {\n                        sqlite3ErrorMsg(pParse, \"%s RETURNING is not available on virtual tables\", op == 128 ? \"DELETE\" : \"UPDATE\");\n                    }\n                    p->tr_tm = 1;\n                } else {\n                    p->tr_tm = 2;\n                }\n                mask |= p->tr_tm;\n            } else if (p->bReturning && p->op == 127 && op == 129 && ((pParse)->pToplevel == 0)) {\n                mask |= p->tr_tm;\n            }\n            p = p->pNext;\n        } while (p);\n    }\n  exit_triggers_exist:\n    if (pMask) {\n        *pMask = mask;\n    }\n    return (mask ? pList : 0);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BeginTrigger",
    "gotos": 17,
    "labels": 2,
    "body": "{\n    Trigger *pTrigger = 0;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    Token *pName;\n    DbFixer sFix;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (isTemp) {\n        if (pName2->n > 0) {\n            sqlite3ErrorMsg(pParse, \"temporary trigger may not have qualified name\");\n            goto trigger_cleanup;\n        }\n        iDb = 1;\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0) {\n            goto trigger_cleanup;\n        }\n    }\n    if (!pTableName || db->mallocFailed) {\n        goto trigger_cleanup;\n    }\n    if (db->init.busy && iDb != 1) {\n        sqlite3DbFree(db, pTableName->a[0].zDatabase);\n        pTableName->a[0].zDatabase = 0;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (db->init.busy == 0 && pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n        iDb = 1;\n    }\n    if (db->mallocFailed)\n        goto trigger_cleanup;\n    ((void)0);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", pName);\n    if (sqlite3FixSrcList(&sFix, pTableName)) {\n        goto trigger_cleanup;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (!pTab) {\n        goto trigger_orphan_error;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"cannot create triggers on virtual tables\");\n        goto trigger_orphan_error;\n    }\n    zName = sqlite3NameFromToken(db, pName);\n    if (zName == 0) {\n        ((void)0);\n        goto trigger_cleanup;\n    }\n    if (sqlite3CheckObjectName(pParse, zName, \"trigger\", pTab->zName)) {\n        goto trigger_cleanup;\n    }\n    ((void)0);\n    if (!(pParse->eParseMode >= 2)) {\n        if (sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash), zName)) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"trigger %T already exists\", pName);\n            } else {\n                ((void)0);\n                sqlite3CodeVerifySchema(pParse, iDb);\n            }\n            goto trigger_cleanup;\n        }\n    }\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0) {\n        sqlite3ErrorMsg(pParse, \"cannot create trigger on system table\");\n        goto trigger_cleanup;\n    }\n    if (((pTab)->eTabType == 2) && tr_tm != 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create %s trigger on view: %S\", (tr_tm == 33) ? \"BEFORE\" : \"AFTER\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!((pTab)->eTabType == 2) && tr_tm == 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create INSTEAD OF trigger on table: %S\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int code = 7;\n        const char *zDb = db->aDb[iTabDb].zDbSName;\n        const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;\n        if (iTabDb == 1 || isTemp)\n            code = 5;\n        if (sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig)) {\n            goto trigger_cleanup;\n        }\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iTabDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto trigger_cleanup;\n        }\n    }\n    if (tr_tm == 65) {\n        tr_tm = 33;\n    }\n    pTrigger = (Trigger *)sqlite3DbMallocZero(db, sizeof(Trigger));\n    if (pTrigger == 0)\n        goto trigger_cleanup;\n    pTrigger->zName = zName;\n    zName = 0;\n    pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);\n    pTrigger->pSchema = db->aDb[iDb].pSchema;\n    pTrigger->pTabSchema = pTab->pSchema;\n    pTrigger->op = (u8)op;\n    pTrigger->tr_tm = tr_tm == 33 ? 1 : 2;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);\n        pTrigger->pWhen = pWhen;\n        pWhen = 0;\n    } else {\n        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 1);\n    }\n    pTrigger->pColumns = pColumns;\n    pColumns = 0;\n    ((void)0);\n    pParse->pNewTrigger = pTrigger;\n  trigger_cleanup:\n    sqlite3DbFree(db, zName);\n    sqlite3SrcListDelete(db, pTableName);\n    sqlite3IdListDelete(db, pColumns);\n    sqlite3ExprDelete(db, pWhen);\n    if (!pParse->pNewTrigger) {\n        sqlite3DeleteTrigger(db, pTrigger);\n    } else {\n        ((void)0);\n    }\n    return;\n  trigger_orphan_error:\n    if (db->init.iDb == 1) {\n        db->init.orphanTrigger = 1;\n    }\n    goto trigger_cleanup;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Select",
    "gotos": 12,
    "labels": 1,
    "body": "{\n    int i, j;\n    WhereInfo *pWInfo;\n    Vdbe *v;\n    int isAgg;\n    ExprList *pEList = 0;\n    SrcList *pTabList;\n    Expr *pWhere;\n    ExprList *pGroupBy;\n    Expr *pHaving;\n    AggInfo *pAggInfo = 0;\n    int rc = 1;\n    DistinctCtx sDistinct;\n    SortCtx sSort;\n    int iEnd;\n    sqlite3 *db;\n    ExprList *pMinMaxOrderBy = 0;\n    u8 minMaxFlag;\n    db = pParse->db;\n    ((void)0);\n    v = sqlite3GetVdbe(pParse);\n    if (p == 0 || pParse->nErr) {\n        return 1;\n    }\n    ((void)0);\n    if (sqlite3AuthCheck(pParse, 21, 0, 0, 0))\n        return 1;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (((pDest->eDest) <= 6)) {\n        ((void)0);\n        if (p->pOrderBy) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, p->pOrderBy);\n            ;\n            p->pOrderBy = 0;\n        }\n        p->selFlags &= ~1;\n        p->selFlags |= 4194304;\n    }\n    sqlite3SelectPrep(pParse, p, 0);\n    if (pParse->nErr) {\n        goto select_end;\n    }\n    ((void)0);\n    ((void)0);\n    if (p->selFlags & 8388608) {\n        SrcItem *p0 = &p->pSrc->a[0];\n        if (sameSrcAlias(p0, p->pSrc)) {\n            sqlite3ErrorMsg(pParse, \"target object/alias may not appear in FROM clause: %s\", p0->zAlias ? p0->zAlias : p0->pTab->zName);\n            goto select_end;\n        }\n        p->selFlags &= ~8388608;\n    }\n    if (pDest->eDest == 9) {\n        sqlite3GenerateColumnNames(pParse, p);\n    }\n    if (sqlite3WindowRewrite(pParse, p)) {\n        ((void)0);\n        goto select_end;\n    }\n    pTabList = p->pSrc;\n    isAgg = (p->selFlags & 8) != 0;\n    __builtin___memset_chk(&sSort, 0, sizeof (sSort), __builtin_object_size(&sSort, 0));\n    sSort.pOrderBy = p->pOrderBy;\n    for (i = 0; !p->pPrior && i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        Select *pSub = pItem->pSelect;\n        Table *pTab = pItem->pTab;\n        ((void)0);\n        if ((pItem->fg.jointype & (8 | 16)) == 8 && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor) && (((db)->dbOptFlags & (8192)) == 0)) {\n            ;\n            pItem->fg.jointype &= ~(8 | 32);\n            ((void)0);\n            unsetJoinExpr(p->pWhere, pItem->iCursor, pTabList->a[0].fg.jointype & 64);\n        }\n        if (pSub == 0)\n            continue;\n        if (pTab->nCol != pSub->pEList->nExpr) {\n            sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\", pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n            goto select_end;\n        }\n        if ((pSub->selFlags & 8) != 0)\n            continue;\n        ((void)0);\n        if (pSub->pOrderBy != 0 && (p->pOrderBy != 0 || pTabList->nSrc > 1) && pSub->pLimit == 0 && (pSub->selFlags & 134217728) == 0 && (p->selFlags & 134217728) == 0 && (((db)->dbOptFlags & (262144)) == 0)) {\n            ;\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, pSub->pOrderBy);\n            pSub->pOrderBy = 0;\n        }\n        if (pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (32 | 2)) != 0)) {\n            continue;\n        }\n        if (flattenSubquery(pParse, p, i, isAgg)) {\n            if (pParse->nErr)\n                goto select_end;\n            i = -1;\n        }\n        pTabList = p->pSrc;\n        if (db->mallocFailed)\n            goto select_end;\n        if (!((pDest->eDest) <= 8)) {\n            sSort.pOrderBy = p->pOrderBy;\n        }\n    }\n    if (p->pPrior) {\n        rc = multiSelect(pParse, p, pDest);\n        if (p->pNext == 0)\n            sqlite3VdbeExplainPop(pParse);\n        return rc;\n    }\n    if (p->pWhere != 0 && p->pWhere->op == 44 && (((db)->dbOptFlags & (32768)) == 0) && propagateConstants(pParse, p)) {\n    } else {\n        ;\n    }\n    for (i = 0; i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        SrcItem *pPrior;\n        SelectDest dest;\n        Select *pSub;\n        const char *zSavedAuthContext;\n        if (pItem->colUsed == 0 && pItem->zName != 0) {\n            sqlite3AuthCheck(pParse, 20, pItem->zName, \"\", pItem->zDatabase);\n        }\n        pSub = pItem->pSelect;\n        if (pSub == 0)\n            continue;\n        ((void)0);\n        pParse->nHeight += sqlite3SelectExprHeight(p);\n        if ((((db)->dbOptFlags & (4096)) == 0) && (pItem->fg.isCte == 0 || (pItem->u2.pCteUse->eM10d != 0 && pItem->u2.pCteUse->nUse < 2)) && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem)) {\n            ((void)0);\n        } else {\n            ;\n        }\n        zSavedAuthContext = pParse->zAuthContext;\n        pParse->zAuthContext = pItem->zName;\n        if (fromClauseTermCanBeCoroutine(pParse, pTabList, i, p->selFlags)) {\n            int addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n            pItem->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp3(v, 11, pItem->regReturn, 0, addrTop);\n            ;\n            pItem->addrFillSub = addrTop;\n            sqlite3SelectDestInit(&dest, 13, pItem->regReturn);\n            sqlite3VdbeExplain(pParse, 1, \"CO-ROUTINE %!S\", pItem);\n            sqlite3Select(pParse, pSub, &dest);\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            pItem->fg.viaCoroutine = 1;\n            pItem->regResult = dest.iSdst;\n            sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n            sqlite3VdbeJumpHere(v, addrTop - 1);\n            sqlite3ClearTempRegCache(pParse);\n        } else if (pItem->fg.isCte && pItem->u2.pCteUse->addrM9e > 0) {\n            CteUse *pCteUse = pItem->u2.pCteUse;\n            sqlite3VdbeAddOp2(v, 10, pCteUse->regRtn, pCteUse->addrM9e);\n            if (pItem->iCursor != pCteUse->iCur) {\n                sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pCteUse->iCur);\n                ;\n            }\n            pSub->nSelectRow = pCteUse->nRowEst;\n        } else if ((pPrior = isSelfJoinView(pTabList, pItem, 0, i)) != 0) {\n            if (pPrior->addrFillSub) {\n                sqlite3VdbeAddOp2(v, 10, pPrior->regReturn, pPrior->addrFillSub);\n            }\n            sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pPrior->iCursor);\n            pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n        } else {\n            int topAddr;\n            int onceAddr = 0;\n            pItem->regReturn = ++pParse->nMem;\n            topAddr = sqlite3VdbeAddOp0(v, 9);\n            pItem->addrFillSub = topAddr + 1;\n            pItem->fg.isMaterialized = 1;\n            if (pItem->fg.isCorrelated == 0) {\n                onceAddr = sqlite3VdbeAddOp0(v, 15);\n                ;\n                ;\n            } else {\n                ;\n            }\n            sqlite3SelectDestInit(&dest, 12, pItem->iCursor);\n            sqlite3VdbeExplain(pParse, 1, \"MATERIALIZE %!S\", pItem);\n            sqlite3Select(pParse, pSub, &dest);\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            if (onceAddr)\n                sqlite3VdbeJumpHere(v, onceAddr);\n            sqlite3VdbeAddOp2(v, 67, pItem->regReturn, topAddr + 1);\n            ;\n            ;\n            sqlite3VdbeJumpHere(v, topAddr);\n            sqlite3ClearTempRegCache(pParse);\n            if (pItem->fg.isCte && pItem->fg.isCorrelated == 0) {\n                CteUse *pCteUse = pItem->u2.pCteUse;\n                pCteUse->addrM9e = pItem->addrFillSub;\n                pCteUse->regRtn = pItem->regReturn;\n                pCteUse->iCur = pItem->iCursor;\n                pCteUse->nRowEst = pSub->nSelectRow;\n            }\n        }\n        if (db->mallocFailed)\n            goto select_end;\n        pParse->nHeight -= sqlite3SelectExprHeight(p);\n        pParse->zAuthContext = zSavedAuthContext;\n    }\n    pEList = p->pEList;\n    pWhere = p->pWhere;\n    pGroupBy = p->pGroupBy;\n    pHaving = p->pHaving;\n    sDistinct.isTnct = (p->selFlags & 1) != 0;\n    if ((p->selFlags & (1 | 8)) == 1 && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1) == 0 && p->pWin == 0) {\n        p->selFlags &= ~1;\n        pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n        p->selFlags |= 8;\n        ((void)0);\n        sDistinct.isTnct = 2;\n    }\n    if (sSort.pOrderBy) {\n        KeyInfo *pKeyInfo;\n        pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList->nExpr);\n        sSort.iECursor = pParse->nTab++;\n        sSort.addrSortIndex = sqlite3VdbeAddOp4(v, 118, sSort.iECursor, sSort.pOrderBy->nExpr + 1 + pEList->nExpr, 0, (char *)pKeyInfo, (-8));\n    } else {\n        sSort.addrSortIndex = -1;\n    }\n    if (pDest->eDest == 12) {\n        sqlite3VdbeAddOp2(v, 118, pDest->iSDParm, pEList->nExpr);\n        if (p->selFlags & 2048) {\n            int ii;\n            for (ii = pEList->nExpr - 1; ii > 0 && pEList->a[ii].fg.bUsed == 0; ii--) {\n                sqlite3ExprDelete(db, pEList->a[ii].pExpr);\n                sqlite3DbFree(db, pEList->a[ii].zEName);\n                pEList->nExpr--;\n            }\n            for (ii = 0; ii < pEList->nExpr; ii++) {\n                if (pEList->a[ii].fg.bUsed == 0)\n                    pEList->a[ii].pExpr->op = 121;\n            }\n        }\n    }\n    iEnd = sqlite3VdbeMakeLabel(pParse);\n    if ((p->selFlags & 16384) == 0) {\n        p->nSelectRow = 320;\n    }\n    if (p->pLimit)\n        computeLimitRegisters(pParse, p, iEnd);\n    if (p->iLimit == 0 && sSort.addrSortIndex >= 0) {\n        sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, 119);\n        sSort.sortFlags |= 1;\n    }\n    if (p->selFlags & 1) {\n        sDistinct.tabTnct = pParse->nTab++;\n        sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 118, sDistinct.tabTnct, 0, 0, (char *)sqlite3KeyInfoFromExprList(pParse, p->pEList, 0, 0), (-8));\n        sqlite3VdbeChangeP5(v, 8);\n        sDistinct.eTnctType = 3;\n    } else {\n        sDistinct.eTnctType = 0;\n    }\n    if (!isAgg && pGroupBy == 0) {\n        u16 wctrlFlags = (sDistinct.isTnct ? 256 : 0) | (p->selFlags & 16384);\n        Window *pWin = p->pWin;\n        if (pWin) {\n            sqlite3WindowCodeInit(pParse, p);\n        }\n        ((void)0);\n        ;\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p->pEList, p, wctrlFlags, p->nSelectRow);\n        if (pWInfo == 0)\n            goto select_end;\n        if (sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow) {\n            p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n        }\n        if (sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo)) {\n            sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n        }\n        if (sSort.pOrderBy) {\n            sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n            sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n            if (sSort.nOBSat == sSort.pOrderBy->nExpr) {\n                sSort.pOrderBy = 0;\n            }\n        }\n        ;\n        if (sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0) {\n            sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n        }\n        ((void)0);\n        if (pWin) {\n            int addrGosub = sqlite3VdbeMakeLabel(pParse);\n            int iCont = sqlite3VdbeMakeLabel(pParse);\n            int iBreak = sqlite3VdbeMakeLabel(pParse);\n            int regGosub = ++pParse->nMem;\n            sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n            sqlite3VdbeAddOp2(v, 9, 0, iBreak);\n            sqlite3VdbeResolveLabel(v, addrGosub);\n            ;\n            sSort.labelOBLopt = 0;\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n            sqlite3VdbeResolveLabel(v, iCont);\n            sqlite3VdbeAddOp1(v, 67, regGosub);\n            ;\n            sqlite3VdbeResolveLabel(v, iBreak);\n        } else {\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, sqlite3WhereContinueLabel(pWInfo), sqlite3WhereBreakLabel(pWInfo));\n            ;\n            sqlite3WhereEnd(pWInfo);\n        }\n    } else {\n        NameContext sNC;\n        int iAMem;\n        int iBMem;\n        int iUseFlag;\n        int iAbortFlag;\n        int groupBySort;\n        int addrEnd;\n        int sortPTab = 0;\n        int sortOut = 0;\n        int orderByGrp = 0;\n        if (pGroupBy) {\n            int k;\n            struct ExprList_item *pItem;\n            for (k = p->pEList->nExpr , pItem = p->pEList->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            for (k = pGroupBy->nExpr , pItem = pGroupBy->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            ((void)0);\n            if (p->nSelectRow > 66)\n                p->nSelectRow = 66;\n            if (sSort.pOrderBy && pGroupBy->nExpr == sSort.pOrderBy->nExpr) {\n                int ii;\n                for (ii = 0; ii < pGroupBy->nExpr; ii++) {\n                    u8 sortFlags;\n                    sortFlags = sSort.pOrderBy->a[ii].fg.sortFlags & 1;\n                    pGroupBy->a[ii].fg.sortFlags = sortFlags;\n                }\n                if (sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1) == 0) {\n                    orderByGrp = 1;\n                }\n            }\n        } else {\n            ((void)0);\n            p->nSelectRow = 0;\n        }\n        addrEnd = sqlite3VdbeMakeLabel(pParse);\n        pAggInfo = sqlite3DbMallocZero(db, sizeof (*pAggInfo));\n        if (pAggInfo) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))agginfoFree, pAggInfo);\n            ;\n        }\n        if (db->mallocFailed) {\n            goto select_end;\n        }\n        pAggInfo->selId = p->selId;\n        __builtin___memset_chk(&sNC, 0, sizeof (sNC), __builtin_object_size(&sNC, 0));\n        sNC.pParse = pParse;\n        sNC.pSrcList = pTabList;\n        sNC.uNC.pAggInfo = pAggInfo;\n        pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n        pAggInfo->pGroupBy = pGroupBy;\n        sqlite3ExprAnalyzeAggList(&sNC, pEList);\n        sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n        if (pHaving) {\n            if (pGroupBy) {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                havingToWhere(pParse, p);\n                pWhere = p->pWhere;\n            }\n            sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n        }\n        pAggInfo->nAccumulator = pAggInfo->nColumn;\n        if (p->pGroupBy == 0 && p->pHaving == 0 && pAggInfo->nFunc == 1) {\n            minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);\n        } else {\n            minMaxFlag = 0;\n        }\n        analyzeAggFuncArgs(pAggInfo, &sNC);\n        if (db->mallocFailed)\n            goto select_end;\n        if (pGroupBy) {\n            KeyInfo *pKeyInfo;\n            int addr1;\n            int addrOutputRow;\n            int regOutputRow;\n            int addrSetAbort;\n            int addrTopOfLoop;\n            int addrSortingIdx;\n            int addrReset;\n            int regReset;\n            ExprList *pDistinct = 0;\n            u16 distFlag = 0;\n            int eDist = 0;\n            if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && (pAggInfo->aFunc[0].pFExpr != 0) && ((((pAggInfo->aFunc[0].pFExpr)->flags & 4096) == 0)) && pAggInfo->aFunc[0].pFExpr->x.pList != 0) {\n                Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);\n                pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);\n                distFlag = pDistinct ? (256 | 1024) : 0;\n            }\n            pAggInfo->sortingIdx = pParse->nTab++;\n            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, 0, pAggInfo->nColumn);\n            addrSortingIdx = sqlite3VdbeAddOp4(v, 119, pAggInfo->sortingIdx, pAggInfo->nSortingColumn, 0, (char *)pKeyInfo, (-8));\n            iUseFlag = ++pParse->nMem;\n            iAbortFlag = ++pParse->nMem;\n            regOutputRow = ++pParse->nMem;\n            addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n            regReset = ++pParse->nMem;\n            addrReset = sqlite3VdbeMakeLabel(pParse);\n            iAMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            iBMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            sqlite3VdbeAddOp2(v, 71, 0, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp3(v, 75, 0, iAMem, iAMem + pGroupBy->nExpr - 1);\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, p, (sDistinct.isTnct == 2 ? 128 : 64) | (orderByGrp ? 512 : 0) | distFlag, 0);\n            if (pWInfo == 0) {\n                sqlite3ExprListDelete(db, pDistinct);\n                goto select_end;\n            }\n            if (pParse->pIdxEpr) {\n                optimizeAggregateUseOfIndexedExpr(pParse, p, pAggInfo, &sNC);\n            }\n            assignAggregateRegisters(pParse, pAggInfo);\n            eDist = sqlite3WhereIsDistinct(pWInfo);\n            ;\n            if (sqlite3WhereIsOrdered(pWInfo) == pGroupBy->nExpr) {\n                groupBySort = 0;\n            } else {\n                int regBase;\n                int regRecord;\n                int nCol;\n                int nGroupBy;\n                explainTempTable(pParse, (sDistinct.isTnct && (p->selFlags & 1) == 0) ? \"DISTINCT\" : \"GROUP BY\");\n                groupBySort = 1;\n                nGroupBy = pGroupBy->nExpr;\n                nCol = nGroupBy;\n                j = nGroupBy;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    if (pAggInfo->aCol[i].iSorterColumn >= j) {\n                        nCol++;\n                        j++;\n                    }\n                }\n                regBase = sqlite3GetTempRange(pParse, nCol);\n                sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n                j = nGroupBy;\n                pAggInfo->directMode = 1;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    struct AggInfo_col *pCol = &pAggInfo->aCol[i];\n                    if (pCol->iSorterColumn >= j) {\n                        sqlite3ExprCode(pParse, pCol->pCExpr, j + regBase);\n                        j++;\n                    }\n                }\n                pAggInfo->directMode = 0;\n                regRecord = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 97, regBase, nCol, regRecord);\n                sqlite3VdbeAddOp2(v, 139, pAggInfo->sortingIdx, regRecord);\n                sqlite3ReleaseTempReg(pParse, regRecord);\n                sqlite3ReleaseTempRange(pParse, regBase, nCol);\n                ;\n                sqlite3WhereEnd(pWInfo);\n                pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;\n                sortOut = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 121, sortPTab, sortOut, nCol);\n                sqlite3VdbeAddOp2(v, 34, pAggInfo->sortingIdx, addrEnd);\n                ;\n                ;\n                pAggInfo->useSortingIdx = 1;\n            }\n            if (pParse->pIdxEpr) {\n                aggregateConvertIndexedExprRefToColumn(pAggInfo);\n            }\n            if (orderByGrp && (((db)->dbOptFlags & (4)) == 0) && (groupBySort || sqlite3WhereIsSorted(pWInfo))) {\n                sSort.pOrderBy = 0;\n                sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n            }\n            addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n            if (groupBySort) {\n                sqlite3VdbeAddOp3(v, 133, pAggInfo->sortingIdx, sortOut, sortPTab);\n            }\n            for (j = 0; j < pGroupBy->nExpr; j++) {\n                if (groupBySort) {\n                    sqlite3VdbeAddOp3(v, 94, sortPTab, j, iBMem + j);\n                } else {\n                    pAggInfo->directMode = 1;\n                    sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem + j);\n                }\n            }\n            sqlite3VdbeAddOp4(v, 90, iAMem, iBMem, pGroupBy->nExpr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n            addr1 = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp3(v, 14, addr1 + 1, 0, addr1 + 1);\n            ;\n            sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeAddOp2(v, 59, iAbortFlag, addrEnd);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            sqlite3VdbeJumpHere(v, addr1);\n            updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);\n            sqlite3VdbeAddOp2(v, 71, 1, iUseFlag);\n            ;\n            if (groupBySort) {\n                sqlite3VdbeAddOp2(v, 37, pAggInfo->sortingIdx, addrTopOfLoop);\n                ;\n            } else {\n                ;\n                sqlite3WhereEnd(pWInfo);\n                sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n            }\n            sqlite3ExprListDelete(db, pDistinct);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeGoto(v, addrEnd);\n            addrSetAbort = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 71, 1, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            sqlite3VdbeResolveLabel(v, addrOutputRow);\n            addrOutputRow = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 59, iUseFlag, addrOutputRow + 2);\n            ;\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            finalizeAggFunctions(pParse, pAggInfo);\n            sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow + 1, 16);\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, addrOutputRow + 1, addrSetAbort);\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            ;\n            sqlite3VdbeResolveLabel(v, addrReset);\n            resetAccumulator(pParse, pAggInfo);\n            sqlite3VdbeAddOp2(v, 71, 0, iUseFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regReset);\n            if (distFlag != 0 && eDist != 0) {\n                struct AggInfo_func *pF = &pAggInfo->aFunc[0];\n                fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n            }\n        } else {\n            Table *pTab;\n            if ((pTab = isSimpleCount(p, pAggInfo)) != 0) {\n                const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n                const int iCsr = pParse->nTab++;\n                Index *pIdx;\n                KeyInfo *pKeyInfo = 0;\n                Index *pBest = 0;\n                Pgno iRoot = pTab->tnum;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                if (!(((pTab)->tabFlags & 128) == 0))\n                    pBest = sqlite3PrimaryKeyIndex(pTab);\n                if (!p->pSrc->a[0].fg.notIndexed) {\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && (!pBest || pIdx->szIdxRow < pBest->szIdxRow)) {\n                            pBest = pIdx;\n                        }\n                    }\n                }\n                if (pBest) {\n                    iRoot = pBest->tnum;\n                    pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n                }\n                sqlite3VdbeAddOp4Int(v, 112, iCsr, (int)iRoot, iDb, 1);\n                if (pKeyInfo) {\n                    sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-8));\n                }\n                assignAggregateRegisters(pParse, pAggInfo);\n                sqlite3VdbeAddOp2(v, 98, iCsr, (((void)0) , (pAggInfo)->iFirstReg + (pAggInfo)->nColumn + (0)));\n                sqlite3VdbeAddOp1(v, 122, iCsr);\n                explainSimpleCount(pParse, pTab, pBest);\n            } else {\n                int regAcc = 0;\n                ExprList *pDistinct = 0;\n                u16 distFlag = 0;\n                int eDist;\n                if (pAggInfo->nAccumulator) {\n                    for (i = 0; i < pAggInfo->nFunc; i++) {\n                        if ((((pAggInfo->aFunc[i].pFExpr)->flags & (16777216)) != 0)) {\n                            continue;\n                        }\n                        if (pAggInfo->aFunc[i].pFunc->funcFlags & 32) {\n                            break;\n                        }\n                    }\n                    if (i == pAggInfo->nFunc) {\n                        regAcc = ++pParse->nMem;\n                        sqlite3VdbeAddOp2(v, 71, 0, regAcc);\n                    }\n                } else if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0) {\n                    ((void)0);\n                    pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;\n                    distFlag = pDistinct ? (256 | 1024) : 0;\n                }\n                assignAggregateRegisters(pParse, pAggInfo);\n                ((void)0);\n                resetAccumulator(pParse, pAggInfo);\n                ((void)0);\n                ((void)0);\n                ;\n                pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, p, minMaxFlag | distFlag, 0);\n                if (pWInfo == 0) {\n                    goto select_end;\n                }\n                ;\n                eDist = sqlite3WhereIsDistinct(pWInfo);\n                updateAccumulator(pParse, regAcc, pAggInfo, eDist);\n                if (eDist != 0) {\n                    struct AggInfo_func *pF = pAggInfo->aFunc;\n                    if (pF) {\n                        fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n                    }\n                }\n                if (regAcc)\n                    sqlite3VdbeAddOp2(v, 71, 1, regAcc);\n                if (minMaxFlag) {\n                    sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);\n                }\n                ;\n                sqlite3WhereEnd(pWInfo);\n                finalizeAggFunctions(pParse, pAggInfo);\n            }\n            sSort.pOrderBy = 0;\n            sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 16);\n            selectInnerLoop(pParse, p, -1, 0, 0, pDest, addrEnd, addrEnd);\n        }\n        sqlite3VdbeResolveLabel(v, addrEnd);\n    }\n    if (sDistinct.eTnctType == 3) {\n        explainTempTable(pParse, \"DISTINCT\");\n    }\n    if (sSort.pOrderBy) {\n        ((void)0);\n        generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n    }\n    sqlite3VdbeResolveLabel(v, iEnd);\n    rc = (pParse->nErr > 0);\n  select_end:\n    ((void)0);\n    ((void)0);\n    sqlite3ExprListDelete(db, pMinMaxOrderBy);\n    sqlite3VdbeExplainPop(pParse);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#140882:1#multiSelect",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    Select *pPrior;\n    Vdbe *v;\n    SelectDest dest;\n    Select *pDelete = 0;\n    sqlite3 *db;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    db = pParse->db;\n    pPrior = p->pPrior;\n    dest = *pDest;\n    ((void)0);\n    ((void)0);\n    v = sqlite3GetVdbe(pParse);\n    ((void)0);\n    if (dest.eDest == 12) {\n        ((void)0);\n        sqlite3VdbeAddOp2(v, 118, dest.iSDParm, p->pEList->nExpr);\n        dest.eDest = 14;\n    }\n    if (p->selFlags & 1024) {\n        rc = multiSelectValues(pParse, p, &dest);\n        if (rc >= 0)\n            goto multi_select_end;\n        rc = 0;\n    }\n    ((void)0);\n    ((void)0);\n    if ((p->selFlags & 8192) != 0 && hasAnchor(p)) {\n        generateWithRecursiveQuery(pParse, p, &dest);\n    } else if (p->pOrderBy) {\n        return multiSelectOrderBy(pParse, p, pDest);\n    } else {\n        if (pPrior->pPrior == 0) {\n            sqlite3VdbeExplain(pParse, 1, \"COMPOUND QUERY\");\n            sqlite3VdbeExplain(pParse, 1, \"LEFT-MOST SUBQUERY\");\n        }\n        switch (p->op) {\n          case 135:\n            {\n                int addr = 0;\n                int nLimit = 0;\n                ((void)0);\n                pPrior->iLimit = p->iLimit;\n                pPrior->iOffset = p->iOffset;\n                pPrior->pLimit = p->pLimit;\n                ;\n                rc = sqlite3Select(pParse, pPrior, &dest);\n                pPrior->pLimit = 0;\n                if (rc) {\n                    goto multi_select_end;\n                }\n                p->pPrior = 0;\n                p->iLimit = pPrior->iLimit;\n                p->iOffset = pPrior->iOffset;\n                if (p->iLimit) {\n                    addr = sqlite3VdbeAddOp1(v, 17, p->iLimit);\n                    ;\n                    ;\n                    if (p->iOffset) {\n                        sqlite3VdbeAddOp3(v, 160, p->iLimit, p->iOffset + 1, p->iOffset);\n                    }\n                }\n                sqlite3VdbeExplain(pParse, 1, \"UNION ALL\");\n                ;\n                rc = sqlite3Select(pParse, p, &dest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                if (p->pLimit && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit) && nLimit > 0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)) {\n                    p->nSelectRow = sqlite3LogEst((u64)nLimit);\n                }\n                if (addr) {\n                    sqlite3VdbeJumpHere(v, addr);\n                }\n                break;\n            }\n          case 136:\n          case 134:\n            {\n                int unionTab;\n                u8 op = 0;\n                int priorOp;\n                Expr *pLimit;\n                int addr;\n                SelectDest uniondest;\n                ;\n                ;\n                priorOp = 1;\n                if (dest.eDest == priorOp) {\n                    ((void)0);\n                    unionTab = dest.iSDParm;\n                } else {\n                    unionTab = pParse->nTab++;\n                    ((void)0);\n                    addr = sqlite3VdbeAddOp2(v, 118, unionTab, 0);\n                    ((void)0);\n                    p->addrOpenEphm[0] = addr;\n                    findRightmost(p)->selFlags |= 32;\n                    ((void)0);\n                }\n                ((void)0);\n                sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &uniondest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                if (p->op == 136) {\n                    op = 2;\n                } else {\n                    ((void)0);\n                    op = 1;\n                }\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                uniondest.eDest = op;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &uniondest);\n                ;\n                ((void)0);\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->pOrderBy = 0;\n                if (p->op == 134) {\n                    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                p->iLimit = 0;\n                p->iOffset = 0;\n                ((void)0);\n                ((void)0);\n                if (dest.eDest != priorOp && db->mallocFailed == 0) {\n                    int iCont, iBreak, iStart;\n                    iBreak = sqlite3VdbeMakeLabel(pParse);\n                    iCont = sqlite3VdbeMakeLabel(pParse);\n                    computeLimitRegisters(pParse, p, iBreak);\n                    sqlite3VdbeAddOp2(v, 36, unionTab, iBreak);\n                    ;\n                    iStart = sqlite3VdbeCurrentAddr(v);\n                    selectInnerLoop(pParse, p, unionTab, 0, 0, &dest, iCont, iBreak);\n                    sqlite3VdbeResolveLabel(v, iCont);\n                    sqlite3VdbeAddOp2(v, 39, unionTab, iStart);\n                    ;\n                    sqlite3VdbeResolveLabel(v, iBreak);\n                    sqlite3VdbeAddOp2(v, 122, unionTab, 0);\n                }\n                break;\n            }\n          default:\n            ((void)0);\n            {\n                int tab1, tab2;\n                int iCont, iBreak, iStart;\n                Expr *pLimit;\n                int addr;\n                SelectDest intersectdest;\n                int r1;\n                tab1 = pParse->nTab++;\n                tab2 = pParse->nTab++;\n                ((void)0);\n                addr = sqlite3VdbeAddOp2(v, 118, tab1, 0);\n                ((void)0);\n                p->addrOpenEphm[0] = addr;\n                findRightmost(p)->selFlags |= 32;\n                ((void)0);\n                sqlite3SelectDestInit(&intersectdest, 1, tab1);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &intersectdest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                addr = sqlite3VdbeAddOp2(v, 118, tab2, 0);\n                ((void)0);\n                p->addrOpenEphm[1] = addr;\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                intersectdest.iSDParm = tab2;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &intersectdest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                if (p->nSelectRow > pPrior->nSelectRow) {\n                    p->nSelectRow = pPrior->nSelectRow;\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                if (rc)\n                    break;\n                ((void)0);\n                iBreak = sqlite3VdbeMakeLabel(pParse);\n                iCont = sqlite3VdbeMakeLabel(pParse);\n                computeLimitRegisters(pParse, p, iBreak);\n                sqlite3VdbeAddOp2(v, 36, tab1, iBreak);\n                ;\n                r1 = sqlite3GetTempReg(pParse);\n                iStart = sqlite3VdbeAddOp2(v, 134, tab1, r1);\n                sqlite3VdbeAddOp4Int(v, 28, tab2, iCont, r1, 0);\n                ;\n                sqlite3ReleaseTempReg(pParse, r1);\n                selectInnerLoop(pParse, p, tab1, 0, 0, &dest, iCont, iBreak);\n                sqlite3VdbeResolveLabel(v, iCont);\n                sqlite3VdbeAddOp2(v, 39, tab1, iStart);\n                ;\n                sqlite3VdbeResolveLabel(v, iBreak);\n                sqlite3VdbeAddOp2(v, 122, tab2, 0);\n                sqlite3VdbeAddOp2(v, 122, tab1, 0);\n                break;\n            }\n        }\n        if (p->pNext == 0) {\n            sqlite3VdbeExplainPop(pParse);\n        }\n    }\n    if (pParse->nErr)\n        goto multi_select_end;\n    if (p->selFlags & 32) {\n        int i;\n        KeyInfo *pKeyInfo;\n        Select *pLoop;\n        CollSeq **apColl;\n        int nCol;\n        ((void)0);\n        ((void)0);\n        nCol = p->pEList->nExpr;\n        pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n        if (!pKeyInfo) {\n            rc = 7;\n            goto multi_select_end;\n        }\n        for (i = 0 , apColl = pKeyInfo->aColl; i < nCol; i++ , apColl++) {\n            *apColl = multiSelectCollSeq(pParse, p, i);\n            if (0 == *apColl) {\n                *apColl = db->pDfltColl;\n            }\n        }\n        for (pLoop = p; pLoop; pLoop = pLoop->pPrior) {\n            for (i = 0; i < 2; i++) {\n                int addr = pLoop->addrOpenEphm[i];\n                if (addr < 0) {\n                    ((void)0);\n                    break;\n                }\n                sqlite3VdbeChangeP2(v, addr, nCol);\n                sqlite3VdbeChangeP4(v, addr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n                pLoop->addrOpenEphm[i] = -1;\n            }\n        }\n        sqlite3KeyInfoUnref(pKeyInfo);\n    }\n  multi_select_end:\n    pDest->iSdst = dest.iSdst;\n    pDest->nSdst = dest.nSdst;\n    if (pDelete) {\n        sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3SelectDelete, pDelete);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#140633:1#generateWithRecursiveQuery",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    SrcList *pSrc = p->pSrc;\n    int nCol = p->pEList->nExpr;\n    Vdbe *v = pParse->pVdbe;\n    Select *pSetup;\n    Select *pFirstRec;\n    int addrTop;\n    int addrCont, addrBreak;\n    int iCurrent = 0;\n    int regCurrent;\n    int iQueue;\n    int iDistinct = 0;\n    int eDest = 8;\n    SelectDest destQueue;\n    int i;\n    int rc;\n    ExprList *pOrderBy;\n    Expr *pLimit;\n    int regLimit, regOffset;\n    if (p->pWin) {\n        sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n        return;\n    }\n    if (sqlite3AuthCheck(pParse, 33, 0, 0, 0))\n        return;\n    addrBreak = sqlite3VdbeMakeLabel(pParse);\n    p->nSelectRow = 320;\n    computeLimitRegisters(pParse, p, addrBreak);\n    pLimit = p->pLimit;\n    regLimit = p->iLimit;\n    regOffset = p->iOffset;\n    p->pLimit = 0;\n    p->iLimit = p->iOffset = 0;\n    pOrderBy = p->pOrderBy;\n    for (i = 0; (i < pSrc->nSrc); i++) {\n        if (pSrc->a[i].fg.isRecursive) {\n            iCurrent = pSrc->a[i].iCursor;\n            break;\n        }\n    }\n    iQueue = pParse->nTab++;\n    if (p->op == 134) {\n        eDest = pOrderBy ? 6 : 5;\n        iDistinct = pParse->nTab++;\n    } else {\n        eDest = pOrderBy ? 7 : 8;\n    }\n    sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n    regCurrent = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, 121, iCurrent, regCurrent, nCol);\n    if (pOrderBy) {\n        KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n        sqlite3VdbeAddOp4(v, 118, iQueue, pOrderBy->nExpr + 2, 0, (char *)pKeyInfo, (-8));\n        destQueue.pOrderBy = pOrderBy;\n    } else {\n        sqlite3VdbeAddOp2(v, 118, iQueue, nCol);\n    }\n    ;\n    if (iDistinct) {\n        p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 118, iDistinct, 0);\n        p->selFlags |= 32;\n    }\n    p->pOrderBy = 0;\n    for (pFirstRec = p; (pFirstRec != 0); pFirstRec = pFirstRec->pPrior) {\n        if (pFirstRec->selFlags & 8) {\n            sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n            goto end_of_recursive_query;\n        }\n        pFirstRec->op = 135;\n        if ((pFirstRec->pPrior->selFlags & 8192) == 0)\n            break;\n    }\n    pSetup = pFirstRec->pPrior;\n    pSetup->pNext = 0;\n    sqlite3VdbeExplain(pParse, 1, \"SETUP\");\n    rc = sqlite3Select(pParse, pSetup, &destQueue);\n    pSetup->pNext = p;\n    if (rc)\n        goto end_of_recursive_query;\n    addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak);\n    ;\n    sqlite3VdbeAddOp1(v, 136, iCurrent);\n    if (pOrderBy) {\n        sqlite3VdbeAddOp3(v, 94, iQueue, pOrderBy->nExpr + 1, regCurrent);\n    } else {\n        sqlite3VdbeAddOp2(v, 134, iQueue, regCurrent);\n    }\n    sqlite3VdbeAddOp1(v, 130, iQueue);\n    addrCont = sqlite3VdbeMakeLabel(pParse);\n    codeOffset(v, regOffset, addrCont);\n    selectInnerLoop(pParse, p, iCurrent, 0, 0, pDest, addrCont, addrBreak);\n    if (regLimit) {\n        sqlite3VdbeAddOp2(v, 61, regLimit, addrBreak);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, addrCont);\n    pFirstRec->pPrior = 0;\n    sqlite3VdbeExplain(pParse, 1, \"RECURSIVE STEP\");\n    sqlite3Select(pParse, p, &destQueue);\n    ((void)0);\n    pFirstRec->pPrior = pSetup;\n    sqlite3VdbeGoto(v, addrTop);\n    sqlite3VdbeResolveLabel(v, addrBreak);\n  end_of_recursive_query:\n    sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n    p->pOrderBy = pOrderBy;\n    p->pLimit = pLimit;\n    return;\n}\n"
  },
  {
    "id": "sqlite3.c#137633:1#sqlite3Prepare",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    int i;\n    Parse sParse;\n    __builtin___memset_chk((((char *)(&sParse)) + __builtin_offsetof(Parse, zErrMsg)), 0, (__builtin_offsetof(Parse, aTempReg) - __builtin_offsetof(Parse, zErrMsg)), __builtin_object_size((((char *)(&sParse)) + __builtin_offsetof(Parse, zErrMsg)), 0));\n    __builtin___memset_chk((((char *)(&sParse)) + __builtin_offsetof(Parse, sLastToken)), 0, (sizeof(Parse) - __builtin_offsetof(Parse, sLastToken)), __builtin_object_size((((char *)(&sParse)) + __builtin_offsetof(Parse, sLastToken)), 0));\n    sParse.pOuterParse = db->pParse;\n    db->pParse = &sParse;\n    sParse.db = db;\n    sParse.pReprepare = pReprepare;\n    ((void)0);\n    if (db->mallocFailed)\n        sqlite3ErrorMsg(&sParse, \"out of memory\");\n    ((void)0);\n    if (prepFlags & 1) {\n        sParse.disableLookaside++;\n        db->lookaside.bDisable++;\n        db->lookaside.sz = 0;\n    }\n    sParse.prepFlags = prepFlags & 255;\n    if (!db->noSharedCache) {\n        for (i = 0; i < db->nDb; i++) {\n            Btree *pBt = db->aDb[i].pBt;\n            if (pBt) {\n                ((void)0);\n                rc = sqlite3BtreeSchemaLocked(pBt);\n                if (rc) {\n                    const char *zDb = db->aDb[i].zDbSName;\n                    sqlite3ErrorWithMsg(db, rc, \"database schema is locked: %s\", zDb);\n                    ;\n                    goto end_prepare;\n                }\n            }\n        }\n    }\n    if (db->pDisconnect)\n        sqlite3VtabUnlockList(db);\n    if (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != 0)) {\n        char *zSqlCopy;\n        int mxLen = db->aLimit[1];\n        ;\n        ;\n        if (nBytes > mxLen) {\n            sqlite3ErrorWithMsg(db, 18, \"statement too long\");\n            rc = sqlite3ApiExit(db, 18);\n            goto end_prepare;\n        }\n        zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n        if (zSqlCopy) {\n            sqlite3RunParser(&sParse, zSqlCopy);\n            sParse.zTail = &zSql[sParse.zTail - zSqlCopy];\n            sqlite3DbFree(db, zSqlCopy);\n        } else {\n            sParse.zTail = &zSql[nBytes];\n        }\n    } else {\n        sqlite3RunParser(&sParse, zSql);\n    }\n    ((void)0);\n    if (pzTail) {\n        *pzTail = sParse.zTail;\n    }\n    if (db->init.busy == 0) {\n        sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), prepFlags);\n    }\n    if (db->mallocFailed) {\n        sParse.rc = 7;\n        sParse.checkSchema = 0;\n    }\n    if (sParse.rc != 0 && sParse.rc != 101) {\n        if (sParse.checkSchema && db->init.busy == 0) {\n            schemaIsValid(&sParse);\n        }\n        if (sParse.pVdbe) {\n            sqlite3VdbeFinalize(sParse.pVdbe);\n        }\n        ((void)0);\n        rc = sParse.rc;\n        if (sParse.zErrMsg) {\n            sqlite3ErrorWithMsg(db, rc, \"%s\", sParse.zErrMsg);\n            sqlite3DbFree(db, sParse.zErrMsg);\n        } else {\n            sqlite3Error(db, rc);\n        }\n    } else {\n        ((void)0);\n        *ppStmt = (sqlite3_stmt *)sParse.pVdbe;\n        rc = 0;\n        sqlite3ErrorClear(db);\n    }\n    while (sParse.pTriggerPrg)\n        {\n            TriggerPrg *pT = sParse.pTriggerPrg;\n            sParse.pTriggerPrg = pT->pNext;\n            sqlite3DbFree(db, pT);\n        }\n  end_prepare:\n    sqlite3ParseObjectReset(&sParse);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Insert",
    "gotos": 18,
    "labels": 2,
    "body": "{\n    sqlite3 *db;\n    Table *pTab;\n    int i, j;\n    Vdbe *v;\n    Index *pIdx;\n    int nColumn;\n    int nHidden = 0;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int ipkColumn = -1;\n    int endOfLoop;\n    int srcTab = 0;\n    int addrInsTop = 0;\n    int addrCont = 0;\n    SelectDest dest;\n    int iDb;\n    u8 useTempTable = 0;\n    u8 appendFlag = 0;\n    u8 withoutRowid;\n    u8 bIdListInOrder;\n    ExprList *pList = 0;\n    int iRegStore;\n    int regFromSelect = 0;\n    int regAutoinc = 0;\n    int regRowCount = 0;\n    int regIns;\n    int regRowid;\n    int regData;\n    int *aRegIdx = 0;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    db = pParse->db;\n    ((void)0);\n    if (pParse->nErr) {\n        goto insert_cleanup;\n    }\n    ((void)0);\n    dest.iSDParm = 0;\n    if (pSelect && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0) {\n        pList = pSelect->pEList;\n        pSelect->pEList = 0;\n        sqlite3SelectDelete(db, pSelect);\n        pSelect = 0;\n    }\n    ((void)0);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0) {\n        goto insert_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    ((void)0);\n    if (sqlite3AuthCheck(pParse, 18, pTab->zName, 0, db->aDb[iDb].zDbSName)) {\n        goto insert_cleanup;\n    }\n    withoutRowid = !(((pTab)->tabFlags & 128) == 0);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 127, 0, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    ((void)0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto insert_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto insert_cleanup;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto insert_cleanup;\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);\n    if (pColumn == 0 && pSelect != 0 && pTrigger == 0 && xferOptimization(pParse, pTab, pSelect, onError, iDb)) {\n        ((void)0);\n        ((void)0);\n        goto insert_end;\n    }\n    regAutoinc = autoIncBegin(pParse, iDb, pTab);\n    regRowid = regIns = pParse->nMem + 1;\n    pParse->nMem += pTab->nCol + 1;\n    if (((pTab)->eTabType == 1)) {\n        regRowid++;\n        pParse->nMem++;\n    }\n    regData = regRowid + 1;\n    bIdListInOrder = (pTab->tabFlags & (1024 | 64)) == 0;\n    if (pColumn) {\n        ((void)0);\n        pColumn->eU4 = 1;\n        for (i = 0; i < pColumn->nId; i++) {\n            pColumn->a[i].u4.idx = -1;\n        }\n        for (i = 0; i < pColumn->nId; i++) {\n            for (j = 0; j < pTab->nCol; j++) {\n                if (sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName) == 0) {\n                    pColumn->a[i].u4.idx = j;\n                    if (i != j)\n                        bIdListInOrder = 0;\n                    if (j == pTab->iPKey) {\n                        ipkColumn = i;\n                        ((void)0);\n                    }\n                    if (pTab->aCol[j].colFlags & (64 | 32)) {\n                        sqlite3ErrorMsg(pParse, \"cannot INSERT into generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                        goto insert_cleanup;\n                    }\n                    break;\n                }\n            }\n            if (j >= pTab->nCol) {\n                if (sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid) {\n                    ipkColumn = i;\n                    bIdListInOrder = 0;\n                } else {\n                    sqlite3ErrorMsg(pParse, \"table %S has no column named %s\", pTabList->a, pColumn->a[i].zName);\n                    pParse->checkSchema = 1;\n                    goto insert_cleanup;\n                }\n            }\n        }\n    }\n    if (pSelect) {\n        int regYield;\n        int addrTop;\n        int rc;\n        regYield = ++pParse->nMem;\n        addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, addrTop);\n        sqlite3SelectDestInit(&dest, 13, regYield);\n        dest.iSdst = bIdListInOrder ? regData : 0;\n        dest.nSdst = pTab->nCol;\n        rc = sqlite3Select(pParse, pSelect, &dest);\n        regFromSelect = dest.iSdst;\n        ((void)0);\n        if (rc || pParse->nErr)\n            goto insert_cleanup;\n        ((void)0);\n        sqlite3VdbeEndCoroutine(v, regYield);\n        sqlite3VdbeJumpHere(v, addrTop - 1);\n        ((void)0);\n        nColumn = pSelect->pEList->nExpr;\n        if (pTrigger || readsTable(pParse, iDb, pTab)) {\n            useTempTable = 1;\n        }\n        if (useTempTable) {\n            int regRec;\n            int regTempRowid;\n            int addrL;\n            srcTab = pParse->nTab++;\n            regRec = sqlite3GetTempReg(pParse);\n            regTempRowid = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp2(v, 118, srcTab, nColumn);\n            addrL = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n            ;\n            sqlite3VdbeAddOp3(v, 97, regFromSelect, nColumn, regRec);\n            sqlite3VdbeAddOp2(v, 127, srcTab, regTempRowid);\n            sqlite3VdbeAddOp3(v, 128, srcTab, regRec, regTempRowid);\n            sqlite3VdbeGoto(v, addrL);\n            sqlite3VdbeJumpHere(v, addrL);\n            sqlite3ReleaseTempReg(pParse, regRec);\n            sqlite3ReleaseTempReg(pParse, regTempRowid);\n        }\n    } else {\n        NameContext sNC;\n        __builtin___memset_chk(&sNC, 0, sizeof (sNC), __builtin_object_size(&sNC, 0));\n        sNC.pParse = pParse;\n        srcTab = -1;\n        ((void)0);\n        if (pList) {\n            nColumn = pList->nExpr;\n            if (sqlite3ResolveExprListNames(&sNC, pList)) {\n                goto insert_cleanup;\n            }\n        } else {\n            nColumn = 0;\n        }\n    }\n    if (pColumn == 0 && nColumn > 0) {\n        ipkColumn = pTab->iPKey;\n        if (ipkColumn >= 0 && (pTab->tabFlags & 96) != 0) {\n            ;\n            ;\n            for (i = ipkColumn - 1; i >= 0; i--) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    ;\n                    ;\n                    ipkColumn--;\n                }\n            }\n        }\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        if ((pTab->tabFlags & (96 | 2)) != 0) {\n            for (i = 0; i < pTab->nCol; i++) {\n                if (pTab->aCol[i].colFlags & 98)\n                    nHidden++;\n            }\n        }\n        if (nColumn != (pTab->nCol - nHidden)) {\n            sqlite3ErrorMsg(pParse, \"table %S has %d columns but %d values were supplied\", pTabList->a, pTab->nCol - nHidden, nColumn);\n            goto insert_cleanup;\n        }\n    }\n    if (pColumn != 0 && nColumn != pColumn->nId) {\n        sqlite3ErrorMsg(pParse, \"%d values for %d columns\", nColumn, pColumn->nId);\n        goto insert_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (!isView) {\n        int nIdx;\n        nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, -1, 0, &iDataCur, &iIdxCur);\n        aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int) * (nIdx + 2));\n        if (aRegIdx == 0) {\n            goto insert_cleanup;\n        }\n        for (i = 0 , pIdx = pTab->pIndex; i < nIdx; pIdx = pIdx->pNext , i++) {\n            ((void)0);\n            aRegIdx[i] = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        }\n        aRegIdx[i] = ++pParse->nMem;\n    }\n    if (pUpsert) {\n        Upsert *pNx;\n        if (((pTab)->eTabType == 1)) {\n            sqlite3ErrorMsg(pParse, \"UPSERT not implemented for virtual table \\\"%s\\\"\", pTab->zName);\n            goto insert_cleanup;\n        }\n        if (((pTab)->eTabType == 2)) {\n            sqlite3ErrorMsg(pParse, \"cannot UPSERT a view\");\n            goto insert_cleanup;\n        }\n        if (sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget)) {\n            goto insert_cleanup;\n        }\n        pTabList->a[0].iCursor = iDataCur;\n        pNx = pUpsert;\n        do {\n            pNx->pUpsertSrc = pTabList;\n            pNx->regData = regData;\n            pNx->iDataCur = iDataCur;\n            pNx->iIdxCur = iIdxCur;\n            if (pNx->pUpsertTarget) {\n                if (sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) {\n                    goto insert_cleanup;\n                }\n            }\n            pNx = pNx->pNextUpsert;\n        } while (pNx != 0);\n    }\n    if (useTempTable) {\n        addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab);\n        ;\n        addrCont = sqlite3VdbeCurrentAddr(v);\n    } else if (pSelect) {\n        ;\n        addrInsTop = addrCont = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n        ;\n        if (ipkColumn >= 0) {\n            sqlite3VdbeAddOp2(v, 80, regFromSelect + ipkColumn, regRowid);\n        }\n    }\n    nHidden = 0;\n    iRegStore = regData;\n    ((void)0);\n    for (i = 0; i < pTab->nCol; i++ , iRegStore++) {\n        int k;\n        u32 colFlags;\n        ((void)0);\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp1(v, 76, iRegStore);\n            continue;\n        }\n        if (((colFlags = pTab->aCol[i].colFlags) & 98) != 0) {\n            nHidden++;\n            if ((colFlags & 32) != 0) {\n                iRegStore--;\n                continue;\n            } else if ((colFlags & 64) != 0) {\n                if (tmask & 1) {\n                    sqlite3VdbeAddOp1(v, 76, iRegStore);\n                }\n                continue;\n            } else if (pColumn == 0) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n        }\n        if (pColumn) {\n            ((void)0);\n            for (j = 0; j < pColumn->nId && pColumn->a[j].u4.idx != i; j++) {\n            }\n            if (j >= pColumn->nId) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n            k = j;\n        } else if (nColumn == 0) {\n            sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n            continue;\n        } else {\n            k = i - nHidden;\n        }\n        if (useTempTable) {\n            sqlite3VdbeAddOp3(v, 94, srcTab, k, iRegStore);\n        } else if (pSelect) {\n            if (regFromSelect != regData) {\n                sqlite3VdbeAddOp2(v, 81, regFromSelect + k, iRegStore);\n            }\n        } else {\n            Expr *pX = pList->a[k].pExpr;\n            int y = sqlite3ExprCodeTarget(pParse, pX, iRegStore);\n            if (y != iRegStore) {\n                sqlite3VdbeAddOp2(v, (((pX)->flags & (4194304)) != 0) ? 80 : 81, y, iRegStore);\n            }\n        }\n    }\n    endOfLoop = sqlite3VdbeMakeLabel(pParse);\n    if (tmask & 1) {\n        int regCols = sqlite3GetTempRange(pParse, pTab->nCol + 1);\n        if (ipkColumn < 0) {\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n        } else {\n            int addr1;\n            ((void)0);\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regCols);\n            } else {\n                ((void)0);\n                sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);\n            }\n            addr1 = sqlite3VdbeAddOp1(v, 51, regCols);\n            ;\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n            sqlite3VdbeJumpHere(v, addr1);\n            sqlite3VdbeAddOp1(v, 13, regCols);\n            ;\n        }\n        ((void)0);\n        sqlite3VdbeAddOp3(v, 80, regRowid + 1, regCols + 1, pTab->nNVCol - 1);\n        if (pTab->tabFlags & 96) {\n            ;\n            ;\n            sqlite3ComputeGeneratedColumns(pParse, regCols + 1, pTab);\n        }\n        if (!isView) {\n            sqlite3TableAffinity(v, pTab, regCols + 1);\n        }\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 1, pTab, regCols - pTab->nCol - 1, onError, endOfLoop);\n        sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol + 1);\n    }\n    if (!isView) {\n        if (((pTab)->eTabType == 1)) {\n            sqlite3VdbeAddOp2(v, 75, 0, regIns);\n        }\n        if (ipkColumn >= 0) {\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regRowid);\n            } else if (pSelect) {\n            } else {\n                Expr *pIpk = pList->a[ipkColumn].pExpr;\n                if (pIpk->op == 121 && !((pTab)->eTabType == 1)) {\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    appendFlag = 1;\n                } else {\n                    sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);\n                }\n            }\n            if (!appendFlag) {\n                int addr1;\n                if (!((pTab)->eTabType == 1)) {\n                    addr1 = sqlite3VdbeAddOp1(v, 51, regRowid);\n                    ;\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    sqlite3VdbeJumpHere(v, addr1);\n                } else {\n                    addr1 = sqlite3VdbeCurrentAddr(v);\n                    sqlite3VdbeAddOp2(v, 50, regRowid, addr1 + 2);\n                    ;\n                }\n                sqlite3VdbeAddOp1(v, 13, regRowid);\n                ;\n            }\n        } else if (((pTab)->eTabType == 1) || withoutRowid) {\n            sqlite3VdbeAddOp2(v, 75, 0, regRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n            appendFlag = 1;\n        }\n        autoIncStep(pParse, regAutoinc, regRowid);\n        if (pTab->tabFlags & 96) {\n            sqlite3ComputeGeneratedColumns(pParse, regRowid + 1, pTab);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            sqlite3VdbeAddOp4(v, 7, 1, pTab->nCol + 2, regIns, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, onError == 11 ? 2 : onError);\n            sqlite3MayAbort(pParse);\n        } else {\n            int isReplace = 0;\n            int bUseSeek;\n            sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regIns, 0, ipkColumn >= 0, onError, endOfLoop, &isReplace, 0, pUpsert);\n            if (db->flags & 16384) {\n                sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);\n            }\n            bUseSeek = (isReplace == 0 || !sqlite3VdbeHasSubProgram(v));\n            sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regIns, aRegIdx, 0, appendFlag, bUseSeek);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    if (pTrigger) {\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 2, pTab, regData - 2 - pTab->nCol, onError, endOfLoop);\n    }\n    sqlite3VdbeResolveLabel(v, endOfLoop);\n    if (useTempTable) {\n        sqlite3VdbeAddOp2(v, 39, srcTab, addrCont);\n        ;\n        sqlite3VdbeJumpHere(v, addrInsTop);\n        sqlite3VdbeAddOp1(v, 122, srcTab);\n    } else if (pSelect) {\n        sqlite3VdbeGoto(v, addrCont);\n        sqlite3VdbeJumpHere(v, addrInsTop);\n    }\n  insert_end:\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows inserted\");\n    }\n  insert_cleanup:\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3UpsertDelete(db, pUpsert);\n    sqlite3SelectDelete(db, pSelect);\n    sqlite3IdListDelete(db, pColumn);\n    if (aRegIdx)\n        sqlite3DbNNFreeNN(db, aRegIdx);\n}\n"
  },
  {
    "id": "sqlite3.c#124828:1#instrFunc",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    const unsigned char *zHaystack;\n    const unsigned char *zNeedle;\n    int nHaystack;\n    int nNeedle;\n    int typeHaystack, typeNeedle;\n    int N = 1;\n    int isText;\n    unsigned char firstChar;\n    sqlite3_value *pC1 = 0;\n    sqlite3_value *pC2 = 0;\n    (void)(argc);\n    typeHaystack = sqlite3_value_type(argv[0]);\n    typeNeedle = sqlite3_value_type(argv[1]);\n    if (typeHaystack == 5 || typeNeedle == 5)\n        return;\n    nHaystack = sqlite3_value_bytes(argv[0]);\n    nNeedle = sqlite3_value_bytes(argv[1]);\n    if (nNeedle > 0) {\n        if (typeHaystack == 4 && typeNeedle == 4) {\n            zHaystack = sqlite3_value_blob(argv[0]);\n            zNeedle = sqlite3_value_blob(argv[1]);\n            isText = 0;\n        } else if (typeHaystack != 4 && typeNeedle != 4) {\n            zHaystack = sqlite3_value_text(argv[0]);\n            zNeedle = sqlite3_value_text(argv[1]);\n            isText = 1;\n        } else {\n            pC1 = sqlite3_value_dup(argv[0]);\n            zHaystack = sqlite3_value_text(pC1);\n            if (zHaystack == 0)\n                goto endInstrOOM;\n            nHaystack = sqlite3_value_bytes(pC1);\n            pC2 = sqlite3_value_dup(argv[1]);\n            zNeedle = sqlite3_value_text(pC2);\n            if (zNeedle == 0)\n                goto endInstrOOM;\n            nNeedle = sqlite3_value_bytes(pC2);\n            isText = 1;\n        }\n        if (zNeedle == 0 || (nHaystack && zHaystack == 0))\n            goto endInstrOOM;\n        firstChar = zNeedle[0];\n        while (nNeedle <= nHaystack && (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0))\n            {\n                N++;\n                do {\n                    nHaystack--;\n                    zHaystack++;\n                } while (isText && (zHaystack[0] & 192) == 128);\n            }\n        if (nNeedle > nHaystack)\n            N = 0;\n    }\n    sqlite3_result_int(context, N);\n  endInstr:\n    sqlite3_value_free(pC1);\n    sqlite3_value_free(pC2);\n    return;\n  endInstrOOM:\n    sqlite3_result_error_nomem(context);\n    goto endInstr;\n}\n"
  },
  {
    "id": "#23:25#sqlite3DeleteFrom",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    Vdbe *v;\n    Table *pTab;\n    int i;\n    WhereInfo *pWInfo;\n    Index *pIdx;\n    int iTabCur;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int nIdx;\n    sqlite3 *db;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int memCnt = 0;\n    int rcauth;\n    int eOnePass;\n    int aiCurOnePass[2];\n    u8 *aToOpen = 0;\n    Index *pPk;\n    int iPk = 0;\n    i16 nPk = 1;\n    int iKey;\n    i16 nKey;\n    int iEphCur = 0;\n    int iRowSet = 0;\n    int addrBypass = 0;\n    int addrLoop = 0;\n    int addrEphOpen = 0;\n    int bComplex;\n    int isView;\n    Trigger *pTrigger;\n    __builtin___memset_chk(&sContext, 0, sizeof (sContext), __builtin_object_size(&sContext, 0));\n    db = pParse->db;\n    ((void)0);\n    if (pParse->nErr) {\n        goto delete_from_cleanup;\n    }\n    ((void)0);\n    ((void)0);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto delete_from_cleanup;\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, 0);\n    isView = ((pTab)->eTabType == 2);\n    bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto delete_from_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, (pTrigger ? 1 : 0))) {\n        goto delete_from_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    ((void)0);\n    rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0, db->aDb[iDb].zDbSName);\n    ((void)0);\n    if (rcauth == 1) {\n        goto delete_from_cleanup;\n    }\n    ((void)0);\n    ((void)0);\n    iTabCur = pTabList->a[0].iCursor = pParse->nTab++;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        pParse->nTab++;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto delete_from_cleanup;\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, bComplex, iDb);\n    if (isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iTabCur);\n        iDataCur = iIdxCur = iTabCur;\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    __builtin___memset_chk(&sNC, 0, sizeof (sNC), __builtin_object_size(&sNC, 0));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    if (sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto delete_from_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        memCnt = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, memCnt);\n    }\n    if (rcauth == 0 && pWhere == 0 && !bComplex && !((pTab)->eTabType == 1)) {\n        ((void)0);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp4(v, 145, pTab->tnum, iDb, memCnt ? memCnt : -1, pTab->zName, (-1));\n        }\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            ((void)0);\n            if (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)) {\n                sqlite3VdbeAddOp3(v, 145, pIdx->tnum, iDb, memCnt ? memCnt : -1);\n            } else {\n                sqlite3VdbeAddOp2(v, 145, pIdx->tnum, iDb);\n            }\n        }\n    } else {\n        u16 wcf = 4 | 16;\n        if (sNC.ncFlags & 64)\n            bComplex = 1;\n        wcf |= (bComplex ? 0 : 8);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            pPk = 0;\n            nPk = 1;\n            iRowSet = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, iRowSet);\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            ((void)0);\n            nPk = pPk->nKeyCol;\n            iPk = pParse->nMem + 1;\n            pParse->nMem += nPk;\n            iEphCur = pParse->nTab++;\n            addrEphOpen = sqlite3VdbeAddOp2(v, 118, iEphCur, nPk);\n            sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n        }\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, wcf, iTabCur + 1);\n        if (pWInfo == 0)\n            goto delete_from_cleanup;\n        eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n        ((void)0);\n        ((void)0);\n        if (eOnePass != 1)\n            sqlite3MultiWrite(pParse);\n        if (sqlite3WhereUsesDeferredSeek(pWInfo)) {\n            sqlite3VdbeAddOp1(v, 143, iTabCur);\n        }\n        if (memCnt) {\n            sqlite3VdbeAddOp2(v, 86, memCnt, 1);\n        }\n        if (pPk) {\n            for (i = 0; i < nPk; i++) {\n                ((void)0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, pPk->aiColumn[i], iPk + i);\n            }\n            iKey = iPk;\n        } else {\n            iKey = ++pParse->nMem;\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);\n        }\n        if (eOnePass != 0) {\n            nKey = nPk;\n            aToOpen = sqlite3DbMallocRawNN(db, nIdx + 2);\n            if (aToOpen == 0) {\n                sqlite3WhereEnd(pWInfo);\n                goto delete_from_cleanup;\n            }\n            __builtin___memset_chk(aToOpen, 1, nIdx + 1, __builtin_object_size(aToOpen, 0));\n            aToOpen[nIdx + 1] = 0;\n            if (aiCurOnePass[0] >= 0)\n                aToOpen[aiCurOnePass[0] - iTabCur] = 0;\n            if (aiCurOnePass[1] >= 0)\n                aToOpen[aiCurOnePass[1] - iTabCur] = 0;\n            if (addrEphOpen)\n                sqlite3VdbeChangeToNoop(v, addrEphOpen);\n            addrBypass = sqlite3VdbeMakeLabel(pParse);\n        } else {\n            if (pPk) {\n                iKey = ++pParse->nMem;\n                nKey = 0;\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, iKey, sqlite3IndexAffinityStr(pParse->db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEphCur, iKey, iPk, nPk);\n            } else {\n                nKey = 1;\n                sqlite3VdbeAddOp2(v, 156, iRowSet, iKey);\n            }\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int iAddrOnce = 0;\n            if (eOnePass == 2) {\n                iAddrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            ;\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 8, iTabCur, aToOpen, &iDataCur, &iIdxCur);\n            ((void)0);\n            ((void)0);\n            if (eOnePass == 2) {\n                sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            ((void)0);\n            if (!((pTab)->eTabType == 1) && aToOpen[iDataCur - iTabCur]) {\n                ((void)0);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, nKey);\n                ;\n            }\n        } else if (pPk) {\n            addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur);\n            ;\n            if (((pTab)->eTabType == 1)) {\n                sqlite3VdbeAddOp3(v, 94, iEphCur, 0, iKey);\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEphCur, iKey);\n            }\n            ((void)0);\n        } else {\n            addrLoop = sqlite3VdbeAddOp3(v, 46, iRowSet, 0, iKey);\n            ;\n            ((void)0);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            ((void)0);\n            sqlite3MayAbort(pParse);\n            if (eOnePass == 1) {\n                sqlite3VdbeAddOp1(v, 122, iTabCur);\n                if (((pParse)->pToplevel == 0)) {\n                    pParse->isMultiWrite = 0;\n                }\n            }\n            sqlite3VdbeAddOp4(v, 7, 0, 1, iKey, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, 2);\n        } else {\n            int count = (pParse->nested == 0);\n            sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, iKey, nKey, count, 11, eOnePass, aiCurOnePass[1]);\n        }\n        if (eOnePass != 0) {\n            sqlite3VdbeResolveLabel(v, addrBypass);\n            sqlite3WhereEnd(pWInfo);\n        } else if (pPk) {\n            sqlite3VdbeAddOp2(v, 39, iEphCur, addrLoop + 1);\n            ;\n            sqlite3VdbeJumpHere(v, addrLoop);\n        } else {\n            sqlite3VdbeGoto(v, addrLoop);\n            sqlite3VdbeJumpHere(v, addrLoop);\n        }\n    }\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (memCnt) {\n        sqlite3CodeChangeCount(v, memCnt, \"rows deleted\");\n    }\n  delete_from_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprDelete(db, pWhere);\n    if (aToOpen)\n        sqlite3DbNNFreeNN(db, aToOpen);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3SrcListAppendFromTerm",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    SrcItem *pItem;\n    sqlite3 *db = pParse->db;\n    if (!p && pOnUsing != 0 && (pOnUsing->pOn || pOnUsing->pUsing)) {\n        sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", (pOnUsing->pOn ? \"ON\" : \"USING\"));\n        goto append_from_error;\n    }\n    p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);\n    if (p == 0) {\n        goto append_from_error;\n    }\n    ((void)0);\n    pItem = &p->a[p->nSrc - 1];\n    ((void)0);\n    ((void)0);\n    if ((pParse->eParseMode >= 2) && pItem->zName) {\n        Token *pToken = ((pDatabase) && pDatabase->z) ? pDatabase : pTable;\n        sqlite3RenameTokenMap(pParse, pItem->zName, pToken);\n    }\n    ((void)0);\n    if (pAlias->n) {\n        pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n    }\n    if (pSubquery) {\n        pItem->pSelect = pSubquery;\n        if (pSubquery->selFlags & 2048) {\n            pItem->fg.isNestedFrom = 1;\n        }\n    }\n    ((void)0);\n    ((void)0);\n    if (pOnUsing == 0) {\n        pItem->u3.pOn = 0;\n    } else if (pOnUsing->pUsing) {\n        pItem->fg.isUsing = 1;\n        pItem->u3.pUsing = pOnUsing->pUsing;\n    } else {\n        pItem->u3.pOn = pOnUsing->pOn;\n    }\n    return p;\n  append_from_error:\n    ((void)0);\n    sqlite3ClearOnOrUsing(db, pOnUsing);\n    sqlite3SelectDelete(db, pSubquery);\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropIndex",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    Index *pIndex;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_index;\n    }\n    ((void)0);\n    ((void)0);\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_drop_index;\n    }\n    pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n    if (pIndex == 0) {\n        if (!ifExists) {\n            sqlite3ErrorMsg(pParse, \"no such index: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        pParse->checkSchema = 1;\n        goto exit_drop_index;\n    }\n    if (pIndex->idxType != 0) {\n        sqlite3ErrorMsg(pParse, \"index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped\", 0);\n        goto exit_drop_index;\n    }\n    iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n    {\n        int code = 10;\n        Table *pTab = pIndex->pTable;\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_index;\n        }\n        if (!0 && iDb == 1)\n            code = 12;\n        if (sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb)) {\n            goto exit_drop_index;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        sqlite3NestedParse(pParse, \"DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'\", db->aDb[iDb].zDbSName, pIndex->zName);\n        sqlite3ClearStatTables(pParse, iDb, \"idx\", pIndex->zName);\n        sqlite3ChangeCookie(pParse, iDb);\n        destroyRootPage(pParse, pIndex->tnum, iDb);\n        sqlite3VdbeAddOp4(v, 152, iDb, 0, 0, pIndex->zName, 0);\n    }\n  exit_drop_index:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropTable",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    Table *pTab;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_table;\n    }\n    ((void)0);\n    ((void)0);\n    if (sqlite3ReadSchema(pParse))\n        goto exit_drop_table;\n    if (noErr)\n        db->suppressErr++;\n    ((void)0);\n    pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);\n    if (noErr)\n        db->suppressErr--;\n    if (pTab == 0) {\n        if (noErr) {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        goto exit_drop_table;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    ((void)0);\n    if (((pTab)->eTabType == 1) && sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_drop_table;\n    }\n    {\n        int code;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zArg2 = 0;\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_table;\n        }\n        if (isView) {\n            if (!0 && iDb == 1) {\n                code = 15;\n            } else {\n                code = 17;\n            }\n        } else if (((pTab)->eTabType == 1)) {\n            code = 30;\n            zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n        } else {\n            if (!0 && iDb == 1) {\n                code = 13;\n            } else {\n                code = 11;\n            }\n        }\n        if (sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb)) {\n            goto exit_drop_table;\n        }\n        if (sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb)) {\n            goto exit_drop_table;\n        }\n    }\n    if (tableMayNotBeDropped(db, pTab)) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (isView && !((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (!isView && ((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (!isView) {\n            sqlite3ClearStatTables(pParse, iDb, \"tbl\", pTab->zName);\n            sqlite3FkDropTable(pParse, pName, pTab);\n        }\n        sqlite3CodeDropTable(pParse, pTab, iDb, isView);\n    }\n  exit_drop_table:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AddGenerated",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    u8 eType = 32;\n    Table *pTab = pParse->pNewTable;\n    Column *pCol;\n    if (pTab == 0) {\n        goto generated_done;\n    }\n    pCol = &(pTab->aCol[pTab->nCol - 1]);\n    if ((pParse->eParseMode == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");\n        goto generated_done;\n    }\n    if (pCol->iDflt > 0)\n        goto generated_error;\n    if (pType) {\n        if (pType->n == 7 && sqlite3_strnicmp(\"virtual\", pType->z, 7) == 0) {\n        } else if (pType->n == 6 && sqlite3_strnicmp(\"stored\", pType->z, 6) == 0) {\n            eType = 64;\n        } else {\n            goto generated_error;\n        }\n    }\n    if (eType == 32)\n        pTab->nNVCol--;\n    pCol->colFlags |= eType;\n    ((void)0);\n    ((void)0);\n    pTab->tabFlags |= eType;\n    if (pCol->colFlags & 1) {\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n    }\n    if ((pExpr) && pExpr->op == 59) {\n        pExpr = sqlite3PExpr(pParse, 174, pExpr, 0);\n    }\n    sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);\n    pExpr = 0;\n    goto generated_done;\n  generated_error:\n    sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\", pCol->zCnName);\n  generated_done:\n    sqlite3ExprDelete(pParse->db, pExpr);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AddPrimaryKey",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Table *pTab = pParse->pNewTable;\n    Column *pCol = 0;\n    int iCol = -1, i;\n    int nTerm;\n    if (pTab == 0)\n        goto primary_key_exit;\n    if (pTab->tabFlags & 4) {\n        sqlite3ErrorMsg(pParse, \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n        goto primary_key_exit;\n    }\n    pTab->tabFlags |= 4;\n    if (pList == 0) {\n        iCol = pTab->nCol - 1;\n        pCol = &pTab->aCol[iCol];\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n        nTerm = 1;\n    } else {\n        nTerm = pList->nExpr;\n        for (i = 0; i < nTerm; i++) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);\n            ((void)0);\n            sqlite3StringToId(pCExpr);\n            if (pCExpr->op == 59) {\n                const char *zCName;\n                ((void)0);\n                zCName = pCExpr->u.zToken;\n                for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                    if (sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName) == 0) {\n                        pCol = &pTab->aCol[iCol];\n                        makeColumnPartOfPrimaryKey(pParse, pCol);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (nTerm == 1 && pCol && pCol->eCType == 4 && sortOrder != 1) {\n        if ((pParse->eParseMode >= 2) && pList) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n            sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);\n        }\n        pTab->iPKey = iCol;\n        pTab->keyConf = (u8)onError;\n        ((void)0);\n        pTab->tabFlags |= autoInc * 8;\n        if (pList)\n            pParse->iPkSortOrder = pList->a[0].fg.sortFlags;\n        (void)sqlite3HasExplicitNulls(pParse, pList);\n    } else if (autoInc) {\n        sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY\");\n    } else {\n        sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0, 2);\n        pList = 0;\n    }\n  primary_key_exit:\n    sqlite3ExprListDelete(pParse->db, pList);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterDropColumn",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iDb;\n    const char *zDb;\n    char *zCol = 0;\n    int iCol;\n    ((void)0);\n    ((void)0);\n    if ((db->mallocFailed))\n        goto exit_drop_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_drop_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_drop_column;\n    if (0 != isRealTable(pParse, pTab, 1))\n        goto exit_drop_column;\n    zCol = sqlite3NameFromToken(db, pName);\n    if (zCol == 0) {\n        ((void)0);\n        goto exit_drop_column;\n    }\n    iCol = sqlite3ColumnIndex(pTab, zCol);\n    if (iCol < 0) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pName);\n        goto exit_drop_column;\n    }\n    if (pTab->aCol[iCol].colFlags & (1 | 8)) {\n        sqlite3ErrorMsg(pParse, \"cannot drop %s column: \\\"%s\\\"\", (pTab->aCol[iCol].colFlags & 1) ? \"PRIMARY KEY\" : \"UNIQUE\", zCol);\n        goto exit_drop_column;\n    }\n    if (pTab->nCol <= 1) {\n        sqlite3ErrorMsg(pParse, \"cannot drop column \\\"%s\\\": no other columns exist\", zCol);\n        goto exit_drop_column;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    ((void)0);\n    zDb = db->aDb[iDb].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, zCol)) {\n        goto exit_drop_column;\n    }\n    renameTestSchema(pParse, zDb, iDb == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iDb == 1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)\", zDb, iDb, iCol, pTab->zName);\n    renameReloadSchema(pParse, iDb, 2);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after drop column\", 1);\n    if (pParse->nErr == 0 && (pTab->aCol[iCol].colFlags & 32) == 0) {\n        int i;\n        int addr;\n        int reg;\n        int regRec;\n        Index *pPk = 0;\n        int nField = 0;\n        int iCur;\n        Vdbe *v = sqlite3GetVdbe(pParse);\n        iCur = pParse->nTab++;\n        sqlite3OpenTable(pParse, iCur, iDb, pTab, 113);\n        addr = sqlite3VdbeAddOp1(v, 36, iCur);\n        ;\n        reg = ++pParse->nMem;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iCur, reg);\n            pParse->nMem += pTab->nCol;\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            pParse->nMem += pPk->nColumn;\n            for (i = 0; i < pPk->nKeyCol; i++) {\n                sqlite3VdbeAddOp3(v, 94, iCur, i, reg + i + 1);\n            }\n            nField = pPk->nKeyCol;\n        }\n        regRec = ++pParse->nMem;\n        for (i = 0; i < pTab->nCol; i++) {\n            if (i != iCol && (pTab->aCol[i].colFlags & 32) == 0) {\n                int regOut;\n                if (pPk) {\n                    int iPos = sqlite3TableColumnToIndex(pPk, i);\n                    int iColPos = sqlite3TableColumnToIndex(pPk, iCol);\n                    if (iPos < pPk->nKeyCol)\n                        continue;\n                    regOut = reg + 1 + iPos - (iPos > iColPos);\n                } else {\n                    regOut = reg + 1 + nField;\n                }\n                if (i == pTab->iPKey) {\n                    sqlite3VdbeAddOp2(v, 75, 0, regOut);\n                } else {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);\n                }\n                nField++;\n            }\n        }\n        if (nField == 0) {\n            pParse->nMem++;\n            sqlite3VdbeAddOp2(v, 75, 0, reg + 1);\n            nField = 1;\n        }\n        sqlite3VdbeAddOp3(v, 97, reg + 1, nField, regRec);\n        if (pPk) {\n            sqlite3VdbeAddOp4Int(v, 138, iCur, regRec, reg + 1, pPk->nKeyCol);\n        } else {\n            sqlite3VdbeAddOp3(v, 128, iCur, regRec, reg);\n        }\n        sqlite3VdbeChangeP5(v, 2);\n        sqlite3VdbeAddOp2(v, 39, iCur, addr + 1);\n        ;\n        sqlite3VdbeJumpHere(v, addr);\n    }\n  exit_drop_column:\n    sqlite3DbFree(db, zCol);\n    sqlite3SrcListDelete(db, pSrc);\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprCodeTarget",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op;\n    int inReg = target;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    Expr tempX;\n    int p5 = 0;\n    ((void)0);\n    ((void)0);\n  expr_code_doover:\n    if (pExpr == 0) {\n        op = 121;\n    } else if (pParse->pIdxEpr != 0 && !(((pExpr)->flags & (8388608)) != 0) && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target)) >= 0) {\n        return r1;\n    } else {\n        ((void)0);\n        op = pExpr->op;\n    }\n    switch (op) {\n      case 169:\n        {\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            struct AggInfo_col *pCol;\n            ((void)0);\n            ((void)0);\n            pCol = &pAggInfo->aCol[pExpr->iAgg];\n            if (!pAggInfo->directMode) {\n                return (((void)0) , (pAggInfo)->iFirstReg + (pExpr->iAgg));\n            } else if (pAggInfo->useSortingIdx) {\n                Table *pTab = pCol->pTab;\n                sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);\n                if (pTab == 0) {\n                } else if (pCol->iColumn < 0) {\n                    ;\n                } else {\n                    ;\n                    if (pTab->aCol[pCol->iColumn].affinity == 69) {\n                        sqlite3VdbeAddOp1(v, 87, target);\n                    }\n                }\n                return target;\n            } else if (pExpr->y.pTab == 0) {\n                sqlite3VdbeAddOp3(v, 94, pExpr->iTable, pExpr->iColumn, target);\n                return target;\n            }\n        }\n      case 167:\n        {\n            int iTab = pExpr->iTable;\n            int iReg;\n            if ((((pExpr)->flags & (32)) != 0)) {\n                int aff;\n                iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                ((void)0);\n                ((void)0);\n                aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n                if (aff > 65) {\n                    static const char zAff[] = \"B\\000C\\000D\\000E\\000F\";\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeAddOp4(v, 96, iReg, 1, 0, &zAff[(aff - 'B') * 2], (-1));\n                }\n                return iReg;\n            }\n            if (iTab < 0) {\n                if (pParse->iSelfTab < 0) {\n                    Column *pCol;\n                    Table *pTab;\n                    int iSrc;\n                    int iCol = pExpr->iColumn;\n                    ((void)0);\n                    pTab = pExpr->y.pTab;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    if (iCol < 0) {\n                        return -1 - pParse->iSelfTab;\n                    }\n                    pCol = pTab->aCol + iCol;\n                    ;\n                    iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n                    if (pCol->colFlags & 96) {\n                        if (pCol->colFlags & 256) {\n                            sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zCnName);\n                            return 0;\n                        }\n                        pCol->colFlags |= 256;\n                        if (pCol->colFlags & 128) {\n                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n                        }\n                        pCol->colFlags &= ~(256 | 128);\n                        return iSrc;\n                    } else if (pCol->affinity == 69) {\n                        sqlite3VdbeAddOp2(v, 81, iSrc, target);\n                        sqlite3VdbeAddOp1(v, 87, target);\n                        return target;\n                    } else {\n                        return iSrc;\n                    }\n                } else {\n                    iTab = pParse->iSelfTab - 1;\n                }\n            }\n            ((void)0);\n            ((void)0);\n            iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, pExpr->iColumn, iTab, target, pExpr->op2);\n            return iReg;\n        }\n      case 155:\n        {\n            codeInteger(pParse, pExpr, 0, target);\n            return target;\n        }\n      case 170:\n        {\n            sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target);\n            return target;\n        }\n      case 153:\n        {\n            ((void)0);\n            codeReal(v, pExpr->u.zToken, 0, target);\n            return target;\n        }\n      case 117:\n        {\n            ((void)0);\n            sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n            return target;\n        }\n      default:\n        {\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            return target;\n        }\n      case 154:\n        {\n            int n;\n            const char *z;\n            char *zBlob;\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            z = &pExpr->u.zToken[2];\n            n = sqlite3Strlen30(z) - 1;\n            ((void)0);\n            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n            sqlite3VdbeAddOp4(v, 77, n / 2, target, 0, zBlob, (-6));\n            return target;\n        }\n      case 156:\n        {\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 78, pExpr->iColumn, target);\n            if (pExpr->u.zToken[1] != 0) {\n                const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n                ((void)0);\n                pParse->pVList[0] = 0;\n                sqlite3VdbeAppendP4(v, (char *)z, (-1));\n            }\n            return target;\n        }\n      case 176:\n        {\n            return pExpr->iTable;\n        }\n      case 36:\n        {\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            if (inReg != target) {\n                sqlite3VdbeAddOp2(v, 81, inReg, target);\n                inReg = target;\n            }\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 88, target, sqlite3AffinityType(pExpr->u.zToken, 0));\n            return inReg;\n        }\n      case 45:\n      case 171:\n        op = (op == 45) ? 53 : 52;\n        p5 = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            if (sqlite3ExprIsVector(pLeft)) {\n                codeVectorCompare(pParse, pExpr, target, op, p5);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n                sqlite3VdbeAddOp2(v, 71, 1, inReg);\n                codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v) + 2, p5, (((pExpr)->flags & (1024)) != 0));\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                if (p5 == 128) {\n                    sqlite3VdbeAddOp2(v, 71, 0, inReg);\n                } else {\n                    sqlite3VdbeAddOp3(v, 92, r1, inReg, r2);\n                }\n                ;\n                ;\n            }\n            break;\n        }\n      case 44:\n      case 43:\n      case 106:\n      case 108:\n      case 107:\n      case 110:\n      case 102:\n      case 103:\n      case 109:\n      case 104:\n      case 105:\n      case 111:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            sqlite3VdbeAddOp3(v, op, r2, r1, target);\n            ;\n            ;\n            break;\n        }\n      case 173:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            ((void)0);\n            if (pLeft->op == 155) {\n                codeInteger(pParse, pLeft, 1, target);\n                return target;\n            } else if (pLeft->op == 153) {\n                ((void)0);\n                codeReal(v, pLeft->u.zToken, 1, target);\n                return target;\n            } else {\n                tempX.op = 155;\n                tempX.flags = 2048 | 65536;\n                tempX.u.iValue = 0;\n                ;\n                r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n                sqlite3VdbeAddOp3(v, 107, r2, r1, target);\n                ;\n            }\n            break;\n        }\n      case 114:\n      case 19:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            sqlite3VdbeAddOp2(v, op, r1, inReg);\n            break;\n        }\n      case 175:\n        {\n            int isTrue;\n            int bNormal;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            bNormal = pExpr->op2 == 45;\n            ;\n            ;\n            sqlite3VdbeAddOp4Int(v, 91, r1, inReg, !isTrue, isTrue ^ bNormal);\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            int addr;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            addr = sqlite3VdbeAddOp1(v, op, r1);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 71, 0, target);\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 168:\n        {\n            AggInfo *pInfo = pExpr->pAggInfo;\n            if (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)) {\n                ((void)0);\n                sqlite3ErrorMsg(pParse, \"misuse of aggregate: %#T()\", pExpr);\n            } else {\n                return (((void)0) , (pInfo)->iFirstReg + (pInfo)->nColumn + (pExpr->iAgg));\n            }\n            break;\n        }\n      case 172:\n        {\n            ExprList *pFarg;\n            int nFarg;\n            FuncDef *pDef;\n            const char *zId;\n            u32 constMask = 0;\n            int i;\n            sqlite3 *db = pParse->db;\n            u8 enc = ((db)->enc);\n            CollSeq *pColl = 0;\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                return pExpr->y.pWin->regResult;\n            }\n            if (((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr)) {\n                return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n            }\n            ((void)0);\n            ((void)0);\n            pFarg = pExpr->x.pList;\n            nFarg = pFarg ? pFarg->nExpr : 0;\n            ((void)0);\n            zId = pExpr->u.zToken;\n            pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n            if (pDef == 0 || pDef->xFinalize != 0) {\n                sqlite3ErrorMsg(pParse, \"unknown function: %#T()\", pExpr);\n                break;\n            }\n            if (pDef->funcFlags & 4194304) {\n                ((void)0);\n                ((void)0);\n                return exprCodeInlineFunction(pParse, pFarg, ((int)(intptr_t)(pDef->pUserData)), target);\n            } else if (pDef->funcFlags & (524288 | 2097152)) {\n                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n            }\n            for (i = 0; i < nFarg; i++) {\n                if (i < 32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {\n                    ;\n                    constMask |= (((unsigned int)1) << (i));\n                }\n                if ((pDef->funcFlags & 32) != 0 && !pColl) {\n                    pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n                }\n            }\n            if (pFarg) {\n                if (constMask) {\n                    r1 = pParse->nMem + 1;\n                    pParse->nMem += nFarg;\n                } else {\n                    r1 = sqlite3GetTempRange(pParse, nFarg);\n                }\n                if ((pDef->funcFlags & (64 | 128)) != 0) {\n                    u8 exprOp;\n                    ((void)0);\n                    ((void)0);\n                    exprOp = pFarg->a[0].pExpr->op;\n                    if (exprOp == 167 || exprOp == 169) {\n                        ((void)0);\n                        ((void)0);\n                        ;\n                        pFarg->a[0].pExpr->op2 = pDef->funcFlags & (64 | 128);\n                    }\n                }\n                sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 1 | 2);\n            } else {\n                r1 = 0;\n            }\n            if (nFarg >= 2 && (((pExpr)->flags & (256)) != 0)) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n            } else if (nFarg > 0) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n            }\n            if (pDef->funcFlags & 32) {\n                if (!pColl)\n                    pColl = db->pDfltColl;\n                sqlite3VdbeAddOp4(v, 85, 0, 0, 0, (char *)pColl, (-2));\n            }\n            sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg, pDef, pExpr->op2);\n            if (nFarg) {\n                if (constMask == 0) {\n                    sqlite3ReleaseTempRange(pParse, r1, nFarg);\n                } else {\n                    ;\n                }\n            }\n            return target;\n        }\n      case 20:\n      case 138:\n        {\n            int nCol;\n            ;\n            ;\n            if (pParse->db->mallocFailed) {\n                return 0;\n            } else if (op == 138 && ((((pExpr)->flags & 4096) != 0)) && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {\n                sqlite3SubselectError(pParse, nCol, 1);\n            } else {\n                return sqlite3CodeSubselect(pParse, pExpr);\n            }\n            break;\n        }\n      case 178:\n        {\n            int n;\n            Expr *pLeft = pExpr->pLeft;\n            if (pLeft->iTable == 0 || pParse->withinRJSubrtn > pLeft->op2) {\n                pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);\n                pLeft->op2 = pParse->withinRJSubrtn;\n            }\n            ((void)0);\n            n = sqlite3ExprVectorSize(pLeft);\n            if (pExpr->iTable != n) {\n                sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pExpr->iTable, n);\n            }\n            return pLeft->iTable + pExpr->iColumn;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            sqlite3VdbeAddOp2(v, 86, target, 0);\n            sqlite3VdbeResolveLabel(v, destIfNull);\n            return target;\n        }\n      case 48:\n        {\n            exprCodeBetween(pParse, pExpr, target, 0, 0);\n            return target;\n        }\n      case 113:\n        {\n            if (!(((pExpr)->flags & (512)) != 0) && (pExpr->pLeft) && pExpr->pLeft->op == 172) {\n                inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                if (inReg != target) {\n                    sqlite3VdbeAddOp2(v, 81, inReg, target);\n                    inReg = target;\n                }\n                sqlite3VdbeAddOp1(v, 179, inReg);\n                return inReg;\n            } else {\n                pExpr = pExpr->pLeft;\n                goto expr_code_doover;\n            }\n        }\n      case 181:\n      case 174:\n        {\n            pExpr = pExpr->pLeft;\n            goto expr_code_doover;\n        }\n      case 77:\n        {\n            Table *pTab;\n            int iCol;\n            int p1;\n            ((void)0);\n            pTab = pExpr->y.pTab;\n            iCol = pExpr->iColumn;\n            p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, iCol);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 157, p1, target);\n            ;\n            if (iCol >= 0 && pTab->aCol[iCol].affinity == 69) {\n                sqlite3VdbeAddOp1(v, 87, target);\n            }\n            break;\n        }\n      case 177:\n        {\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            break;\n        }\n      case 179:\n        {\n            int addrINR;\n            u8 okConstFactor = pParse->okConstFactor;\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            if (pAggInfo) {\n                ((void)0);\n                if (!pAggInfo->directMode) {\n                    inReg = (((void)0) , (pAggInfo)->iFirstReg + (pExpr->iAgg));\n                    break;\n                }\n                if (pExpr->pAggInfo->useSortingIdx) {\n                    sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pAggInfo->aCol[pExpr->iAgg].iSorterColumn, target);\n                    inReg = target;\n                    break;\n                }\n            }\n            addrINR = sqlite3VdbeAddOp1(v, 20, pExpr->iTable);\n            pParse->okConstFactor = 0;\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            pParse->okConstFactor = okConstFactor;\n            sqlite3VdbeJumpHere(v, addrINR);\n            sqlite3VdbeChangeP3(v, addrINR, inReg);\n            break;\n        }\n      case 157:\n        {\n            int endLabel;\n            int nextCase;\n            int nExpr;\n            int i;\n            ExprList *pEList;\n            struct ExprList_item *aListelem;\n            Expr opCompare;\n            Expr *pX;\n            Expr *pTest = 0;\n            Expr *pDel = 0;\n            sqlite3 *db = pParse->db;\n            ((void)0);\n            ((void)0);\n            pEList = pExpr->x.pList;\n            aListelem = pEList->a;\n            nExpr = pEList->nExpr;\n            endLabel = sqlite3VdbeMakeLabel(pParse);\n            if ((pX = pExpr->pLeft) != 0) {\n                pDel = sqlite3ExprDup(db, pX, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDel);\n                    break;\n                }\n                ;\n                exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n                ;\n                __builtin___memset_chk(&opCompare, 0, sizeof (opCompare), __builtin_object_size(&opCompare, 0));\n                opCompare.op = 53;\n                opCompare.pLeft = pDel;\n                pTest = &opCompare;\n                regFree1 = 0;\n            }\n            for (i = 0; i < nExpr - 1; i = i + 2) {\n                if (pX) {\n                    ((void)0);\n                    opCompare.pRight = aListelem[i].pExpr;\n                } else {\n                    pTest = aListelem[i].pExpr;\n                }\n                nextCase = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);\n                ;\n                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);\n                sqlite3VdbeGoto(v, endLabel);\n                sqlite3VdbeResolveLabel(v, nextCase);\n            }\n            if ((nExpr & 1) != 0) {\n                sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, target);\n            }\n            sqlite3ExprDelete(db, pDel);\n            setDoNotMergeFlagOnCopy(v);\n            sqlite3VdbeResolveLabel(v, endLabel);\n            break;\n        }\n      case 71:\n        {\n            ((void)0);\n            if (!pParse->pTriggerTab && !pParse->nested) {\n                sqlite3ErrorMsg(pParse, \"RAISE() may only be used within a trigger-program\");\n                return 0;\n            }\n            if (pExpr->affExpr == 2) {\n                sqlite3MayAbort(pParse);\n            }\n            ((void)0);\n            if (pExpr->affExpr == 4) {\n                sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr->u.zToken, 0);\n                ;\n            } else {\n                sqlite3HaltConstraint(pParse, pParse->pTriggerTab ? (19 | (7 << 8)) : 1, pExpr->affExpr, pExpr->u.zToken, 0, 0);\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    return inReg;\n}\n"
  },
  {
    "id": "sqlite3.c#109116:1#sqlite3ExprCodeIN",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    int rRhsHasNull = 0;\n    int eType;\n    int rLhs;\n    int rLhsOrig;\n    Vdbe *v;\n    int *aiMap = 0;\n    char *zAff = 0;\n    int nVector;\n    int iDummy;\n    Expr *pLeft;\n    int i;\n    int destStep2;\n    int destStep6 = 0;\n    int addrTruthOp;\n    int destNotNull;\n    int addrTop;\n    int iTab = 0;\n    u8 okConstFactor = pParse->okConstFactor;\n    ((void)0);\n    pLeft = pExpr->pLeft;\n    if (sqlite3ExprCheckIN(pParse, pExpr))\n        return;\n    zAff = exprINAffinity(pParse, pExpr);\n    nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n    aiMap = (int *)sqlite3DbMallocZero(pParse->db, nVector * (sizeof(int) + sizeof(char)) + 1);\n    if (pParse->db->mallocFailed)\n        goto sqlite3ExprCodeIN_oom_error;\n    v = pParse->pVdbe;\n    ((void)0);\n    ;\n    eType = sqlite3FindInIndex(pParse, pExpr, 2 | 1, destIfFalse == destIfNull ? 0 : &rRhsHasNull, aiMap, &iTab);\n    ((void)0);\n    ((void)0);\n    pParse->okConstFactor = 0;\n    rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);\n    pParse->okConstFactor = okConstFactor;\n    for (i = 0; i < nVector && aiMap[i] == i; i++) {\n    }\n    if (i == nVector) {\n        rLhs = rLhsOrig;\n    } else {\n        rLhs = sqlite3GetTempRange(pParse, nVector);\n        for (i = 0; i < nVector; i++) {\n            sqlite3VdbeAddOp3(v, 80, rLhsOrig + i, rLhs + aiMap[i], 0);\n        }\n    }\n    if (eType == 5) {\n        ExprList *pList;\n        CollSeq *pColl;\n        int labelOk = sqlite3VdbeMakeLabel(pParse);\n        int r2, regToFree;\n        int regCkNull = 0;\n        int ii;\n        ((void)0);\n        pList = pExpr->x.pList;\n        pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n        if (destIfNull != destIfFalse) {\n            regCkNull = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp3(v, 102, rLhs, rLhs, regCkNull);\n        }\n        for (ii = 0; ii < pList->nExpr; ii++) {\n            r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n            if (regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr)) {\n                sqlite3VdbeAddOp3(v, 102, regCkNull, r2, regCkNull);\n            }\n            sqlite3ReleaseTempReg(pParse, regToFree);\n            if (ii < pList->nExpr - 1 || destIfNull != destIfFalse) {\n                int op = rLhs != r2 ? 53 : 51;\n                sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2, (void *)pColl, (-2));\n                ;\n                ;\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0]);\n            } else {\n                int op = rLhs != r2 ? 52 : 50;\n                ((void)0);\n                sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2, (void *)pColl, (-2));\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0] | 16);\n            }\n        }\n        if (regCkNull) {\n            sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull);\n            ;\n            sqlite3VdbeGoto(v, destIfFalse);\n        }\n        sqlite3VdbeResolveLabel(v, labelOk);\n        sqlite3ReleaseTempReg(pParse, regCkNull);\n        goto sqlite3ExprCodeIN_finished;\n    }\n    if (destIfNull == destIfFalse) {\n        destStep2 = destIfFalse;\n    } else {\n        destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n        if (pParse->nErr)\n            goto sqlite3ExprCodeIN_oom_error;\n        if (sqlite3ExprCanBeNull(p)) {\n            sqlite3VdbeAddOp2(v, 50, rLhs + i, destStep2);\n            ;\n        }\n    }\n    if (eType == 1) {\n        sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);\n        ;\n        addrTruthOp = sqlite3VdbeAddOp0(v, 9);\n    } else {\n        sqlite3VdbeAddOp4(v, 96, rLhs, nVector, 0, zAff, nVector);\n        if (destIfFalse == destIfNull) {\n            sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse, rLhs, nVector);\n            ;\n            goto sqlite3ExprCodeIN_finished;\n        }\n        addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0, rLhs, nVector);\n        ;\n    }\n    if (rRhsHasNull && nVector == 1) {\n        sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse);\n        ;\n    }\n    if (destIfFalse == destIfNull)\n        sqlite3VdbeGoto(v, destIfFalse);\n    if (destStep6)\n        sqlite3VdbeResolveLabel(v, destStep6);\n    addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);\n    ;\n    if (nVector > 1) {\n        destNotNull = sqlite3VdbeMakeLabel(pParse);\n    } else {\n        destNotNull = destIfFalse;\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p;\n        CollSeq *pColl;\n        int r3 = sqlite3GetTempReg(pParse);\n        p = sqlite3VectorFieldSubexpr(pLeft, i);\n        pColl = sqlite3ExprCollSeq(pParse, p);\n        sqlite3VdbeAddOp3(v, 94, iTab, i, r3);\n        sqlite3VdbeAddOp4(v, 52, rLhs + i, destNotNull, r3, (void *)pColl, (-2));\n        ;\n        sqlite3ReleaseTempReg(pParse, r3);\n    }\n    sqlite3VdbeAddOp2(v, 9, 0, destIfNull);\n    if (nVector > 1) {\n        sqlite3VdbeResolveLabel(v, destNotNull);\n        sqlite3VdbeAddOp2(v, 39, iTab, addrTop + 1);\n        ;\n        sqlite3VdbeAddOp2(v, 9, 0, destIfFalse);\n    }\n    sqlite3VdbeJumpHere(v, addrTruthOp);\n  sqlite3ExprCodeIN_finished:\n    if (rLhs != rLhsOrig)\n        sqlite3ReleaseTempReg(pParse, rLhs);\n    ;\n  sqlite3ExprCodeIN_oom_error:\n    sqlite3DbFree(pParse->db, aiMap);\n    sqlite3DbFree(pParse->db, zAff);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterRenameColumn",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iCol;\n    char *zOld = 0;\n    char *zNew = 0;\n    const char *zDb;\n    int iSchema;\n    int bQuote;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_rename_column;\n    if (0 != isRealTable(pParse, pTab, 0))\n        goto exit_rename_column;\n    iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);\n    ((void)0);\n    zDb = db->aDb[iSchema].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_column;\n    }\n    zOld = sqlite3NameFromToken(db, pOld);\n    if (!zOld)\n        goto exit_rename_column;\n    for (iCol = 0; iCol < pTab->nCol; iCol++) {\n        if (0 == sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld))\n            break;\n    }\n    if (iCol == pTab->nCol) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pOld);\n        goto exit_rename_column;\n    }\n    renameTestSchema(pParse, zDb, iSchema == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iSchema == 1);\n    sqlite3MayAbort(pParse);\n    zNew = sqlite3NameFromToken(db, pNew);\n    if (!zNew)\n        goto exit_rename_column;\n    ((void)0);\n    bQuote = (sqlite3CtypeMap[(unsigned char)(pNew->z[0])] & 128);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)\", zDb, zDb, pTab->zName, iCol, zNew, bQuote, iSchema == 1, pTab->zName);\n    sqlite3NestedParse(pParse, \"UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')\", zDb, pTab->zName, iCol, zNew, bQuote);\n    renameReloadSchema(pParse, iSchema, 1);\n    renameTestSchema(pParse, zDb, iSchema == 1, \"after rename\", 1);\n  exit_rename_column:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zOld);\n    sqlite3DbFree(db, zNew);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3WhereBegin",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    int nByteWInfo;\n    int nTabList;\n    WhereInfo *pWInfo;\n    Vdbe *v = pParse->pVdbe;\n    Bitmask notReady;\n    WhereLoopBuilder sWLB;\n    WhereMaskSet *pMaskSet;\n    WhereLevel *pLevel;\n    WhereLoop *pLoop;\n    int ii;\n    sqlite3 *db;\n    int rc;\n    u8 bFordelete = 0;\n    ((void)0);\n    ((void)0);\n    db = pParse->db;\n    __builtin___memset_chk(&sWLB, 0, sizeof (sWLB), __builtin_object_size(&sWLB, 0));\n    ;\n    if (pOrderBy && pOrderBy->nExpr >= ((int)(sizeof(Bitmask) * 8)))\n        pOrderBy = 0;\n    ;\n    if (pTabList->nSrc > ((int)(sizeof(Bitmask) * 8))) {\n        sqlite3ErrorMsg(pParse, \"at most %d tables in a join\", ((int)(sizeof(Bitmask) * 8)));\n        return 0;\n    }\n    nTabList = (wctrlFlags & 32) ? 1 : pTabList->nSrc;\n    nByteWInfo = (sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel));\n    pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));\n    if (db->mallocFailed) {\n        sqlite3DbFree(db, pWInfo);\n        pWInfo = 0;\n        goto whereBeginError;\n    }\n    pWInfo->pParse = pParse;\n    pWInfo->pTabList = pTabList;\n    pWInfo->pOrderBy = pOrderBy;\n    pWInfo->pResultSet = pResultSet;\n    pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;\n    pWInfo->nLevel = nTabList;\n    pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);\n    pWInfo->wctrlFlags = wctrlFlags;\n    pWInfo->iLimit = iAuxArg;\n    pWInfo->savedNQueryLoop = pParse->nQueryLoop;\n    pWInfo->pSelect = pSelect;\n    __builtin___memset_chk(&pWInfo->nOBSat, 0, __builtin_offsetof(WhereInfo, sWC) - __builtin_offsetof(WhereInfo, nOBSat), __builtin_object_size(&pWInfo->nOBSat, 0));\n    __builtin___memset_chk(&pWInfo->a[0], 0, sizeof(WhereLoop) + nTabList * sizeof(WhereLevel), __builtin_object_size(&pWInfo->a[0], 0));\n    ((void)0);\n    pMaskSet = &pWInfo->sMaskSet;\n    pMaskSet->n = 0;\n    pMaskSet->ix[0] = -99;\n    sWLB.pWInfo = pWInfo;\n    sWLB.pWC = &pWInfo->sWC;\n    sWLB.pNew = (WhereLoop *)(((char *)pWInfo) + nByteWInfo);\n    ((void)0);\n    whereLoopInit(sWLB.pNew);\n    sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);\n    sqlite3WhereSplit(&pWInfo->sWC, pWhere, 44);\n    if (nTabList == 0) {\n        if (pOrderBy)\n            pWInfo->nOBSat = pOrderBy->nExpr;\n        if ((wctrlFlags & 256) != 0 && (((db)->dbOptFlags & (16)) == 0)) {\n            pWInfo->eDistinct = 1;\n        }\n        sqlite3VdbeExplain(pParse, 0, \"SCAN CONSTANT ROW\");\n    } else {\n        ii = 0;\n        do {\n            createMask(pMaskSet, pTabList->a[ii].iCursor);\n            sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);\n        } while ((++ii) < pTabList->nSrc);\n    }\n    sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);\n    if (pSelect && pSelect->pLimit) {\n        sqlite3WhereAddLimit(&pWInfo->sWC, pSelect);\n    }\n    if (pParse->nErr)\n        goto whereBeginError;\n    for (ii = 0; ii < sWLB.pWC->nBase; ii++) {\n        WhereTerm *pT = &sWLB.pWC->a[ii];\n        if (pT->wtFlags & 2)\n            continue;\n        if (pT->prereqAll == 0 && (nTabList == 0 || exprIsDeterministic(pT->pExpr))) {\n            sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 16);\n            pT->wtFlags |= 4;\n        }\n    }\n    if (wctrlFlags & 256) {\n        if ((((db)->dbOptFlags & (16)) != 0)) {\n            wctrlFlags &= ~256;\n            pWInfo->wctrlFlags &= ~256;\n        } else if (isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet)) {\n            pWInfo->eDistinct = 1;\n        } else if (pOrderBy == 0) {\n            pWInfo->wctrlFlags |= 128;\n            pWInfo->pOrderBy = pResultSet;\n        }\n    }\n    if (nTabList != 1 || whereShortCut(&sWLB) == 0) {\n        rc = whereLoopAddAll(&sWLB);\n        if (rc)\n            goto whereBeginError;\n        ;\n        wherePathSolver(pWInfo, 0);\n        if (db->mallocFailed)\n            goto whereBeginError;\n        if (pWInfo->pOrderBy) {\n            wherePathSolver(pWInfo, pWInfo->nRowOut + 1);\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n    }\n    if (pWInfo->pOrderBy == 0 && (db->flags & 4096) != 0) {\n        pWInfo->revMask = ((Bitmask)-1);\n    }\n    if (pParse->nErr) {\n        goto whereBeginError;\n    }\n    ((void)0);\n    notReady = ~(Bitmask)0;\n    if (pWInfo->nLevel >= 2 && pResultSet != 0 && 0 == (wctrlFlags & 1024) && (((db)->dbOptFlags & (256)) == 0)) {\n        notReady = whereOmitNoopJoin(pWInfo, notReady);\n        nTabList = pWInfo->nLevel;\n        ((void)0);\n    }\n    if (pWInfo->nLevel >= 2 && (((db)->dbOptFlags & (524288)) == 0)) {\n        whereCheckIfBloomFilterIsUseful(pWInfo);\n    }\n    pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;\n    ((void)0);\n    if ((wctrlFlags & 4) != 0) {\n        int wsFlags = pWInfo->a[0].pWLoop->wsFlags;\n        int bOnerow = (wsFlags & 4096) != 0;\n        ((void)0);\n        if (bOnerow || (0 != (wctrlFlags & 8) && !((pTabList->a[0].pTab)->eTabType == 1) && (0 == (wsFlags & 8192) || (wctrlFlags & 16)))) {\n            pWInfo->eOnePass = bOnerow ? 1 : 2;\n            if ((((pTabList->a[0].pTab)->tabFlags & 128) == 0) && (wsFlags & 64)) {\n                if (wctrlFlags & 8) {\n                    bFordelete = 8;\n                }\n                pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~64);\n            }\n        }\n    }\n    for (ii = 0 , pLevel = pWInfo->a; ii < nTabList; ii++ , pLevel++) {\n        Table *pTab;\n        int iDb;\n        SrcItem *pTabItem;\n        pTabItem = &pTabList->a[pLevel->iFrom];\n        pTab = pTabItem->pTab;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        pLoop = pLevel->pWLoop;\n        if ((pTab->tabFlags & 16384) != 0 || ((pTab)->eTabType == 2)) {\n        } else if ((pLoop->wsFlags & 1024) != 0) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            int iCur = pTabItem->iCursor;\n            sqlite3VdbeAddOp4(v, 173, iCur, 0, 0, pVTab, (-11));\n        } else if (((pTab)->eTabType == 1)) {\n        } else if (((pLoop->wsFlags & 64) == 0 && (wctrlFlags & 32) == 0) || (pTabItem->fg.jointype & (64 | 16)) != 0) {\n            int op = 112;\n            if (pWInfo->eOnePass != 0) {\n                op = 113;\n                pWInfo->aiCurOnePass[0] = pTabItem->iCursor;\n            }\n            ;\n            sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);\n            ((void)0);\n            ;\n            ;\n            if (pWInfo->eOnePass == 0 && pTab->nCol < ((int)(sizeof(Bitmask) * 8)) && (pTab->tabFlags & (96 | 128)) == 0 && (pLoop->wsFlags & (16384 | 4194304)) == 0) {\n                Bitmask b = pTabItem->colUsed;\n                int n = 0;\n                for (; b; b = b >> 1 , n++) {\n                }\n                sqlite3VdbeChangeP4(v, -1, ((void *)(intptr_t)(n)), (-3));\n                ((void)0);\n            }\n            {\n                sqlite3VdbeChangeP5(v, bFordelete);\n            }\n        } else {\n            sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n        }\n        if (pLoop->wsFlags & 512) {\n            Index *pIx = pLoop->u.btree.pIndex;\n            int iIndexCur;\n            int op = 112;\n            ((void)0);\n            if (!(((pTab)->tabFlags & 128) == 0) && ((pIx)->idxType == 2) && (wctrlFlags & 32) != 0) {\n                iIndexCur = pLevel->iTabCur;\n                op = 0;\n            } else if (pWInfo->eOnePass != 0) {\n                Index *pJ = pTabItem->pTab->pIndex;\n                iIndexCur = iAuxArg;\n                ((void)0);\n                while ((pJ) && pJ != pIx)\n                    {\n                        iIndexCur++;\n                        pJ = pJ->pNext;\n                    }\n                op = 113;\n                pWInfo->aiCurOnePass[1] = iIndexCur;\n            } else if (iAuxArg && (wctrlFlags & 32) != 0) {\n                iIndexCur = iAuxArg;\n                op = 101;\n            } else {\n                iIndexCur = pParse->nTab++;\n                if (pIx->bHasExpr && (((db)->dbOptFlags & (16777216)) == 0)) {\n                    whereAddIndexedExpr(pParse, pIx, iIndexCur, pTabItem);\n                }\n            }\n            pLevel->iIdxCur = iIndexCur;\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            if (op) {\n                sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);\n                sqlite3VdbeSetP4KeyInfo(pParse, pIx);\n                if ((pLoop->wsFlags & 15) != 0 && (pLoop->wsFlags & (2 | 32768)) == 0 && (pLoop->wsFlags & 524288) == 0 && (pLoop->wsFlags & 1048576) == 0 && (pWInfo->wctrlFlags & 1) == 0 && pWInfo->eDistinct != 2) {\n                    sqlite3VdbeChangeP5(v, 2);\n                }\n                ;\n            }\n        }\n        if (iDb >= 0)\n            sqlite3CodeVerifySchema(pParse, iDb);\n        if ((pTabItem->fg.jointype & 16) != 0 && (pLevel->pRJ = sqlite3WhereMalloc(pWInfo, sizeof(WhereRightJoin))) != 0) {\n            WhereRightJoin *pRJ = pLevel->pRJ;\n            pRJ->iMatch = pParse->nTab++;\n            pRJ->regBloom = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 77, 65536, pRJ->regBloom);\n            pRJ->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, pRJ->regReturn);\n            ((void)0);\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                KeyInfo *pInfo;\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, 1);\n                pInfo = sqlite3KeyInfoAlloc(pParse->db, 1, 0);\n                if (pInfo) {\n                    pInfo->aColl[0] = 0;\n                    pInfo->aSortFlags[0] = 0;\n                    sqlite3VdbeAppendP4(v, pInfo, (-8));\n                }\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            pLoop->wsFlags &= ~64;\n            pWInfo->nOBSat = 0;\n            pWInfo->eDistinct = 3;\n        }\n    }\n    pWInfo->iTop = sqlite3VdbeCurrentAddr(v);\n    if (db->mallocFailed)\n        goto whereBeginError;\n    for (ii = 0; ii < nTabList; ii++) {\n        int addrExplain;\n        int wsFlags;\n        SrcItem *pSrc;\n        if (pParse->nErr)\n            goto whereBeginError;\n        pLevel = &pWInfo->a[ii];\n        wsFlags = pLevel->pWLoop->wsFlags;\n        pSrc = &pTabList->a[pLevel->iFrom];\n        if (pSrc->fg.isMaterialized) {\n            if (pSrc->fg.isCorrelated) {\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n            } else {\n                int iOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n                sqlite3VdbeJumpHere(v, iOnce);\n            }\n        }\n        if ((wsFlags & (16384 | 4194304)) != 0) {\n            if ((wsFlags & 16384) != 0) {\n                constructAutomaticIndex(pParse, &pWInfo->sWC, &pTabList->a[pLevel->iFrom], notReady, pLevel);\n            } else {\n                sqlite3ConstructBloomFilter(pWInfo, ii, pLevel, notReady);\n            }\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n        addrExplain = sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, wctrlFlags);\n        pLevel->addrBody = sqlite3VdbeCurrentAddr(v);\n        notReady = sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, ii, pLevel, notReady);\n        pWInfo->iContinue = pLevel->addrCont;\n        if ((wsFlags & 8192) == 0 && (wctrlFlags & 32) == 0) {\n            ((void)addrExplain);\n        }\n    }\n    ;\n    pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);\n    return pWInfo;\n  whereBeginError:\n    if (pWInfo) {\n        pParse->nQueryLoop = pWInfo->savedNQueryLoop;\n        whereInfoFree(db, pWInfo);\n    }\n    return 0;\n}\n"
  },
  {
    "id": "sqlite3.c#42984:1#unixOpen",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    unixFile *p = (unixFile *)pFile;\n    int fd = -1;\n    int openFlags = 0;\n    int eType = flags & 1048320;\n    int noLock;\n    int rc = 0;\n    int ctrlFlags = 0;\n    int isExclusive = (flags & 16);\n    int isDelete = (flags & 8);\n    int isCreate = (flags & 4);\n    int isReadonly = (flags & 1);\n    int isReadWrite = (flags & 2);\n    int isAutoProxy = (flags & 32);\n    struct statfs fsInfo;\n    int isNewJrnl = (isCreate && (eType == 16384 || eType == 2048 || eType == 524288));\n    char zTmpname[514];\n    const char *zName = zPath;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (randomnessPid != (pid_t)getpid()) {\n        randomnessPid = (pid_t)getpid();\n        sqlite3_randomness(0, 0);\n    }\n    __builtin___memset_chk(p, 0, sizeof(unixFile), __builtin_object_size(p, 0));\n    if (eType == 256) {\n        UnixUnusedFd *pUnused;\n        pUnused = findReusableFd(zName, flags);\n        if (pUnused) {\n            fd = pUnused->fd;\n        } else {\n            pUnused = sqlite3_malloc64(sizeof (*pUnused));\n            if (!pUnused) {\n                return 7;\n            }\n        }\n        p->pPreallocatedUnused = pUnused;\n        ((void)0);\n    } else if (!zName) {\n        ((void)0);\n        rc = unixGetTempname(pVfs->mxPathname, zTmpname);\n        if (rc != 0) {\n            return rc;\n        }\n        zName = zTmpname;\n        ((void)0);\n    }\n    if (isReadonly)\n        openFlags |= 0;\n    if (isReadWrite)\n        openFlags |= 2;\n    if (isCreate)\n        openFlags |= 512;\n    if (isExclusive)\n        openFlags |= (2048 | 256);\n    openFlags |= (0 | 0 | 256);\n    if (fd < 0) {\n        mode_t openMode;\n        uid_t uid;\n        gid_t gid;\n        rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);\n        if (rc != 0) {\n            ((void)0);\n            ((void)0);\n            return rc;\n        }\n        fd = robust_open(zName, openFlags, openMode);\n        ;\n        ((void)0);\n        if (fd < 0) {\n            if (isNewJrnl && (*__error()) == 13 && ((int (*)(const char *, int))aSyscall[2].pCurrent)(zName, 0)) {\n                rc = (8 | (6 << 8));\n            } else if ((*__error()) != 21 && isReadWrite) {\n                flags &= ~(2 | 4);\n                openFlags &= ~(2 | 512);\n                flags |= 1;\n                openFlags |= 0;\n                isReadonly = 1;\n                fd = robust_open(zName, openFlags, openMode);\n            }\n        }\n        if (fd < 0) {\n            int rc2 = unixLogErrorAtLine(sqlite3CantopenError(43140), \"open\", zName, 43140);\n            if (rc == 0)\n                rc = rc2;\n            goto open_finished;\n        }\n        if (openMode && (flags & (524288 | 2048)) != 0) {\n            robustFchown(fd, uid, gid);\n        }\n    }\n    ((void)0);\n    if (pOutFlags) {\n        *pOutFlags = flags;\n    }\n    if (p->pPreallocatedUnused) {\n        p->pPreallocatedUnused->fd = fd;\n        p->pPreallocatedUnused->flags = flags & (1 | 2);\n    }\n    if (isDelete) {\n        ((int (*)(const char *))aSyscall[16].pCurrent)(zName);\n    } else {\n        p->openFlags = openFlags;\n    }\n    if (fstatfs(fd, &fsInfo) == -1) {\n        storeLastErrno(p, (*__error()));\n        robust_close(p, fd, 43194);\n        return (10 | (13 << 8));\n    }\n    if (0 == strncmp(\"msdos\", fsInfo.f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (0 == strncmp(\"exfat\", fsInfo.f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (isDelete)\n        ctrlFlags |= 32;\n    if (isReadonly)\n        ctrlFlags |= 2;\n    noLock = eType != 256;\n    if (noLock)\n        ctrlFlags |= 128;\n    if (isNewJrnl)\n        ctrlFlags |= 8;\n    if (flags & 64)\n        ctrlFlags |= 64;\n    if (isAutoProxy && (zPath != ((void *)0)) && (!noLock) && pVfs->xOpen) {\n        char *envforce = getenv(\"SQLITE_FORCE_PROXY_LOCKING\");\n        int useProxy = 0;\n        if (envforce != ((void *)0)) {\n            useProxy = atoi(envforce) > 0;\n        } else {\n            useProxy = !(fsInfo.f_flags & 4096);\n        }\n        if (useProxy) {\n            rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n            if (rc == 0) {\n                rc = proxyTransformUnixFile((unixFile *)pFile, \":auto:\");\n                if (rc != 0) {\n                    unixClose(pFile);\n                    return rc;\n                }\n            }\n            goto open_finished;\n        }\n    }\n    ((void)0);\n    rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n  open_finished:\n    if (rc != 0) {\n        sqlite3_free(p->pPreallocatedUnused);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#131691:12#sqlite3_exec",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    const char *zLeftover;\n    sqlite3_stmt *pStmt = 0;\n    char **azCols = 0;\n    int callbackIsInit;\n    if (!sqlite3SafetyCheckOk(db))\n        return sqlite3MisuseError(131704);\n    if (zSql == 0)\n        zSql = \"\";\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3Error(db, 0);\n    while (rc == 0 && zSql[0])\n        {\n            int nCol = 0;\n            char **azVals = 0;\n            pStmt = 0;\n            rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n            ((void)0);\n            if (rc != 0) {\n                continue;\n            }\n            if (!pStmt) {\n                zSql = zLeftover;\n                continue;\n            }\n            callbackIsInit = 0;\n            while (1)\n                {\n                    int i;\n                    rc = sqlite3_step(pStmt);\n                    if (xCallback && (100 == rc || (101 == rc && !callbackIsInit && db->flags & 256))) {\n                        if (!callbackIsInit) {\n                            nCol = sqlite3_column_count(pStmt);\n                            azCols = sqlite3DbMallocRaw(db, (2 * nCol + 1) * sizeof(const char *));\n                            if (azCols == 0) {\n                                goto exec_out;\n                            }\n                            for (i = 0; i < nCol; i++) {\n                                azCols[i] = (char *)sqlite3_column_name(pStmt, i);\n                                ((void)0);\n                            }\n                            callbackIsInit = 1;\n                        }\n                        if (rc == 100) {\n                            azVals = &azCols[nCol];\n                            for (i = 0; i < nCol; i++) {\n                                azVals[i] = (char *)sqlite3_column_text(pStmt, i);\n                                if (!azVals[i] && sqlite3_column_type(pStmt, i) != 5) {\n                                    sqlite3OomFault(db);\n                                    goto exec_out;\n                                }\n                            }\n                            azVals[i] = 0;\n                        }\n                        if (xCallback(pArg, nCol, azVals, azCols)) {\n                            rc = 4;\n                            sqlite3VdbeFinalize((Vdbe *)pStmt);\n                            pStmt = 0;\n                            sqlite3Error(db, 4);\n                            goto exec_out;\n                        }\n                    }\n                    if (rc != 100) {\n                        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);\n                        pStmt = 0;\n                        zSql = zLeftover;\n                        while ((sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1))\n                            zSql++;\n                        break;\n                    }\n                }\n            sqlite3DbFree(db, azCols);\n            azCols = 0;\n        }\n  exec_out:\n    if (pStmt)\n        sqlite3VdbeFinalize((Vdbe *)pStmt);\n    sqlite3DbFree(db, azCols);\n    rc = sqlite3ApiExit(db, rc);\n    if (rc != 0 && pzErrMsg) {\n        *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));\n        if (*pzErrMsg == 0) {\n            rc = 7;\n            sqlite3Error(db, 7);\n        }\n    } else if (pzErrMsg) {\n        *pzErrMsg = 0;\n    }\n    ((void)0);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeExec",
    "gotos": 232,
    "labels": 21,
    "body": "{\n    Op *aOp = p->aOp;\n    Op *pOp = aOp;\n    int rc = 0;\n    sqlite3 *db = p->db;\n    u8 resetSchemaOnFault = 0;\n    u8 encoding = ((db)->enc);\n    int iCompare = 0;\n    u64 nVmStep = 0;\n    u64 nProgressLimit;\n    Mem *aMem = p->aMem;\n    Mem *pIn1 = 0;\n    Mem *pIn2 = 0;\n    Mem *pIn3 = 0;\n    Mem *pOut = 0;\n    ((void)0);\n    if (((p->lockMask) != 0)) {\n        sqlite3VdbeEnter(p);\n    }\n    if (db->xProgress) {\n        u32 iPrior = p->aCounter[4];\n        ((void)0);\n        nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);\n    } else {\n        nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n    }\n    if (p->rc == 7) {\n        goto no_mem;\n    }\n    ((void)0);\n    ;\n    p->rc = 0;\n    ((void)0);\n    p->iCurrentTime = 0;\n    ((void)0);\n    db->busyHandler.nBusy = 0;\n    if (__atomic_load_n((&db->u1.isInterrupted), 0))\n        goto abort_due_to_interrupt;\n    ;\n    for (pOp = &aOp[p->pc]; 1; pOp++) {\n        ((void)0);\n        ((void)0);\n        nVmStep++;\n        switch (pOp->opcode) {\n          case 9:\n            {\n              jump_to_p2_and_check_for_interrupt:\n                pOp = &aOp[pOp->p2 - 1];\n              check_for_interrupt:\n                if (__atomic_load_n((&db->u1.isInterrupted), 0))\n                    goto abort_due_to_interrupt;\n                while (nVmStep >= nProgressLimit && db->xProgress != 0)\n                    {\n                        ((void)0);\n                        nProgressLimit += db->nProgressOps;\n                        if (db->xProgress(db->pProgressArg)) {\n                            nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                            rc = 9;\n                            goto abort_due_to_error;\n                        }\n                    }\n                break;\n            }\n          case 10:\n            {\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                pIn1->flags = 4;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                goto jump_to_p2_and_check_for_interrupt;\n            }\n          case 67:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & 4) {\n                    if (pOp->p3) {\n                        ;\n                    }\n                    pOp = &aOp[pIn1->u.i];\n                } else if ((pOp->p3)) {\n                    ;\n                }\n                break;\n            }\n          case 11:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pOut = &aMem[pOp->p1];\n                ((void)0);\n                pOut->u.i = pOp->p3 - 1;\n                pOut->flags = 4;\n                if (pOp->p2 == 0)\n                    break;\n              jump_to_p2:\n                ((void)0);\n                ((void)0);\n                pOp = &aOp[pOp->p2 - 1];\n                break;\n            }\n          case 68:\n            {\n                VdbeOp *pCaller;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pCaller = &aOp[pIn1->u.i];\n                ((void)0);\n                ((void)0);\n                pOp = &aOp[pCaller->p2 - 1];\n                pIn1->flags = 0;\n                break;\n            }\n          case 12:\n            {\n                int pcDest;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                pIn1->flags = 4;\n                pcDest = (int)pIn1->u.i;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                pOp = &aOp[pcDest];\n                break;\n            }\n          case 69:\n            {\n                pIn3 = &aMem[pOp->p3];\n                if ((pIn3->flags & 1) == 0)\n                    break;\n            }\n          case 70:\n            {\n                VdbeFrame *pFrame;\n                int pcx;\n                ((void)0);\n                if (p->pFrame && pOp->p1 == 0) {\n                    pFrame = p->pFrame;\n                    p->pFrame = pFrame->pParent;\n                    p->nFrame--;\n                    sqlite3VdbeSetChanges(db, p->nChange);\n                    pcx = sqlite3VdbeFrameRestore(pFrame);\n                    if (pOp->p2 == 4) {\n                        pcx = p->aOp[pcx].p2 - 1;\n                    }\n                    aOp = p->aOp;\n                    aMem = p->aMem;\n                    pOp = &aOp[pcx];\n                    break;\n                }\n                p->rc = pOp->p1;\n                p->errorAction = (u8)pOp->p2;\n                ((void)0);\n                if (p->rc) {\n                    if (pOp->p5) {\n                        static const char *const azType[] = {\"NOT NULL\", \"UNIQUE\", \"CHECK\", \"FOREIGN KEY\"};\n                        ;\n                        ;\n                        ;\n                        ;\n                        sqlite3VdbeError(p, \"%s constraint failed\", azType[pOp->p5 - 1]);\n                        if (pOp->p4.z) {\n                            p->zErrMsg = sqlite3MPrintf(db, \"%z: %s\", p->zErrMsg, pOp->p4.z);\n                        }\n                    } else {\n                        sqlite3VdbeError(p, \"%s\", pOp->p4.z);\n                    }\n                    pcx = (int)(pOp - aOp);\n                    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n                }\n                rc = sqlite3VdbeHalt(p);\n                ((void)0);\n                if (rc == 5) {\n                    p->rc = 5;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = p->rc ? 1 : 101;\n                }\n                goto vdbe_return;\n            }\n          case 71:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = pOp->p1;\n                break;\n            }\n          case 72:\n            {\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pOut->u.i = *pOp->p4.pI64;\n                break;\n            }\n          case 153:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 8;\n                ((void)0);\n                pOut->u.r = *pOp->p4.pReal;\n                break;\n            }\n          case 117:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n                if (encoding != 1) {\n                    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));\n                    ((void)0);\n                    if (rc)\n                        goto too_big;\n                    if (0 != sqlite3VdbeChangeEncoding(pOut, encoding))\n                        goto no_mem;\n                    ((void)0);\n                    ((void)0);\n                    pOut->szMalloc = 0;\n                    pOut->flags |= 8192;\n                    if (pOp->p4type == (-6)) {\n                        sqlite3DbFree(db, pOp->p4.z);\n                    }\n                    pOp->p4type = (-6);\n                    pOp->p4.z = pOut->z;\n                    pOp->p1 = pOut->n;\n                }\n                if (pOp->p1 > db->aLimit[0]) {\n                    goto too_big;\n                }\n                pOp->opcode = 73;\n                ((void)0);\n            }\n          case 73:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = pOp->p4.z;\n                pOut->n = pOp->p1;\n                pOut->enc = encoding;\n                ;\n                if (pOp->p3 > 0) {\n                    ((void)0);\n                    pIn3 = &aMem[pOp->p3];\n                    ((void)0);\n                    if (pIn3->u.i == pOp->p5)\n                        pOut->flags = 16 | 8192 | 512;\n                }\n                break;\n            }\n          case 74:\n          case 75:\n            {\n                int cnt;\n                u16 nullFlag;\n                pOut = out2Prerelease(p, pOp);\n                cnt = pOp->p3 - pOp->p2;\n                ((void)0);\n                pOut->flags = nullFlag = pOp->p1 ? (1 | 256) : 1;\n                pOut->n = 0;\n                while (cnt > 0)\n                    {\n                        pOut++;\n                        ;\n                        sqlite3VdbeMemSetNull(pOut);\n                        pOut->flags = nullFlag;\n                        pOut->n = 0;\n                        cnt--;\n                    }\n                break;\n            }\n          case 76:\n            {\n                ((void)0);\n                pOut = &aMem[pOp->p1];\n                pOut->flags = (pOut->flags & ~(0 | 63)) | 1;\n                break;\n            }\n          case 77:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                if (pOp->p4.z == 0) {\n                    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);\n                    if (sqlite3VdbeMemExpandBlob(pOut))\n                        goto no_mem;\n                } else {\n                    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n                }\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 78:\n            {\n                Mem *pVar;\n                ((void)0);\n                ((void)0);\n                pVar = &p->aVar[pOp->p1 - 1];\n                if (sqlite3VdbeMemTooBig(pVar)) {\n                    goto too_big;\n                }\n                pOut = &aMem[pOp->p2];\n                if ((((pOut)->flags & (32768 | 4096)) != 0))\n                    sqlite3VdbeMemSetNull(pOut);\n                __builtin___memcpy_chk(pOut, pVar, __builtin_offsetof(Mem, db), __builtin_object_size(pOut, 0));\n                pOut->flags &= ~(4096 | 16384);\n                pOut->flags |= 8192 | 64;\n                ;\n                break;\n            }\n          case 79:\n            {\n                int n;\n                int p1;\n                int p2;\n                n = pOp->p3;\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[p1];\n                pOut = &aMem[p2];\n                do {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ;\n                    sqlite3VdbeMemMove(pOut, pIn1);\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                    ;\n                    ;\n                    pIn1++;\n                    pOut++;\n                } while (--n);\n                break;\n            }\n          case 80:\n            {\n                int n;\n                n = pOp->p3;\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                ((void)0);\n                while (1)\n                    {\n                        ;\n                        sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                        if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                            goto no_mem;\n                        }\n                        ;\n                        if ((pOut->flags & 2048) != 0 && (pOp->p5 & 2) != 0) {\n                            pOut->flags &= ~2048;\n                        }\n                        ;\n                        if ((n--) == 0)\n                            break;\n                        pOut++;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 81:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                ((void)0);\n                sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                break;\n            }\n          case 82:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);\n                break;\n            }\n          case 83:\n            {\n                if ((rc = sqlite3VdbeCheckFk(p, 0)) != 0) {\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 84:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                p->cacheCtr = (p->cacheCtr + 2) | 1;\n                p->pResultRow = &aMem[pOp->p1];\n                if (db->mallocFailed)\n                    goto no_mem;\n                if (db->mTrace & 4) {\n                    db->trace.xV2(4, db->pTraceArg, p, 0);\n                }\n                p->pc = (int)(pOp - aOp) + 1;\n                rc = 100;\n                goto vdbe_return;\n            }\n          case 111:\n            {\n                i64 nByte;\n                u16 flags1;\n                u16 flags2;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                flags1 = pIn1->flags;\n                ;\n                ;\n                if ((flags1 | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                if ((flags1 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn1, encoding, 0))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                } else if ((flags1 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn1))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                }\n                flags2 = pIn2->flags;\n                if ((flags2 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn2, encoding, 0))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                } else if ((flags2 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn2))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                }\n                nByte = pIn1->n + pIn2->n;\n                if (nByte > db->aLimit[0]) {\n                    goto too_big;\n                }\n                if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {\n                    goto no_mem;\n                }\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 2);\n                if (pOut != pIn2) {\n                    __builtin___memcpy_chk(pOut->z, pIn2->z, pIn2->n, __builtin_object_size(pOut->z, 0));\n                    ((void)0);\n                    pIn2->flags = flags2;\n                }\n                __builtin___memcpy_chk(&pOut->z[pIn2->n], pIn1->z, pIn1->n, __builtin_object_size(&pOut->z[pIn2->n], 0));\n                ((void)0);\n                pIn1->flags = flags1;\n                if (encoding > 1)\n                    nByte &= ~1;\n                pOut->z[nByte] = 0;\n                pOut->z[nByte + 1] = 0;\n                pOut->flags |= 512;\n                pOut->n = (int)nByte;\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n            {\n                u16 type1;\n                u16 type2;\n                i64 iA;\n                i64 iB;\n                double rA;\n                double rB;\n                pIn1 = &aMem[pOp->p1];\n                type1 = pIn1->flags;\n                pIn2 = &aMem[pOp->p2];\n                type2 = pIn2->flags;\n                pOut = &aMem[pOp->p3];\n                if ((type1 & type2 & 4) != 0) {\n                  int_math:\n                    iA = pIn1->u.i;\n                    iB = pIn2->u.i;\n                    switch (pOp->opcode) {\n                      case 106:\n                        if (sqlite3AddInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 107:\n                        if (sqlite3SubInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 108:\n                        if (sqlite3MulInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 109:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1 && iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                                goto fp_math;\n                            iB /= iA;\n                            break;\n                        }\n                      default:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            iB %= iA;\n                            break;\n                        }\n                    }\n                    pOut->u.i = iB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                } else if (((type1 | type2) & 1) != 0) {\n                    goto arithmetic_result_is_null;\n                } else {\n                    type1 = numericType(pIn1);\n                    type2 = numericType(pIn2);\n                    if ((type1 & type2 & 4) != 0)\n                        goto int_math;\n                  fp_math:\n                    rA = sqlite3VdbeRealValue(pIn1);\n                    rB = sqlite3VdbeRealValue(pIn2);\n                    switch (pOp->opcode) {\n                      case 106:\n                        rB += rA;\n                        break;\n                      case 107:\n                        rB -= rA;\n                        break;\n                      case 108:\n                        rB *= rA;\n                        break;\n                      case 109:\n                        {\n                            if (rA == (double)0)\n                                goto arithmetic_result_is_null;\n                            rB /= rA;\n                            break;\n                        }\n                      default:\n                        {\n                            iA = sqlite3VdbeIntValue(pIn1);\n                            iB = sqlite3VdbeIntValue(pIn2);\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            rB = (double)(iB % iA);\n                            break;\n                        }\n                    }\n                    if (sqlite3IsNaN(rB)) {\n                        goto arithmetic_result_is_null;\n                    }\n                    pOut->u.r = rB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 8);\n                }\n                break;\n              arithmetic_result_is_null:\n                sqlite3VdbeMemSetNull(pOut);\n                break;\n            }\n          case 85:\n            {\n                ((void)0);\n                if (pOp->p1) {\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);\n                }\n                break;\n            }\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n            {\n                i64 iA;\n                u64 uA;\n                i64 iB;\n                u8 op;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                if ((pIn1->flags | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                iA = sqlite3VdbeIntValue(pIn2);\n                iB = sqlite3VdbeIntValue(pIn1);\n                op = pOp->opcode;\n                if (op == 102) {\n                    iA &= iB;\n                } else if (op == 103) {\n                    iA |= iB;\n                } else if (iB != 0) {\n                    ((void)0);\n                    if (iB < 0) {\n                        ((void)0);\n                        op = 2 * 104 + 1 - op;\n                        iB = iB > (-64) ? -iB : 64;\n                    }\n                    if (iB >= 64) {\n                        iA = (iA >= 0 || op == 104) ? 0 : -1;\n                    } else {\n                        __builtin___memcpy_chk(&uA, &iA, sizeof (uA), __builtin_object_size(&uA, 0));\n                        if (op == 104) {\n                            uA <<= iB;\n                        } else {\n                            uA >>= iB;\n                            if (iA < 0)\n                                uA |= ((((u64)4294967295U) << 32) | 4294967295U) << (64 - iB);\n                        }\n                        __builtin___memcpy_chk(&iA, &uA, sizeof (iA), __builtin_object_size(&iA, 0));\n                    }\n                }\n                pOut->u.i = iA;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 86:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn1->u.i += pOp->p2;\n                break;\n            }\n          case 13:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if ((pIn1->flags & 4) == 0) {\n                    applyAffinity(pIn1, 67, encoding);\n                    if ((pIn1->flags & 4) == 0) {\n                        ;\n                        if (pOp->p2 == 0) {\n                            rc = 20;\n                            goto abort_due_to_error;\n                        } else {\n                            goto jump_to_p2;\n                        }\n                    }\n                }\n                ;\n                ((pIn1)->flags = ((pIn1)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 87:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & (4 | 32)) {\n                    ;\n                    ;\n                    sqlite3VdbeMemRealify(pIn1);\n                    ;\n                }\n                break;\n            }\n          case 88:\n            {\n                ((void)0);\n                ;\n                ;\n                ;\n                ;\n                ;\n                pIn1 = &aMem[pOp->p1];\n                ;\n                rc = (((pIn1)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                ;\n                ;\n                break;\n            }\n          case 53:\n          case 52:\n          case 56:\n          case 55:\n          case 54:\n          case 57:\n            {\n                int res, res2;\n                char affinity;\n                u16 flags1;\n                u16 flags3;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                flags1 = pIn1->flags;\n                flags3 = pIn3->flags;\n                if ((flags1 & flags3 & 4) != 0) {\n                    if (pIn3->u.i > pIn1->u.i) {\n                        if (sqlite3aGTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = +1;\n                    } else if (pIn3->u.i < pIn1->u.i) {\n                        if (sqlite3aLTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = -1;\n                    } else {\n                        if (sqlite3aEQb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = 0;\n                    }\n                    ;\n                    break;\n                }\n                if ((flags1 | flags3) & 1) {\n                    if (pOp->p5 & 128) {\n                        ((void)0);\n                        ((void)0);\n                        ;\n                        if ((flags1 & flags3 & 1) != 0 && (flags3 & 256) == 0) {\n                            res = 0;\n                        } else {\n                            res = ((flags3 & 1) ? -1 : +1);\n                        }\n                    } else {\n                        ;\n                        if (pOp->p5 & 16) {\n                            goto jump_to_p2;\n                        }\n                        iCompare = 1;\n                        break;\n                    }\n                } else {\n                    affinity = pOp->p5 & 71;\n                    if (affinity >= 67) {\n                        if ((flags1 | flags3) & 2) {\n                            if ((flags1 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn1, 0);\n                                ((void)0);\n                                flags3 = pIn3->flags;\n                            }\n                            if ((flags3 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn3, 0);\n                            }\n                        }\n                    } else if (affinity == 66 && ((flags1 | flags3) & 2) != 0) {\n                        if ((flags1 & 2) == 0 && (flags1 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn1, encoding, 1);\n                            ;\n                            flags1 = (pIn1->flags & ~3519) | (flags1 & 3519);\n                            if ((pIn1 == pIn3))\n                                flags3 = flags1 | 2;\n                        }\n                        if ((flags3 & 2) == 0 && (flags3 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn3, encoding, 1);\n                            ;\n                            flags3 = (pIn3->flags & ~3519) | (flags3 & 3519);\n                        }\n                    }\n                    ((void)0);\n                    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (res < 0) {\n                    res2 = sqlite3aLTb[pOp->opcode];\n                } else if (res == 0) {\n                    res2 = sqlite3aEQb[pOp->opcode];\n                } else {\n                    res2 = sqlite3aGTb[pOp->opcode];\n                }\n                iCompare = res;\n                ((void)0);\n                pIn3->flags = flags3;\n                ((void)0);\n                pIn1->flags = flags1;\n                ;\n                if (res2) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 58:\n            {\n                ((void)0);\n                ;\n                if (iCompare == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 89:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                break;\n            }\n          case 90:\n            {\n                int n;\n                int i;\n                int p1;\n                int p2;\n                const KeyInfo *pKeyInfo;\n                u32 idx;\n                CollSeq *pColl;\n                int bRev;\n                u32 *aPermute;\n                if ((pOp->p5 & 1) == 0) {\n                    aPermute = 0;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    aPermute = pOp[-1].p4.ai + 1;\n                    ((void)0);\n                }\n                n = pOp->p3;\n                pKeyInfo = pOp->p4.pKeyInfo;\n                ((void)0);\n                ((void)0);\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                for (i = 0; i < n; i++) {\n                    idx = aPermute ? aPermute[i] : (u32)i;\n                    ((void)0);\n                    ((void)0);\n                    ;\n                    ;\n                    ((void)0);\n                    pColl = pKeyInfo->aColl[i];\n                    bRev = (pKeyInfo->aSortFlags[i] & 1);\n                    iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);\n                    if (iCompare) {\n                        if ((pKeyInfo->aSortFlags[i] & 2) && ((aMem[p1 + idx].flags & 1) || (aMem[p2 + idx].flags & 1))) {\n                            iCompare = -iCompare;\n                        }\n                        if (bRev)\n                            iCompare = -iCompare;\n                        break;\n                    }\n                }\n                ((void)0);\n                break;\n            }\n          case 14:\n            {\n                ((void)0);\n                ((void)0);\n                if (iCompare < 0) {\n                    ;\n                    pOp = &aOp[pOp->p1 - 1];\n                } else if (iCompare == 0) {\n                    ;\n                    pOp = &aOp[pOp->p2 - 1];\n                } else {\n                    ;\n                    pOp = &aOp[pOp->p3 - 1];\n                }\n                break;\n            }\n          case 44:\n          case 43:\n            {\n                int v1;\n                int v2;\n                v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);\n                v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);\n                if (pOp->opcode == 44) {\n                    static const unsigned char and_logic[] = {0, 0, 0, 0, 1, 2, 0, 2, 2};\n                    v1 = and_logic[v1 * 3 + v2];\n                } else {\n                    static const unsigned char or_logic[] = {0, 1, 2, 1, 1, 1, 2, 1, 2};\n                    v1 = or_logic[v1 * 3 + v2];\n                }\n                pOut = &aMem[pOp->p3];\n                if (v1 == 2) {\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                } else {\n                    pOut->u.i = v1;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                }\n                break;\n            }\n          case 91:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                sqlite3VdbeMemSetInt64(&aMem[pOp->p2], sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);\n                break;\n            }\n          case 19:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                if ((pIn1->flags & 1) == 0) {\n                    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1, 0));\n                } else {\n                    sqlite3VdbeMemSetNull(pOut);\n                }\n                break;\n            }\n          case 114:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetNull(pOut);\n                if ((pIn1->flags & 1) == 0) {\n                    pOut->flags = 4;\n                    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);\n                }\n                break;\n            }\n          case 15:\n            {\n                u32 iAddr;\n                ((void)0);\n                if (p->pFrame) {\n                    iAddr = (int)(pOp - p->aOp);\n                    if ((p->pFrame->aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    p->pFrame->aOnce[iAddr / 8] |= 1 << (iAddr & 7);\n                } else {\n                    if (p->aOp[0].p1 == pOp->p1) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                }\n                ;\n                pOp->p1 = p->aOp[0].p1;\n                break;\n            }\n          case 16:\n            {\n                int c;\n                c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 17:\n            {\n                int c;\n                c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 50:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) != 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 18:\n            {\n                VdbeCursor *pC;\n                u16 typeMask;\n                u32 serialType;\n                ((void)0);\n                ((void)0);\n                if (pOp->p1 >= 0) {\n                    pC = p->apCsr[pOp->p1];\n                    ((void)0);\n                    ((void)0);\n                    if (pOp->p3 < pC->nHdrParsed) {\n                        serialType = pC->aType[pOp->p3];\n                        if (serialType >= 12) {\n                            if (serialType & 1) {\n                                typeMask = 4;\n                            } else {\n                                typeMask = 8;\n                            }\n                        } else {\n                            static const unsigned char aMask[] = {16, 1, 1, 1, 1, 1, 1, 2, 1, 1, 16, 16};\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            typeMask = aMask[serialType];\n                        }\n                    } else {\n                        typeMask = 1 << (pOp->p4.i - 1);\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                    }\n                } else {\n                    ((void)0);\n                    typeMask = 1 << (sqlite3_value_type((sqlite3_value *)&aMem[pOp->p3]) - 1);\n                    ;\n                    ;\n                    ;\n                    ;\n                    ;\n                }\n                ;\n                if (typeMask & pOp->p5) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 92:\n            {\n                if ((aMem[pOp->p1].flags & 1) != 0 || (aMem[pOp->p3].flags & 1) != 0) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n                } else {\n                    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n                }\n                break;\n            }\n          case 51:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 20:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if ((pC) && pC->nullRow) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p3);\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 94:\n            {\n                u32 p2;\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 *aOffset;\n                int len;\n                int i;\n                Mem *pDest;\n                Mem sMem;\n                const u8 *zData;\n                const u8 *zHdr;\n                const u8 *zEndHdr;\n                u64 offset64;\n                u32 t;\n                Mem *pReg;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                p2 = (u32)pOp->p2;\n              op_column_restart:\n                ((void)0);\n                ((void)0);\n                aOffset = pC->aOffset;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pC->cacheStatus != p->cacheCtr) {\n                    if (pC->nullRow) {\n                        if (pC->eCurType == 3 && pC->seekResult > 0) {\n                            pReg = &aMem[pC->seekResult];\n                            ((void)0);\n                            ((void)0);\n                            pC->payloadSize = pC->szRow = pReg->n;\n                            pC->aRow = (u8 *)pReg->z;\n                        } else {\n                            pDest = &aMem[pOp->p3];\n                            ;\n                            sqlite3VdbeMemSetNull(pDest);\n                            goto op_column_out;\n                        }\n                    } else {\n                        pCrsr = pC->uc.pCursor;\n                        if (pC->deferredMoveto) {\n                            u32 iMap;\n                            ((void)0);\n                            if (pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1 + p2]) > 0) {\n                                pC = pC->pAltCursor;\n                                p2 = iMap - 1;\n                                goto op_column_restart;\n                            }\n                            rc = sqlite3VdbeFinishMoveto(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                        } else if (sqlite3BtreeCursorHasMoved(pCrsr)) {\n                            rc = sqlite3VdbeHandleMovedCursor(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                            goto op_column_restart;\n                        }\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);\n                        pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);\n                        ((void)0);\n                        ((void)0);\n                    }\n                    pC->cacheStatus = p->cacheCtr;\n                    if ((aOffset[0] = pC->aRow[0]) < 128) {\n                        pC->iHdrOffset = 1;\n                    } else {\n                        pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);\n                    }\n                    pC->nHdrParsed = 0;\n                    if (pC->szRow < aOffset[0]) {\n                        pC->aRow = 0;\n                        pC->szRow = 0;\n                        if (aOffset[0] > 98307 || aOffset[0] > pC->payloadSize) {\n                            goto op_column_corrupt;\n                        }\n                    } else {\n                        zData = pC->aRow;\n                        ((void)0);\n                        ;\n                        goto op_column_read_header;\n                    }\n                } else if (sqlite3BtreeCursorHasMoved(pC->uc.pCursor)) {\n                    rc = sqlite3VdbeHandleMovedCursor(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    goto op_column_restart;\n                }\n                if (pC->nHdrParsed <= p2) {\n                    if (pC->iHdrOffset < aOffset[0]) {\n                        if (pC->aRow == 0) {\n                            __builtin___memset_chk(&sMem, 0, sizeof (sMem), __builtin_object_size(&sMem, 0));\n                            rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor, aOffset[0], &sMem);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                            zData = (u8 *)sMem.z;\n                        } else {\n                            zData = pC->aRow;\n                        }\n                      op_column_read_header:\n                        i = pC->nHdrParsed;\n                        offset64 = aOffset[i];\n                        zHdr = zData + pC->iHdrOffset;\n                        zEndHdr = zData + aOffset[0];\n                        ;\n                        do {\n                            if ((pC->aType[i] = t = zHdr[0]) < 128) {\n                                zHdr++;\n                                offset64 += sqlite3VdbeOneByteSerialTypeLen(t);\n                            } else {\n                                zHdr += sqlite3GetVarint32(zHdr, &t);\n                                pC->aType[i] = t;\n                                offset64 += sqlite3VdbeSerialTypeLen(t);\n                            }\n                            aOffset[++i] = (u32)(offset64 & 4294967295U);\n                        } while ((u32)i <= p2 && zHdr < zEndHdr);\n                        if ((zHdr >= zEndHdr && (zHdr > zEndHdr || offset64 != pC->payloadSize)) || (offset64 > pC->payloadSize)) {\n                            if (aOffset[0] == 0) {\n                                i = 0;\n                                zHdr = zEndHdr;\n                            } else {\n                                if (pC->aRow == 0)\n                                    sqlite3VdbeMemRelease(&sMem);\n                                goto op_column_corrupt;\n                            }\n                        }\n                        pC->nHdrParsed = i;\n                        pC->iHdrOffset = (u32)(zHdr - zData);\n                        if (pC->aRow == 0)\n                            sqlite3VdbeMemRelease(&sMem);\n                    } else {\n                        t = 0;\n                    }\n                    if (pC->nHdrParsed <= p2) {\n                        pDest = &aMem[pOp->p3];\n                        ;\n                        if (pOp->p4type == (-10)) {\n                            sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 8192);\n                        } else {\n                            sqlite3VdbeMemSetNull(pDest);\n                        }\n                        goto op_column_out;\n                    }\n                } else {\n                    t = pC->aType[p2];\n                }\n                ((void)0);\n                ((void)0);\n                pDest = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                if ((((pDest)->flags & (32768 | 4096)) != 0)) {\n                    sqlite3VdbeMemSetNull(pDest);\n                }\n                ((void)0);\n                if (pC->szRow >= aOffset[p2 + 1]) {\n                    zData = pC->aRow + aOffset[p2];\n                    if (t < 12) {\n                        sqlite3VdbeSerialGet(zData, t, pDest);\n                    } else {\n                        static const u16 aFlag[] = {16, 2 | 512};\n                        pDest->n = len = (t - 12) / 2;\n                        pDest->enc = encoding;\n                        if (pDest->szMalloc < len + 2) {\n                            if (len > db->aLimit[0])\n                                goto too_big;\n                            pDest->flags = 1;\n                            if (sqlite3VdbeMemGrow(pDest, len + 2, 0))\n                                goto no_mem;\n                        } else {\n                            pDest->z = pDest->zMalloc;\n                        }\n                        __builtin___memcpy_chk(pDest->z, zData, len, __builtin_object_size(pDest->z, 0));\n                        pDest->z[len] = 0;\n                        pDest->z[len + 1] = 0;\n                        pDest->flags = aFlag[t & 1];\n                    }\n                } else {\n                    pDest->enc = encoding;\n                    if (((pOp->p5 & (64 | 128)) != 0 && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & 128) != 0)) || (len = sqlite3VdbeSerialTypeLen(t)) == 0) {\n                        sqlite3VdbeSerialGet((u8 *)sqlite3CtypeMap, t, pDest);\n                    } else {\n                        if (len > db->aLimit[0])\n                            goto too_big;\n                        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        sqlite3VdbeSerialGet((const u8 *)pDest->z, t, pDest);\n                        pDest->flags &= ~16384;\n                    }\n                }\n              op_column_out:\n                ;\n                ;\n                break;\n              op_column_corrupt:\n                if (aOp[0].p3 > 0) {\n                    pOp = &aOp[aOp[0].p3 - 1];\n                    break;\n                } else {\n                    rc = sqlite3CorruptError(93251);\n                    goto abort_due_to_error;\n                }\n            }\n          case 95:\n            {\n                Table *pTab;\n                Column *aCol;\n                int i;\n                ((void)0);\n                pTab = pOp->p4.pTab;\n                ((void)0);\n                ((void)0);\n                aCol = pTab->aCol;\n                pIn1 = &aMem[pOp->p1];\n                for (i = 0; i < pTab->nCol; i++) {\n                    if (aCol[i].colFlags & 96) {\n                        if (aCol[i].colFlags & 32)\n                            continue;\n                        if (pOp->p3) {\n                            pIn1++;\n                            continue;\n                        }\n                    }\n                    ((void)0);\n                    applyAffinity(pIn1, aCol[i].affinity, encoding);\n                    if ((pIn1->flags & 1) == 0) {\n                        switch (aCol[i].eCType) {\n                          case 2:\n                            {\n                                if ((pIn1->flags & 16) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 4:\n                          case 3:\n                            {\n                                if ((pIn1->flags & 4) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 6:\n                            {\n                                if ((pIn1->flags & 2) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 5:\n                            {\n                                ;\n                                ((void)0);\n                                if (pIn1->flags & 4) {\n                                    ;\n                                    ;\n                                    ;\n                                    ;\n                                    if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                        pIn1->flags |= 32;\n                                        pIn1->flags &= ~4;\n                                    } else {\n                                        pIn1->u.r = (double)pIn1->u.i;\n                                        pIn1->flags |= 8;\n                                        pIn1->flags &= ~4;\n                                    }\n                                } else if ((pIn1->flags & (8 | 32)) == 0) {\n                                    goto vdbe_type_error;\n                                }\n                                break;\n                            }\n                          default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    ;\n                    pIn1++;\n                }\n                ((void)0);\n                break;\n              vdbe_type_error:\n                sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab->zName, aCol[i].zCnName);\n                rc = (19 | (12 << 8));\n                goto abort_due_to_error;\n            }\n          case 96:\n            {\n                const char *zAffinity;\n                zAffinity = pOp->p4.z;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                while (1)\n                    {\n                        ((void)0);\n                        ((void)0);\n                        applyAffinity(pIn1, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pIn1->flags & 4) != 0) {\n                            ;\n                            ;\n                            ;\n                            ;\n                            if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                pIn1->flags |= 32;\n                                pIn1->flags &= ~4;\n                            } else {\n                                pIn1->u.r = (double)pIn1->u.i;\n                                pIn1->flags |= 8;\n                                pIn1->flags &= ~4;\n                            }\n                        }\n                        ;\n                        zAffinity++;\n                        if (zAffinity[0] == 0)\n                            break;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 97:\n            {\n                Mem *pRec;\n                u64 nData;\n                int nHdr;\n                i64 nByte;\n                i64 nZero;\n                int nVarint;\n                u32 serial_type;\n                Mem *pData0;\n                Mem *pLast;\n                int nField;\n                char *zAffinity;\n                u32 len;\n                u8 *zHdr;\n                u8 *zPayload;\n                nData = 0;\n                nHdr = 0;\n                nZero = 0;\n                nField = pOp->p1;\n                zAffinity = pOp->p4.z;\n                ((void)0);\n                pData0 = &aMem[nField];\n                nField = pOp->p2;\n                pLast = &pData0[nField - 1];\n                ((void)0);\n                pOut = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                if (zAffinity) {\n                    pRec = pData0;\n                    do {\n                        applyAffinity(pRec, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pRec->flags & 4)) {\n                            pRec->flags |= 32;\n                            pRec->flags &= ~(4);\n                        }\n                        ;\n                        zAffinity++;\n                        pRec++;\n                        ((void)0);\n                    } while (zAffinity[0]);\n                }\n                pRec = pLast;\n                do {\n                    ((void)0);\n                    if (pRec->flags & 1) {\n                        if (pRec->flags & 1024) {\n                            ((void)0);\n                            pRec->uTemp = 10;\n                        } else {\n                            pRec->uTemp = 0;\n                        }\n                        nHdr++;\n                    } else if (pRec->flags & (4 | 32)) {\n                        i64 i = pRec->u.i;\n                        u64 uu;\n                        ;\n                        ;\n                        if (i < 0) {\n                            uu = ~i;\n                        } else {\n                            uu = i;\n                        }\n                        nHdr++;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        if (uu <= 127) {\n                            if ((i & 1) == i && p->minWriteFileFormat >= 4) {\n                                pRec->uTemp = 8 + (u32)uu;\n                            } else {\n                                nData++;\n                                pRec->uTemp = 1;\n                            }\n                        } else if (uu <= 32767) {\n                            nData += 2;\n                            pRec->uTemp = 2;\n                        } else if (uu <= 8388607) {\n                            nData += 3;\n                            pRec->uTemp = 3;\n                        } else if (uu <= 2147483647) {\n                            nData += 4;\n                            pRec->uTemp = 4;\n                        } else if (uu <= 140737488355327LL) {\n                            nData += 6;\n                            pRec->uTemp = 5;\n                        } else {\n                            nData += 8;\n                            if (pRec->flags & 32) {\n                                pRec->u.r = (double)pRec->u.i;\n                                pRec->flags &= ~32;\n                                pRec->flags |= 8;\n                                pRec->uTemp = 7;\n                            } else {\n                                pRec->uTemp = 6;\n                            }\n                        }\n                    } else if (pRec->flags & 8) {\n                        nHdr++;\n                        nData += 8;\n                        pRec->uTemp = 7;\n                    } else {\n                        ((void)0);\n                        ((void)0);\n                        len = (u32)pRec->n;\n                        serial_type = (len * 2) + 12 + ((pRec->flags & 2) != 0);\n                        if (pRec->flags & 1024) {\n                            serial_type += pRec->u.nZero * 2;\n                            if (nData) {\n                                if (sqlite3VdbeMemExpandBlob(pRec))\n                                    goto no_mem;\n                                len += pRec->u.nZero;\n                            } else {\n                                nZero += pRec->u.nZero;\n                            }\n                        }\n                        nData += len;\n                        nHdr += sqlite3VarintLen(serial_type);\n                        pRec->uTemp = serial_type;\n                    }\n                    if (pRec == pData0)\n                        break;\n                    pRec--;\n                } while (1);\n                ;\n                ;\n                if (nHdr <= 126) {\n                    nHdr += 1;\n                } else {\n                    nVarint = sqlite3VarintLen(nHdr);\n                    nHdr += nVarint;\n                    if (nVarint < sqlite3VarintLen(nHdr))\n                        nHdr++;\n                }\n                nByte = nHdr + nData;\n                if (nByte + nZero <= pOut->szMalloc) {\n                    pOut->z = pOut->zMalloc;\n                } else {\n                    if (nByte + nZero > db->aLimit[0]) {\n                        goto too_big;\n                    }\n                    if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {\n                        goto no_mem;\n                    }\n                }\n                pOut->n = (int)nByte;\n                pOut->flags = 16;\n                if (nZero) {\n                    pOut->u.nZero = nZero;\n                    pOut->flags |= 1024;\n                }\n                ;\n                zHdr = (u8 *)pOut->z;\n                zPayload = zHdr + nHdr;\n                if (nHdr < 128) {\n                    *(zHdr++) = nHdr;\n                } else {\n                    zHdr += sqlite3PutVarint(zHdr, nHdr);\n                }\n                ((void)0);\n                pRec = pData0;\n                while (1)\n                    {\n                        serial_type = pRec->uTemp;\n                        if (serial_type <= 7) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type == 0) {\n                            } else {\n                                u64 v;\n                                u32 i;\n                                if (serial_type == 7) {\n                                    ((void)0);\n                                    __builtin___memcpy_chk(&v, &pRec->u.r, sizeof (v), __builtin_object_size(&v, 0));\n                                    ;\n                                } else {\n                                    v = pRec->u.i;\n                                }\n                                len = i = sqlite3SmallTypeSizes[serial_type];\n                                ((void)0);\n                                while (1)\n                                    {\n                                        zPayload[--i] = (u8)(v & 255);\n                                        if (i == 0)\n                                            break;\n                                        v >>= 8;\n                                    }\n                                zPayload += len;\n                            }\n                        } else if (serial_type < 128) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type >= 14 && pRec->n > 0) {\n                                ((void)0);\n                                __builtin___memcpy_chk(zPayload, pRec->z, pRec->n, __builtin_object_size(zPayload, 0));\n                                zPayload += pRec->n;\n                            }\n                        } else {\n                            zHdr += sqlite3PutVarint(zHdr, serial_type);\n                            if (pRec->n) {\n                                ((void)0);\n                                __builtin___memcpy_chk(zPayload, pRec->z, pRec->n, __builtin_object_size(zPayload, 0));\n                                zPayload += pRec->n;\n                            }\n                        }\n                        if (pRec == pLast)\n                            break;\n                        pRec++;\n                    }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                break;\n            }\n          case 98:\n            {\n                i64 nEntry;\n                BtCursor *pCrsr;\n                ((void)0);\n                pCrsr = p->apCsr[pOp->p1]->uc.pCursor;\n                ((void)0);\n                if (pOp->p3) {\n                    nEntry = sqlite3BtreeRowCountEst(pCrsr);\n                } else {\n                    nEntry = 0;\n                    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = nEntry;\n                goto check_for_interrupt;\n            }\n          case 0:\n            {\n                int p1;\n                char *zName;\n                int nName;\n                Savepoint *pNew;\n                Savepoint *pSavepoint;\n                Savepoint *pTmp;\n                int iSavepoint;\n                int ii;\n                p1 = pOp->p1;\n                zName = pOp->p4.z;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (p1 == 0) {\n                    if (db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot open savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        nName = sqlite3Strlen30(zName);\n                        ((void)0);\n                        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);\n                        if (pNew) {\n                            pNew->zName = (char *)&pNew[1];\n                            __builtin___memcpy_chk(pNew->zName, zName, nName + 1, __builtin_object_size(pNew->zName, 0));\n                            if (db->autoCommit) {\n                                db->autoCommit = 0;\n                                db->isTransactionSavepoint = 1;\n                            } else {\n                                db->nSavepoint++;\n                            }\n                            pNew->pNext = db->pSavepoint;\n                            db->pSavepoint = pNew;\n                            pNew->nDeferredCons = db->nDeferredCons;\n                            pNew->nDeferredImmCons = db->nDeferredImmCons;\n                        }\n                    }\n                } else {\n                    ((void)0);\n                    iSavepoint = 0;\n                    for (pSavepoint = db->pSavepoint; pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName); pSavepoint = pSavepoint->pNext) {\n                        iSavepoint++;\n                    }\n                    if (!pSavepoint) {\n                        sqlite3VdbeError(p, \"no such savepoint: %s\", zName);\n                        rc = 1;\n                    } else if (db->nVdbeWrite > 0 && p1 == 1) {\n                        sqlite3VdbeError(p, \"cannot release savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;\n                        if (isTransaction && p1 == 1) {\n                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                                goto vdbe_return;\n                            }\n                            db->autoCommit = 1;\n                            if (sqlite3VdbeHalt(p) == 5) {\n                                p->pc = (int)(pOp - aOp);\n                                db->autoCommit = 0;\n                                p->rc = rc = 5;\n                                goto vdbe_return;\n                            }\n                            rc = p->rc;\n                            if (rc) {\n                                db->autoCommit = 0;\n                            } else {\n                                db->isTransactionSavepoint = 0;\n                            }\n                        } else {\n                            int isSchemaChange;\n                            iSavepoint = db->nSavepoint - iSavepoint - 1;\n                            if (p1 == 2) {\n                                isSchemaChange = (db->mDbFlags & 1) != 0;\n                                for (ii = 0; ii < db->nDb; ii++) {\n                                    rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, (4 | (2 << 8)), isSchemaChange == 0);\n                                    if (rc != 0)\n                                        goto abort_due_to_error;\n                                }\n                            } else {\n                                ((void)0);\n                                isSchemaChange = 0;\n                            }\n                            for (ii = 0; ii < db->nDb; ii++) {\n                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);\n                                if (rc != 0) {\n                                    goto abort_due_to_error;\n                                }\n                            }\n                            if (isSchemaChange) {\n                                sqlite3ExpirePreparedStatements(db, 0);\n                                sqlite3ResetAllSchemasOfConnection(db);\n                                db->mDbFlags |= 1;\n                            }\n                        }\n                        if (rc)\n                            goto abort_due_to_error;\n                        while (db->pSavepoint != pSavepoint)\n                            {\n                                pTmp = db->pSavepoint;\n                                db->pSavepoint = pTmp->pNext;\n                                sqlite3DbFree(db, pTmp);\n                                db->nSavepoint--;\n                            }\n                        if (p1 == 1) {\n                            ((void)0);\n                            db->pSavepoint = pSavepoint->pNext;\n                            sqlite3DbFree(db, pSavepoint);\n                            if (!isTransaction) {\n                                db->nSavepoint--;\n                            }\n                        } else {\n                            ((void)0);\n                            db->nDeferredCons = pSavepoint->nDeferredCons;\n                            db->nDeferredImmCons = pSavepoint->nDeferredImmCons;\n                        }\n                        if (!isTransaction || p1 == 2) {\n                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                if (p->eVdbeState == 3) {\n                    rc = 101;\n                    goto vdbe_return;\n                }\n                break;\n            }\n          case 1:\n            {\n                int desiredAutoCommit;\n                int iRollback;\n                desiredAutoCommit = pOp->p1;\n                iRollback = pOp->p2;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (desiredAutoCommit != db->autoCommit) {\n                    if (iRollback) {\n                        ((void)0);\n                        sqlite3RollbackAll(db, (4 | (2 << 8)));\n                        db->autoCommit = 1;\n                    } else if (desiredAutoCommit && db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot commit transaction - SQL statements in progress\");\n                        rc = 5;\n                        goto abort_due_to_error;\n                    } else if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                        goto vdbe_return;\n                    } else {\n                        db->autoCommit = (u8)desiredAutoCommit;\n                    }\n                    if (sqlite3VdbeHalt(p) == 5) {\n                        p->pc = (int)(pOp - aOp);\n                        db->autoCommit = (u8)(1 - desiredAutoCommit);\n                        p->rc = rc = 5;\n                        goto vdbe_return;\n                    }\n                    sqlite3CloseSavepoints(db);\n                    if (p->rc == 0) {\n                        rc = 101;\n                    } else {\n                        rc = 1;\n                    }\n                    goto vdbe_return;\n                } else {\n                    sqlite3VdbeError(p, (!desiredAutoCommit) ? \"cannot start a transaction within a transaction\" : ((iRollback) ? \"cannot rollback - no transaction is active\" : \"cannot commit - no transaction is active\"));\n                    rc = 1;\n                    goto abort_due_to_error;\n                }\n                ((void)0);\n            }\n          case 2:\n            {\n                Btree *pBt;\n                Db *pDb;\n                int iMeta = 0;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pOp->p2 && (db->flags & (1048576 | ((u64)(2) << 32))) != 0) {\n                    if (db->flags & 1048576) {\n                        rc = 8;\n                    } else {\n                        rc = 11;\n                    }\n                    goto abort_due_to_error;\n                }\n                pDb = &db->aDb[pOp->p1];\n                pBt = pDb->pBt;\n                if (pBt) {\n                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);\n                    ;\n                    ;\n                    if (rc != 0) {\n                        if ((rc & 255) == 5) {\n                            p->pc = (int)(pOp - aOp);\n                            p->rc = rc;\n                            goto vdbe_return;\n                        }\n                        goto abort_due_to_error;\n                    }\n                    if (p->usesStmtJournal && pOp->p2 && (db->autoCommit == 0 || db->nVdbeRead > 1)) {\n                        ((void)0);\n                        if (p->iStatement == 0) {\n                            ((void)0);\n                            db->nStatement++;\n                            p->iStatement = db->nSavepoint + db->nStatement;\n                        }\n                        rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);\n                        }\n                        p->nStmtDefCons = db->nDeferredCons;\n                        p->nStmtDefImmCons = db->nDeferredImmCons;\n                    }\n                }\n                ((void)0);\n                if (rc == 0 && pOp->p5 && (iMeta != pOp->p3 || pDb->pSchema->iGeneration != pOp->p4.i)) {\n                    sqlite3DbFree(db, p->zErrMsg);\n                    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {\n                        sqlite3ResetOneSchema(db, pOp->p1);\n                    }\n                    p->expired = 1;\n                    rc = 17;\n                    p->changeCntOn = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 99:\n            {\n                int iMeta;\n                int iDb;\n                int iCookie;\n                ((void)0);\n                iDb = pOp->p1;\n                iCookie = pOp->p3;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = iMeta;\n                break;\n            }\n          case 100:\n            {\n                Db *pDb;\n                ;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[pOp->p1];\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);\n                if (pOp->p2 == 1) {\n                    *(u32 *)&pDb->pSchema->schema_cookie = *(u32 *)&pOp->p3 - pOp->p5;\n                    db->mDbFlags |= 1;\n                    sqlite3FkClearTriggerCache(db, pOp->p1);\n                } else if (pOp->p2 == 2) {\n                    pDb->pSchema->file_format = pOp->p3;\n                }\n                if (pOp->p1 == 1) {\n                    sqlite3ExpirePreparedStatements(db, 0);\n                    p->expired = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 101:\n            {\n                int nField;\n                KeyInfo *pKeyInfo;\n                u32 p2;\n                int iDb;\n                int wrFlag;\n                Btree *pX;\n                VdbeCursor *pCur;\n                Db *pDb;\n                ((void)0);\n                ((void)0);\n                pCur = p->apCsr[pOp->p1];\n                if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {\n                    ((void)0);\n                    ((void)0);\n                    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n                    goto open_cursor_set_hints;\n                }\n              case 112:\n              case 113:\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (p->expired == 1) {\n                    rc = (4 | (2 << 8));\n                    goto abort_due_to_error;\n                }\n                nField = 0;\n                pKeyInfo = 0;\n                p2 = (u32)pOp->p2;\n                iDb = pOp->p3;\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[iDb];\n                pX = pDb->pBt;\n                ((void)0);\n                if (pOp->opcode == 113) {\n                    ((void)0);\n                    wrFlag = 4 | (pOp->p5 & 8);\n                    ((void)0);\n                    if (pDb->pSchema->file_format < p->minWriteFileFormat) {\n                        p->minWriteFileFormat = pDb->pSchema->file_format;\n                    }\n                } else {\n                    wrFlag = 0;\n                }\n                if (pOp->p5 & 16) {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    pIn2 = &aMem[p2];\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeMemIntegerify(pIn2);\n                    p2 = (int)pIn2->u.i;\n                    ((void)0);\n                }\n                if (pOp->p4type == (-8)) {\n                    pKeyInfo = pOp->p4.pKeyInfo;\n                    ((void)0);\n                    ((void)0);\n                    nField = pKeyInfo->nAllField;\n                } else if (pOp->p4type == (-3)) {\n                    nField = pOp->p4.i;\n                }\n                ((void)0);\n                ((void)0);\n                ;\n                pCur = allocateCursor(p, pOp->p1, nField, 0);\n                if (pCur == 0)\n                    goto no_mem;\n                pCur->iDb = iDb;\n                pCur->nullRow = 1;\n                pCur->isOrdered = 1;\n                pCur->pgnoRoot = p2;\n                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);\n                pCur->pKeyInfo = pKeyInfo;\n                pCur->isTable = pOp->p4type != (-8);\n              open_cursor_set_hints:\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (pOp->p5 & (1 | 2)));\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 115:\n            {\n                VdbeCursor *pOrig;\n                VdbeCursor *pCx;\n                pOrig = p->apCsr[pOp->p2];\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->isEphemeral = 1;\n                pCx->pKeyInfo = pOrig->pKeyInfo;\n                pCx->isTable = pOrig->isTable;\n                pCx->pgnoRoot = pOrig->pgnoRoot;\n                pCx->isOrdered = pOrig->isOrdered;\n                pCx->ub.pBtx = pOrig->ub.pBtx;\n                pCx->noReuse = 1;\n                pOrig->noReuse = 1;\n                rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);\n                ((void)0);\n                break;\n            }\n          case 116:\n          case 118:\n            {\n                VdbeCursor *pCx;\n                KeyInfo *pKeyInfo;\n                static const int vfsFlags = 2 | 4 | 16 | 8 | 1024;\n                ((void)0);\n                ((void)0);\n                if (pOp->p3 > 0) {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    aMem[pOp->p3].n = 0;\n                    aMem[pOp->p3].z = \"\";\n                }\n                pCx = p->apCsr[pOp->p1];\n                if (pCx && !pCx->noReuse && (pOp->p2 <= pCx->nField)) {\n                    ((void)0);\n                    pCx->seqCount = 0;\n                    pCx->cacheStatus = 0;\n                    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);\n                } else {\n                    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);\n                    if (pCx == 0)\n                        goto no_mem;\n                    pCx->isEphemeral = 1;\n                    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx, 1 | 4 | pOp->p5, vfsFlags);\n                    if (rc == 0) {\n                        rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);\n                        if (rc == 0) {\n                            if ((pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != 0) {\n                                ((void)0);\n                                rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot, 2 | pOp->p5);\n                                if (rc == 0) {\n                                    ((void)0);\n                                    ((void)0);\n                                    ((void)0);\n                                    rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pKeyInfo, pCx->uc.pCursor);\n                                }\n                                pCx->isTable = 0;\n                            } else {\n                                pCx->pgnoRoot = 1;\n                                rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 4, 0, pCx->uc.pCursor);\n                                pCx->isTable = 1;\n                            }\n                        }\n                        pCx->isOrdered = (pOp->p5 != 8);\n                        if (rc) {\n                            sqlite3BtreeClose(pCx->ub.pBtx);\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pCx->nullRow = 1;\n                break;\n            }\n          case 119:\n            {\n                VdbeCursor *pCx;\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->pKeyInfo = pOp->p4.pKeyInfo;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 120:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if ((pC->seqCount++) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 121:\n            {\n                VdbeCursor *pCx;\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->seekResult = pOp->p2;\n                pCx->isTable = 1;\n                pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                ((void)0);\n                break;\n            }\n          case 122:\n            {\n                ((void)0);\n                sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n                p->apCsr[pOp->p1] = 0;\n                break;\n            }\n          case 21:\n          case 22:\n          case 23:\n          case 24:\n            {\n                int res;\n                int oc;\n                VdbeCursor *pC;\n                UnpackedRecord r;\n                int nField;\n                i64 iKey;\n                int eqOnly;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                oc = pOp->opcode;\n                eqOnly = 0;\n                pC->nullRow = 0;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pC->isTable) {\n                    u16 flags3, newType;\n                    ((void)0);\n                    pIn3 = &aMem[pOp->p3];\n                    flags3 = pIn3->flags;\n                    if ((flags3 & (4 | 8 | 32 | 2)) == 2) {\n                        applyNumericAffinity(pIn3, 0);\n                    }\n                    iKey = sqlite3VdbeIntValue(pIn3);\n                    newType = pIn3->flags;\n                    pIn3->flags = flags3;\n                    if ((newType & (4 | 32)) == 0) {\n                        int c;\n                        if ((newType & 8) == 0) {\n                            if ((newType & 1) || oc >= 23) {\n                                ;\n                                goto jump_to_p2;\n                            } else {\n                                rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                                if (rc != 0)\n                                    goto abort_due_to_error;\n                                goto seek_not_found;\n                            }\n                        }\n                        c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n                        if (c > 0) {\n                            ((void)0);\n                            ((void)0);\n                            ((void)0);\n                            if ((oc & 1) == (24 & 1))\n                                oc--;\n                        } else if (c < 0) {\n                            ((void)0);\n                            ((void)0);\n                            ((void)0);\n                            if ((oc & 1) == (21 & 1))\n                                oc++;\n                        }\n                    }\n                    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n                    pC->movetoTarget = iKey;\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                } else {\n                    if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2)) {\n                        eqOnly = 1;\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                    }\n                    nField = pOp->p4.i;\n                    ((void)0);\n                    ((void)0);\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.nField = (u16)nField;\n                    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    r.aMem = &aMem[pOp->p3];\n                    r.eqSeen = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (eqOnly && r.eqSeen == 0) {\n                        ((void)0);\n                        goto seek_not_found;\n                    }\n                }\n                if (oc >= 23) {\n                    ((void)0);\n                    if (res < 0 || (res == 0 && oc == 24)) {\n                        res = 0;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = 0;\n                    }\n                } else {\n                    ((void)0);\n                    if (res > 0 || (res == 0 && oc == 21)) {\n                        res = 0;\n                        rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = sqlite3BtreeEof(pC->uc.pCursor);\n                    }\n                }\n              seek_not_found:\n                ((void)0);\n                ;\n                if (res) {\n                    goto jump_to_p2;\n                } else if (eqOnly) {\n                    ((void)0);\n                    pOp++;\n                }\n                break;\n            }\n          case 124:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nStep;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp[1].p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (!sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)) {\n                    break;\n                }\n                nStep = pOp->p1;\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp[1].p4.i;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp[1].p3];\n                res = 0;\n                while (1)\n                    {\n                        rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res > 0 && pOp->p5 == 0) {\n                          seekscan_search_fail:\n                            ;\n                            pOp++;\n                            goto jump_to_p2;\n                        }\n                        if (res >= 0) {\n                            ;\n                            goto jump_to_p2;\n                            break;\n                        }\n                        if (nStep <= 0) {\n                            ;\n                            break;\n                        }\n                        nStep--;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc) {\n                            if (rc == 101) {\n                                rc = 0;\n                                goto seekscan_search_fail;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    }\n                break;\n            }\n          case 125:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pC->seekHit < pOp->p2) {\n                    pC->seekHit = pOp->p2;\n                } else if (pC->seekHit > pOp->p3) {\n                    pC->seekHit = pOp->p3;\n                }\n                break;\n            }\n          case 25:\n            {\n                VdbeCursor *pCur;\n                ((void)0);\n                pCur = p->apCsr[pOp->p1];\n                ;\n                if (pCur == 0 || pCur->nullRow) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                break;\n            }\n          case 26:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if (pC->seekHit >= pOp->p4.i)\n                    break;\n            }\n          case 27:\n          case 28:\n          case 29:\n            {\n                int alreadyExists;\n                int ii;\n                VdbeCursor *pC;\n                UnpackedRecord *pIdxKey;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                r.aMem = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                r.nField = (u16)pOp->p4.i;\n                if (r.nField > 0) {\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = (((r.aMem)->flags & 1024) ? sqlite3VdbeMemExpandBlob(r.aMem) : 0);\n                    ((void)0);\n                    if (rc)\n                        goto no_mem;\n                    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);\n                    if (pIdxKey == 0)\n                        goto no_mem;\n                    sqlite3VdbeRecordUnpack(pC->pKeyInfo, r.aMem->n, r.aMem->z, pIdxKey);\n                    pIdxKey->default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);\n                    sqlite3DbFreeNN(db, pIdxKey);\n                }\n                if (rc != 0) {\n                    goto abort_due_to_error;\n                }\n                alreadyExists = (pC->seekResult == 0);\n                pC->nullRow = 1 - alreadyExists;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pOp->opcode == 29) {\n                    ;\n                    if (alreadyExists)\n                        goto jump_to_p2;\n                } else {\n                    if (!alreadyExists) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    if (pOp->opcode == 27) {\n                        for (ii = 0; ii < r.nField; ii++) {\n                            if (r.aMem[ii].flags & 1) {\n                                ;\n                                goto jump_to_p2;\n                            }\n                        }\n                    }\n                    ;\n                    if (pOp->opcode == 26) {\n                        pC->seekHit = pOp->p4.i;\n                    }\n                }\n                break;\n            }\n          case 30:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                u64 iKey;\n                pIn3 = &aMem[pOp->p3];\n                ;\n                ;\n                ;\n                ;\n                if ((pIn3->flags & (4 | 32)) == 0) {\n                    Mem x = pIn3[0];\n                    applyAffinity(&x, 67, encoding);\n                    if ((x.flags & 4) == 0)\n                        goto jump_to_p2;\n                    iKey = x.u.i;\n                    goto notExistsWithKey;\n                }\n              case 31:\n                pIn3 = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                iKey = pIn3->u.i;\n              notExistsWithKey:\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                res = 0;\n                rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n                ((void)0);\n                pC->movetoTarget = iKey;\n                pC->nullRow = 0;\n                pC->cacheStatus = 0;\n                pC->deferredMoveto = 0;\n                ;\n                pC->seekResult = res;\n                if (res != 0) {\n                    ((void)0);\n                    if (pOp->p2 == 0) {\n                        rc = sqlite3CorruptError(95494);\n                    } else {\n                        goto jump_to_p2;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 126:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n                break;\n            }\n          case 127:\n            {\n                i64 v;\n                VdbeCursor *pC;\n                int res;\n                int cnt;\n                Mem *pMem;\n                VdbeFrame *pFrame;\n                v = 0;\n                res = 0;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                {\n                    ((void)0);\n                    if (!pC->useRandomRowid) {\n                        rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                        if (rc != 0) {\n                            goto abort_due_to_error;\n                        }\n                        if (res) {\n                            v = 1;\n                        } else {\n                            ((void)0);\n                            v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                            if (v >= (i64)((((u64)2147483647) << 32) | (u64)4294967295U)) {\n                                pC->useRandomRowid = 1;\n                            } else {\n                                v++;\n                            }\n                        }\n                    }\n                    if (pOp->p3) {\n                        ((void)0);\n                        if (p->pFrame) {\n                            for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                                ;\n                            ((void)0);\n                            pMem = &pFrame->aMem[pOp->p3];\n                        } else {\n                            ((void)0);\n                            pMem = &aMem[pOp->p3];\n                            ;\n                        }\n                        ((void)0);\n                        ;\n                        sqlite3VdbeMemIntegerify(pMem);\n                        ((void)0);\n                        if (pMem->u.i == (i64)((((u64)2147483647) << 32) | (u64)4294967295U) || pC->useRandomRowid) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        if (v < pMem->u.i + 1) {\n                            v = pMem->u.i + 1;\n                        }\n                        pMem->u.i = v;\n                    }\n                    if (pC->useRandomRowid) {\n                        ((void)0);\n                        cnt = 0;\n                        do {\n                            sqlite3_randomness(sizeof (v), &v);\n                            v &= ((i64)((((u64)2147483647) << 32) | (u64)4294967295U) >> 1);\n                            v++;\n                        } while (((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v, 0, &res)) == 0) && (res == 0) && (++cnt < 100));\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res == 0) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        ((void)0);\n                    }\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 128:\n            {\n                Mem *pData;\n                Mem *pKey;\n                VdbeCursor *pC;\n                int seekResult;\n                const char *zDb;\n                Table *pTab;\n                BtreePayload x;\n                pData = &aMem[pOp->p2];\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                pKey = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                ;\n                x.nKey = pKey->u.i;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    ((void)0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    ((void)0);\n                } else {\n                    pTab = 0;\n                    zDb = 0;\n                }\n                ((void)0);\n                if (pOp->p5 & 1) {\n                    p->nChange++;\n                    if (pOp->p5 & 32)\n                        db->lastRowid = x.nKey;\n                }\n                ((void)0);\n                x.pData = pData->z;\n                x.nData = pData->n;\n                seekResult = ((pOp->p5 & 16) ? pC->seekResult : 0);\n                if (pData->flags & 1024) {\n                    x.nZero = pData->u.nZero;\n                } else {\n                    x.nZero = 0;\n                }\n                x.pKey = 0;\n                ((void)0);\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), seekResult);\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pTab) {\n                    ((void)0);\n                    ((void)0);\n                    db->xUpdateCallback(db->pUpdateArg, (pOp->p5 & 4) ? 23 : 18, zDb, pTab->zName, x.nKey);\n                }\n                break;\n            }\n          case 129:\n            {\n                VdbeCursor *pDest;\n                VdbeCursor *pSrc;\n                i64 iKey;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDest = p->apCsr[pOp->p1];\n                pSrc = p->apCsr[pOp->p2];\n                iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n                rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 130:\n            {\n                VdbeCursor *pC;\n                const char *zDb;\n                Table *pTab;\n                int opflags;\n                opflags = pOp->p2;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    ((void)0);\n                    ((void)0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    if ((pOp->p5 & 2) != 0 && pC->isTable) {\n                        pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                    }\n                } else {\n                    zDb = 0;\n                    pTab = 0;\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (opflags & 1) {\n                    p->nChange++;\n                    if (db->xUpdateCallback && (pTab != 0) && (((pTab)->tabFlags & 128) == 0)) {\n                        db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName, pC->movetoTarget);\n                        ((void)0);\n                    }\n                }\n                break;\n            }\n          case 131:\n            {\n                sqlite3VdbeSetChanges(db, p->nChange);\n                p->nChange = 0;\n                break;\n            }\n          case 132:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nKeyCol;\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pIn3 = &aMem[pOp->p3];\n                nKeyCol = pOp->p4.i;\n                res = 0;\n                rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n            ;\n          case 133:\n            {\n                VdbeCursor *pC;\n                pOut = &aMem[pOp->p2];\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                rc = sqlite3VdbeSorterRowkey(pC, pOut);\n                ((void)0);\n                ((void)0);\n                if (rc)\n                    goto abort_due_to_error;\n                p->apCsr[pOp->p3]->cacheStatus = 0;\n                break;\n            }\n          case 134:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 n;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                ((void)0);\n                n = sqlite3BtreePayloadSize(pCrsr);\n                if (n > (u32)db->aLimit[0]) {\n                    goto too_big;\n                }\n                ;\n                rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);\n                if (rc)\n                    goto abort_due_to_error;\n                if (!pOp->p3)\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                ;\n                ;\n                ;\n                break;\n            }\n          case 135:\n            {\n                VdbeCursor *pC;\n                i64 v;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pC->nullRow) {\n                    pOut->flags = 1;\n                    break;\n                } else if (pC->deferredMoveto) {\n                    v = pC->movetoTarget;\n                } else if (pC->eCurType == 2) {\n                    ((void)0);\n                    pVtab = pC->uc.pVCur->pVtab;\n                    pModule = pVtab->pModule;\n                    ((void)0);\n                    rc = pModule->xRowid(pC->uc.pVCur, &v);\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3VdbeCursorRestore(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (pC->nullRow) {\n                        pOut->flags = 1;\n                        break;\n                    }\n                    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 136:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if (pC == 0) {\n                    pC = allocateCursor(p, pOp->p1, 1, 3);\n                    if (pC == 0)\n                        goto no_mem;\n                    pC->seekResult = 0;\n                    pC->isTable = 1;\n                    pC->noReuse = 1;\n                    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                }\n                pC->nullRow = 1;\n                pC->cacheStatus = 0;\n                if (pC->eCurType == 0) {\n                    ((void)0);\n                    sqlite3BtreeClearCursor(pC->uc.pCursor);\n                }\n                break;\n            }\n          case 137:\n          case 32:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                res = 0;\n                ((void)0);\n                if (pOp->opcode == 137) {\n                    ((void)0);\n                    pC->seekResult = -1;\n                    if (sqlite3BtreeCursorIsValidNN(pCrsr)) {\n                        break;\n                    }\n                }\n                rc = sqlite3BtreeLast(pCrsr, &res);\n                pC->nullRow = (u8)res;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 33:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                i64 sz;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                rc = sqlite3BtreeFirst(pCrsr, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    sz = sqlite3BtreeRowCountEst(pCrsr);\n                    if ((sz >= 0) && sqlite3LogEst((u64)sz) < pOp->p3)\n                        res = 1;\n                }\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 34:\n          case 35:\n            {\n                p->aCounter[2]++;\n            }\n          case 36:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                res = 1;\n                if (((pC)->eCurType == 1)) {\n                    rc = sqlite3VdbeSorterRewind(pC, &res);\n                } else {\n                    ((void)0);\n                    pCrsr = pC->uc.pCursor;\n                    ((void)0);\n                    rc = sqlite3BtreeFirst(pCrsr, &res);\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pC->nullRow = (u8)res;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 37:\n            {\n                VdbeCursor *pC;\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                rc = sqlite3VdbeSorterNext(db, pC);\n                goto next_tail;\n              case 38:\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);\n                goto next_tail;\n              case 39:\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);\n              next_tail:\n                pC->cacheStatus = 0;\n                ;\n                if (rc == 0) {\n                    pC->nullRow = 0;\n                    p->aCounter[pOp->p5]++;\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                if (rc != 101)\n                    goto abort_due_to_error;\n                rc = 0;\n                pC->nullRow = 1;\n                goto check_for_interrupt;\n            }\n          case 138:\n            {\n                VdbeCursor *pC;\n                BtreePayload x;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ;\n                ((void)0);\n                ((void)0);\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                ((void)0);\n                ((void)0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                x.nKey = pIn2->n;\n                x.pKey = pIn2->z;\n                x.aMem = aMem + pOp->p3;\n                x.nMem = (u16)pOp->p4.i;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), ((pOp->p5 & 16) ? pC->seekResult : 0));\n                ((void)0);\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 139:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ;\n                ((void)0);\n                ((void)0);\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                ((void)0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeSorterWrite(pC, pIn2);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 140:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ;\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p3;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp->p2];\n                rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    rc = sqlite3BtreeDelete(pCrsr, 4);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else if (pOp->p5 && !sqlite3WritableSchema(db)) {\n                    rc = sqlite3ReportError((11 | (3 << 8)), 96569, \"index corruption\");\n                    goto abort_due_to_error;\n                }\n                ((void)0);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                break;\n            }\n          case 141:\n          case 142:\n            {\n                VdbeCursor *pC;\n                VdbeCursor *pTabCur;\n                i64 rowid;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeCursorRestore(pC);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                if (!pC->nullRow) {\n                    rowid = 0;\n                    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (pOp->opcode == 141) {\n                        ((void)0);\n                        pTabCur = p->apCsr[pOp->p3];\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        pTabCur->nullRow = 0;\n                        pTabCur->movetoTarget = rowid;\n                        pTabCur->deferredMoveto = 1;\n                        pTabCur->cacheStatus = 0;\n                        ((void)0);\n                        ((void)0);\n                        pTabCur->ub.aAltMap = pOp->p4.ai;\n                        ((void)0);\n                        pTabCur->pAltCursor = pC;\n                    } else {\n                        pOut = out2Prerelease(p, pOp);\n                        pOut->u.i = rowid;\n                    }\n                } else {\n                    ((void)0);\n                    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);\n                }\n                break;\n            }\n          case 143:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if (pC->deferredMoveto) {\n                    rc = sqlite3VdbeFinishMoveto(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 40:\n          case 41:\n          case 42:\n          case 45:\n            {\n                VdbeCursor *pC;\n                int res;\n                UnpackedRecord r;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p4.i;\n                if (pOp->opcode < 42) {\n                    ((void)0);\n                    r.default_rc = -1;\n                } else {\n                    ((void)0);\n                    r.default_rc = 0;\n                }\n                r.aMem = &aMem[pOp->p3];\n                {\n                    i64 nCellKey = 0;\n                    BtCursor *pCur;\n                    Mem m;\n                    ((void)0);\n                    pCur = pC->uc.pCursor;\n                    ((void)0);\n                    nCellKey = sqlite3BtreePayloadSize(pCur);\n                    if (nCellKey <= 0 || nCellKey > 2147483647) {\n                        rc = sqlite3CorruptError(96774);\n                        goto abort_due_to_error;\n                    }\n                    sqlite3VdbeMemInit(&m, db, 0);\n                    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n                    if (rc)\n                        goto abort_due_to_error;\n                    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n                    sqlite3VdbeMemReleaseMalloc(&m);\n                }\n                ((void)0);\n                if ((pOp->opcode & 1) == (42 & 1)) {\n                    ((void)0);\n                    res = -res;\n                } else {\n                    ((void)0);\n                    res++;\n                }\n                ;\n                ((void)0);\n                if (res > 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 144:\n            {\n                int iMoved;\n                int iDb;\n                ;\n                ((void)0);\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                if (db->nVdbeRead > db->nVDestroy + 1) {\n                    rc = 6;\n                    p->errorAction = 2;\n                    goto abort_due_to_error;\n                } else {\n                    iDb = pOp->p3;\n                    ((void)0);\n                    iMoved = 0;\n                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);\n                    pOut->flags = 4;\n                    pOut->u.i = iMoved;\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (iMoved != 0) {\n                        sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);\n                        ((void)0);\n                        resetSchemaOnFault = iDb + 1;\n                    }\n                }\n                break;\n            }\n          case 145:\n            {\n                i64 nChange;\n                ;\n                nChange = 0;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n                if (pOp->p3) {\n                    p->nChange += nChange;\n                    if (pOp->p3 > 0) {\n                        ((void)0);\n                        ;\n                        aMem[pOp->p3].u.i += nChange;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 146:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if (((pC)->eCurType == 1)) {\n                    sqlite3VdbeSorterReset(db, pC->uc.pSorter);\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 147:\n            {\n                Pgno pgno;\n                Db *pDb;\n                ;\n                pOut = out2Prerelease(p, pOp);\n                pgno = 0;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[pOp->p1];\n                ((void)0);\n                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);\n                if (rc)\n                    goto abort_due_to_error;\n                pOut->u.i = pgno;\n                break;\n            }\n          case 148:\n            {\n                ;\n                db->nSqlExec++;\n                rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n                db->nSqlExec--;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 149:\n            {\n                int iDb;\n                const char *zSchema;\n                char *zSql;\n                InitData initData;\n                iDb = pOp->p1;\n                ((void)0);\n                ((void)0);\n                if (pOp->p4.z == 0) {\n                    sqlite3SchemaClear(db->aDb[iDb].pSchema);\n                    db->mDbFlags &= ~16;\n                    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n                    db->mDbFlags |= 1;\n                    p->expired = 0;\n                } else {\n                    zSchema = \"sqlite_master\";\n                    initData.db = db;\n                    initData.iDb = iDb;\n                    initData.pzErrMsg = &p->zErrMsg;\n                    initData.mInitFlags = 0;\n                    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n                    zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n                    if (zSql == 0) {\n                        rc = 7;\n                    } else {\n                        ((void)0);\n                        db->init.busy = 1;\n                        initData.rc = 0;\n                        initData.nInitRow = 0;\n                        ((void)0);\n                        rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n                        if (rc == 0)\n                            rc = initData.rc;\n                        if (rc == 0 && initData.nInitRow == 0) {\n                            rc = sqlite3CorruptError(97026);\n                        }\n                        sqlite3DbFreeNN(db, zSql);\n                        db->init.busy = 0;\n                    }\n                }\n                if (rc) {\n                    sqlite3ResetAllSchemasOfConnection(db);\n                    if (rc == 7) {\n                        goto no_mem;\n                    }\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 150:\n            {\n                ((void)0);\n                rc = sqlite3AnalysisLoad(db, pOp->p1);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 151:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 152:\n            {\n                ;\n                sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 154:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 155:\n            {\n                int nRoot;\n                Pgno *aRoot;\n                int nErr;\n                char *z;\n                Mem *pnErr;\n                ((void)0);\n                nRoot = pOp->p2;\n                aRoot = pOp->p4.ai;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pnErr = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot, (int)pnErr->u.i + 1, &nErr, &z);\n                sqlite3VdbeMemSetNull(pIn1);\n                if (nErr == 0) {\n                    ((void)0);\n                } else if (rc) {\n                    sqlite3_free(z);\n                    goto abort_due_to_error;\n                } else {\n                    pnErr->u.i -= nErr - 1;\n                    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);\n                }\n                ;\n                sqlite3VdbeChangeEncoding(pIn1, encoding);\n                goto check_for_interrupt;\n            }\n          case 156:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                ((void)0);\n                sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);\n                break;\n            }\n          case 46:\n            {\n                i64 val;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                if ((pIn1->flags & 16) == 0 || sqlite3RowSetNext((RowSet *)pIn1->z, &val) == 0) {\n                    sqlite3VdbeMemSetNull(pIn1);\n                    ;\n                    goto jump_to_p2_and_check_for_interrupt;\n                } else {\n                    ;\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);\n                }\n                goto check_for_interrupt;\n            }\n          case 47:\n            {\n                int iSet;\n                int exists;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                iSet = pOp->p4.i;\n                ((void)0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (iSet) {\n                    exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);\n                    ;\n                    if (exists)\n                        goto jump_to_p2;\n                }\n                if (iSet >= 0) {\n                    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);\n                }\n                break;\n            }\n          case 48:\n            {\n                int nMem;\n                int nByte;\n                Mem *pRt;\n                Mem *pMem;\n                Mem *pEnd;\n                VdbeFrame *pFrame;\n                SubProgram *pProgram;\n                void *t;\n                pProgram = pOp->p4.pProgram;\n                pRt = &aMem[pOp->p3];\n                ((void)0);\n                if (pOp->p5) {\n                    t = pProgram->token;\n                    for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent)\n                        ;\n                    if (pFrame)\n                        break;\n                }\n                if (p->nFrame >= db->aLimit[10]) {\n                    rc = 1;\n                    sqlite3VdbeError(p, \"too many levels of trigger recursion\");\n                    goto abort_due_to_error;\n                }\n                if ((pRt->flags & 16) == 0) {\n                    nMem = pProgram->nMem + pProgram->nCsr;\n                    ((void)0);\n                    if (pProgram->nCsr == 0)\n                        nMem++;\n                    nByte = (((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(Mem) + pProgram->nCsr * sizeof(VdbeCursor *) + (pProgram->nOp + 7) / 8;\n                    pFrame = sqlite3DbMallocZero(db, nByte);\n                    if (!pFrame) {\n                        goto no_mem;\n                    }\n                    sqlite3VdbeMemRelease(pRt);\n                    pRt->flags = 16 | 4096;\n                    pRt->z = (char *)pFrame;\n                    pRt->n = nByte;\n                    pRt->xDel = sqlite3VdbeFrameMemDel;\n                    pFrame->v = p;\n                    pFrame->nChildMem = nMem;\n                    pFrame->nChildCsr = pProgram->nCsr;\n                    pFrame->pc = (int)(pOp - aOp);\n                    pFrame->aMem = p->aMem;\n                    pFrame->nMem = p->nMem;\n                    pFrame->apCsr = p->apCsr;\n                    pFrame->nCursor = p->nCursor;\n                    pFrame->aOp = p->aOp;\n                    pFrame->nOp = p->nOp;\n                    pFrame->token = pProgram->token;\n                    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)])[pFrame->nChildMem];\n                    for (pMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]); pMem != pEnd; pMem++) {\n                        pMem->flags = 0;\n                        pMem->db = db;\n                    }\n                } else {\n                    pFrame = (VdbeFrame *)pRt->z;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                }\n                p->nFrame++;\n                pFrame->pParent = p->pFrame;\n                pFrame->lastRowid = db->lastRowid;\n                pFrame->nChange = p->nChange;\n                pFrame->nDbChange = p->db->nChange;\n                ((void)0);\n                pFrame->pAuxData = p->pAuxData;\n                p->pAuxData = 0;\n                p->nChange = 0;\n                p->pFrame = pFrame;\n                p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]);\n                p->nMem = pFrame->nChildMem;\n                p->nCursor = (u16)pFrame->nChildCsr;\n                p->apCsr = (VdbeCursor **)&aMem[p->nMem];\n                pFrame->aOnce = (u8 *)&p->apCsr[pProgram->nCsr];\n                __builtin___memset_chk(pFrame->aOnce, 0, (pProgram->nOp + 7) / 8, __builtin_object_size(pFrame->aOnce, 0));\n                p->aOp = aOp = pProgram->aOp;\n                p->nOp = pProgram->nOp;\n                pOp = &aOp[-1];\n                goto check_for_interrupt;\n            }\n          case 157:\n            {\n                VdbeFrame *pFrame;\n                Mem *pIn;\n                pOut = out2Prerelease(p, pOp);\n                pFrame = p->pFrame;\n                pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];\n                sqlite3VdbeMemShallowCopy(pOut, pIn, 16384);\n                break;\n            }\n          case 158:\n            {\n                if (db->flags & 524288) {\n                    db->nDeferredImmCons += pOp->p2;\n                } else if (pOp->p1) {\n                    db->nDeferredCons += pOp->p2;\n                } else {\n                    p->nFkConstraint += pOp->p2;\n                }\n                break;\n            }\n          case 49:\n            {\n                if (pOp->p1) {\n                    ;\n                    if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                } else {\n                    ;\n                    if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 159:\n            {\n                VdbeFrame *pFrame;\n                if (p->pFrame) {\n                    for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                        ;\n                    pIn1 = &pFrame->aMem[pOp->p1];\n                } else {\n                    pIn1 = &aMem[pOp->p1];\n                }\n                ((void)0);\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn2 = &aMem[pOp->p2];\n                sqlite3VdbeMemIntegerify(pIn2);\n                if (pIn1->u.i < pIn2->u.i) {\n                    pIn1->u.i = pIn2->u.i;\n                }\n                break;\n            }\n          case 59:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                if (pIn1->u.i > 0) {\n                    pIn1->u.i -= pOp->p3;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 160:\n            {\n                i64 x;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                ((void)0);\n                x = pIn1->u.i;\n                if (x <= 0 || sqlite3AddInt64(&x, pIn3->u.i > 0 ? pIn3->u.i : 0)) {\n                    pOut->u.i = -1;\n                } else {\n                    pOut->u.i = x;\n                }\n                break;\n            }\n          case 60:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                if (pIn1->u.i) {\n                    if (pIn1->u.i > 0)\n                        pIn1->u.i--;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 61:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                if (pIn1->u.i > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                    pIn1->u.i--;\n                ;\n                if (pIn1->u.i == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 161:\n          case 162:\n            {\n                int n;\n                sqlite3_context *pCtx;\n                ((void)0);\n                n = pOp->p5;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCtx = sqlite3DbMallocRawNN(db, n * sizeof(sqlite3_value *) + (sizeof (pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value *)));\n                if (pCtx == 0)\n                    goto no_mem;\n                pCtx->pMem = 0;\n                pCtx->pOut = (Mem *)&(pCtx->argv[n]);\n                sqlite3VdbeMemInit(pCtx->pOut, db, 1);\n                pCtx->pFunc = pOp->p4.pFunc;\n                pCtx->iOp = (int)(pOp - aOp);\n                pCtx->pVdbe = p;\n                pCtx->skipFlag = 0;\n                pCtx->isError = 0;\n                pCtx->enc = encoding;\n                pCtx->argc = n;\n                pOp->p4type = (-15);\n                pOp->p4.pCtx = pCtx;\n                ((void)0);\n                pOp->opcode = 163;\n            }\n          case 163:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                Mem *pMem;\n                ((void)0);\n                pCtx = pOp->p4.pCtx;\n                pMem = &aMem[pOp->p3];\n                if (pCtx->pMem != pMem) {\n                    pCtx->pMem = pMem;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                pMem->n++;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pOp->p1) {\n                    (pCtx->pFunc->xInverse)(pCtx, pCtx->argc, pCtx->argv);\n                } else\n                    (pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pCtx->pOut));\n                        rc = pCtx->isError;\n                    }\n                    if (pCtx->skipFlag) {\n                        ((void)0);\n                        i = pOp[-1].p1;\n                        if (i)\n                            sqlite3VdbeMemSetInt64(&aMem[i], 1);\n                        pCtx->skipFlag = 0;\n                    }\n                    sqlite3VdbeMemRelease(pCtx->pOut);\n                    pCtx->pOut->flags = 1;\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                ((void)0);\n                ((void)0);\n                break;\n            }\n          case 164:\n          case 165:\n            {\n                Mem *pMem;\n                ((void)0);\n                ((void)0);\n                pMem = &aMem[pOp->p1];\n                ((void)0);\n                if (pOp->p3) {\n                    ;\n                    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);\n                    pMem = &aMem[pOp->p3];\n                } else {\n                    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);\n                }\n                if (rc) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pMem));\n                    goto abort_due_to_error;\n                }\n                sqlite3VdbeChangeEncoding(pMem, encoding);\n                ;\n                break;\n            }\n          case 3:\n            {\n                int i;\n                int aRes[3];\n                Mem *pMem;\n                ((void)0);\n                aRes[0] = 0;\n                aRes[1] = aRes[2] = -1;\n                ((void)0);\n                rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);\n                if (rc) {\n                    if (rc != 5)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    aRes[0] = 1;\n                }\n                for (i = 0 , pMem = &aMem[pOp->p3]; i < 3; i++ , pMem++) {\n                    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);\n                }\n                break;\n            }\n            ;\n          case 4:\n            {\n                Btree *pBt;\n                Pager *pPager;\n                int eNew;\n                int eOld;\n                const char *zFilename;\n                pOut = out2Prerelease(p, pOp);\n                eNew = pOp->p3;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pBt = db->aDb[pOp->p1].pBt;\n                pPager = sqlite3BtreePager(pBt);\n                eOld = sqlite3PagerGetJournalMode(pPager);\n                if (eNew == (-1))\n                    eNew = eOld;\n                ((void)0);\n                if (!sqlite3PagerOkToChangeJournalMode(pPager))\n                    eNew = eOld;\n                zFilename = sqlite3PagerFilename(pPager, 1);\n                if (eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !sqlite3PagerWalSupported(pPager))) {\n                    eNew = eOld;\n                }\n                if ((eNew != eOld) && (eOld == 5 || eNew == 5)) {\n                    if (!db->autoCommit || db->nVdbeRead > 1) {\n                        rc = 1;\n                        sqlite3VdbeError(p, \"cannot change %s wal mode from within a transaction\", (eNew == 5 ? \"into\" : \"out of\"));\n                        goto abort_due_to_error;\n                    } else {\n                        if (eOld == 5) {\n                            rc = sqlite3PagerCloseWal(pPager, db);\n                            if (rc == 0) {\n                                sqlite3PagerSetJournalMode(pPager, eNew);\n                            }\n                        } else if (eOld == 4) {\n                            sqlite3PagerSetJournalMode(pPager, 2);\n                        }\n                        ((void)0);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeSetVersion(pBt, (eNew == 5 ? 2 : 1));\n                        }\n                    }\n                }\n                if (rc)\n                    eNew = eOld;\n                eNew = sqlite3PagerSetJournalMode(pPager, eNew);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = (char *)sqlite3JournalModename(eNew);\n                pOut->n = sqlite3Strlen30(pOut->z);\n                pOut->enc = 1;\n                sqlite3VdbeChangeEncoding(pOut, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 5:\n            {\n                ((void)0);\n                rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p2 ? &aMem[pOp->p2] : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 62:\n            {\n                Btree *pBt;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pBt = db->aDb[pOp->p1].pBt;\n                rc = sqlite3BtreeIncrVacuum(pBt);\n                ;\n                if (rc) {\n                    if (rc != 101)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 166:\n            {\n                ((void)0);\n                if (!pOp->p1) {\n                    sqlite3ExpirePreparedStatements(db, pOp->p2);\n                } else {\n                    p->expired = pOp->p2 + 1;\n                }\n                break;\n            }\n          case 167:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeCursorPin(pC->uc.pCursor);\n                break;\n            }\n          case 168:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeCursorUnpin(pC->uc.pCursor);\n                break;\n            }\n          case 169:\n            {\n                u8 isWriteLock = (u8)pOp->p3;\n                if (isWriteLock || 0 == (db->flags & 1024)) {\n                    int p1 = pOp->p1;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n                    if (rc) {\n                        if ((rc & 255) == 6) {\n                            const char *z = pOp->p4.z;\n                            sqlite3VdbeError(p, \"database table is locked: %s\", z);\n                        }\n                        goto abort_due_to_error;\n                    }\n                }\n                break;\n            }\n          case 170:\n            {\n                VTable *pVTab;\n                pVTab = pOp->p4.pVtab;\n                rc = sqlite3VtabBegin(db, pVTab);\n                if (pVTab)\n                    sqlite3VtabImportErrmsg(p, pVTab->pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 171:\n            {\n                Mem sMem;\n                const char *zTab;\n                __builtin___memset_chk(&sMem, 0, sizeof (sMem), __builtin_object_size(&sMem, 0));\n                sMem.db = db;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);\n                ((void)0);\n                zTab = (const char *)sqlite3_value_text(&sMem);\n                ((void)0);\n                if (zTab) {\n                    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);\n                }\n                sqlite3VdbeMemRelease(&sMem);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 172:\n            {\n                db->nVDestroy++;\n                rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n                db->nVDestroy--;\n                ((void)0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 173:\n            {\n                VdbeCursor *pCur;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                ((void)0);\n                pCur = 0;\n                pVCur = 0;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                rc = pModule->xOpen(pVtab, &pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                pVCur->pVtab = pVtab;\n                pCur = allocateCursor(p, pOp->p1, 0, 2);\n                if (pCur) {\n                    pCur->uc.pVCur = pVCur;\n                    pVtab->nRef++;\n                } else {\n                    ((void)0);\n                    pModule->xClose(pVCur);\n                    goto no_mem;\n                }\n                break;\n            }\n          case 174:\n            {\n                VdbeCursor *pC;\n                ValueList *pRhs;\n                pC = p->apCsr[pOp->p1];\n                pRhs = sqlite3_malloc64(sizeof (*pRhs));\n                if (pRhs == 0)\n                    goto no_mem;\n                pRhs->pCsr = pC->uc.pCursor;\n                pRhs->pOut = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n                break;\n            }\n          case 6:\n            {\n                int nArg;\n                int iQuery;\n                const sqlite3_module *pModule;\n                Mem *pQuery;\n                Mem *pArgc;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                VdbeCursor *pCur;\n                int res;\n                int i;\n                Mem **apArg;\n                pQuery = &aMem[pOp->p3];\n                pArgc = &pQuery[1];\n                pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ;\n                ((void)0);\n                ((void)0);\n                pVCur = pCur->uc.pVCur;\n                pVtab = pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                nArg = (int)pArgc->u.i;\n                iQuery = (int)pQuery->u.i;\n                apArg = p->apArg;\n                for (i = 0; i < nArg; i++) {\n                    apArg[i] = &pArgc[i + 1];\n                }\n                rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pVCur);\n                pCur->nullRow = 0;\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 175:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                Mem *pDest;\n                sqlite3_context sContext;\n                VdbeCursor *pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pDest = &aMem[pOp->p3];\n                ;\n                if (pCur->nullRow) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    break;\n                }\n                ((void)0);\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                __builtin___memset_chk(&sContext, 0, sizeof (sContext), __builtin_object_size(&sContext, 0));\n                sContext.pOut = pDest;\n                sContext.enc = encoding;\n                ((void)0);\n                if (pOp->p5 & 1) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    pDest->flags = 1 | 1024;\n                    pDest->u.nZero = 0;\n                } else {\n                    ((pDest)->flags = ((pDest)->flags & ~(3519 | 1024)) | 1);\n                }\n                rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (sContext.isError > 0) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pDest));\n                    rc = sContext.isError;\n                }\n                sqlite3VdbeChangeEncoding(pDest, encoding);\n                ;\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 63:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int res;\n                VdbeCursor *pCur;\n                pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pCur->nullRow) {\n                    break;\n                }\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                rc = pModule->xNext(pCur->uc.pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pCur->uc.pVCur);\n                ;\n                if (!res) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                goto check_for_interrupt;\n            }\n          case 176:\n            {\n                sqlite3_vtab *pVtab;\n                Mem *pName;\n                int isLegacy;\n                isLegacy = (db->flags & 67108864);\n                db->flags |= 67108864;\n                pVtab = pOp->p4.pVtab->pVtab;\n                pName = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                ((void)0);\n                ;\n                ;\n                ;\n                rc = sqlite3VdbeChangeEncoding(pName, 1);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = pVtab->pModule->xRename(pVtab, pName->z);\n                if (isLegacy == 0)\n                    db->flags &= ~(u64)67108864;\n                sqlite3VtabImportErrmsg(p, pVtab);\n                p->expired = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 7:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int nArg;\n                int i;\n                sqlite_int64 rowid = 0;\n                Mem **apArg;\n                Mem *pX;\n                ((void)0);\n                ((void)0);\n                if (db->mallocFailed)\n                    goto no_mem;\n                ;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                nArg = pOp->p2;\n                ((void)0);\n                if ((pModule->xUpdate)) {\n                    u8 vtabOnConflict = db->vtabOnConflict;\n                    apArg = p->apArg;\n                    pX = &aMem[pOp->p3];\n                    for (i = 0; i < nArg; i++) {\n                        ((void)0);\n                        ;\n                        apArg[i] = pX;\n                        pX++;\n                    }\n                    db->vtabOnConflict = pOp->p5;\n                    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);\n                    db->vtabOnConflict = vtabOnConflict;\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc == 0 && pOp->p1) {\n                        ((void)0);\n                        db->lastRowid = rowid;\n                    }\n                    if ((rc & 255) == 19 && pOp->p4.pVtab->bConstraint) {\n                        if (pOp->p5 == 4) {\n                            rc = 0;\n                        } else {\n                            p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5);\n                        }\n                    } else {\n                        p->nChange++;\n                    }\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 177:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n                break;\n            }\n          case 178:\n            {\n                unsigned int newMax;\n                Btree *pBt;\n                pOut = out2Prerelease(p, pOp);\n                pBt = db->aDb[pOp->p1].pBt;\n                newMax = 0;\n                if (pOp->p3) {\n                    newMax = sqlite3BtreeLastPage(pBt);\n                    if (newMax < (unsigned int)pOp->p3)\n                        newMax = (unsigned int)pOp->p3;\n                }\n                pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n                break;\n            }\n          case 65:\n          case 66:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                ((void)0);\n                pCtx = pOp->p4.pCtx;\n                pOut = &aMem[pOp->p3];\n                if (pCtx->pOut != pOut) {\n                    pCtx->pVdbe = p;\n                    pCtx->pOut = pOut;\n                    pCtx->enc = encoding;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                ((void)0);\n                ;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                ((void)0);\n                (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pOut));\n                        rc = pCtx->isError;\n                    }\n                    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                break;\n            }\n          case 179:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn1->flags &= ~2048;\n                break;\n            }\n          case 180:\n            {\n                u64 h;\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                pIn1->z[h / 8] |= 1 << (h & 7);\n                break;\n            }\n          case 64:\n            {\n                u64 h;\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                if ((pIn1->z[h / 8] & (1 << (h & 7))) == 0) {\n                    ;\n                    p->aCounter[8]++;\n                    goto jump_to_p2;\n                } else {\n                    p->aCounter[7]++;\n                    ;\n                }\n                break;\n            }\n          case 181:\n          case 8:\n            {\n                int i;\n                char *zTrace;\n                ((void)0);\n                ((void)0);\n                if ((db->mTrace & (1 | 64)) != 0 && p->minWriteFileFormat != 254 && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0) {\n                    if (db->mTrace & 64) {\n                        char *z = sqlite3VdbeExpandSql(p, zTrace);\n                        db->trace.xLegacy(db->pTraceArg, z);\n                        sqlite3_free(z);\n                    } else if (db->nVdbeExec > 1) {\n                        char *z = sqlite3MPrintf(db, \"-- %s\", zTrace);\n                        (void)db->trace.xV2(1, db->pTraceArg, p, z);\n                        sqlite3DbFree(db, z);\n                    } else {\n                        (void)db->trace.xV2(1, db->pTraceArg, p, zTrace);\n                    }\n                }\n                ((void)0);\n                if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {\n                    if (pOp->opcode == 181)\n                        break;\n                    for (i = 1; i < p->nOp; i++) {\n                        if (p->aOp[i].opcode == 15)\n                            p->aOp[i].p1 = 0;\n                    }\n                    pOp->p1 = 0;\n                }\n                pOp->p1++;\n                p->aCounter[6]++;\n                goto jump_to_p2;\n            }\n          default:\n            {\n                ((void)0);\n                break;\n            }\n        }\n    }\n  abort_due_to_error:\n    if (db->mallocFailed) {\n        rc = 7;\n    } else if (rc == (10 | (33 << 8))) {\n        rc = sqlite3CorruptError(98965);\n    }\n    ((void)0);\n    if (p->zErrMsg == 0 && rc != (10 | (12 << 8))) {\n        sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n    }\n    p->rc = rc;\n    sqlite3SystemError(db, rc);\n    ;\n    sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", (int)(pOp - aOp), p->zSql, p->zErrMsg);\n    if (p->eVdbeState == 2)\n        sqlite3VdbeHalt(p);\n    if (rc == (10 | (12 << 8)))\n        sqlite3OomFault(db);\n    if (rc == 11 && db->autoCommit == 0) {\n        db->flags |= ((u64)(2) << 32);\n    }\n    rc = 1;\n    if (resetSchemaOnFault > 0) {\n        sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);\n    }\n  vdbe_return:\n    while (nVmStep >= nProgressLimit && db->xProgress != 0)\n        {\n            nProgressLimit += db->nProgressOps;\n            if (db->xProgress(db->pProgressArg)) {\n                nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                rc = 9;\n                goto abort_due_to_error;\n            }\n        }\n    p->aCounter[4] += (int)nVmStep;\n    if (((p->lockMask) != 0)) {\n        sqlite3VdbeLeave(p);\n    }\n    ((void)0);\n    return rc;\n  too_big:\n    sqlite3VdbeError(p, \"string or blob too big\");\n    rc = 18;\n    goto abort_due_to_error;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3VdbeError(p, \"out of memory\");\n    rc = 7;\n    goto abort_due_to_error;\n  abort_due_to_interrupt:\n    ((void)0);\n    rc = 9;\n    goto abort_due_to_error;\n}\n"
  },
  {
    "id": "sqlite3.c#58174:1#pager_playback",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    i64 szJ;\n    u32 nRec;\n    u32 u;\n    Pgno mxPg = 0;\n    int rc;\n    int res = 1;\n    char *zSuper = 0;\n    int needPagerReset;\n    int nPlayback = 0;\n    u32 savedPageSize = pPager->pageSize;\n    ((void)0);\n    rc = sqlite3OsFileSize(pPager->jfd, &szJ);\n    if (rc != 0) {\n        goto end_playback;\n    }\n    zSuper = pPager->pTmpSpace;\n    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n    if (rc == 0 && zSuper[0]) {\n        rc = sqlite3OsAccess(pVfs, zSuper, 0, &res);\n    }\n    zSuper = 0;\n    if (rc != 0 || !res) {\n        goto end_playback;\n    }\n    pPager->journalOff = 0;\n    needPagerReset = isHot;\n    while (1)\n        {\n            rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);\n            if (rc != 0) {\n                if (rc == 101) {\n                    rc = 0;\n                }\n                goto end_playback;\n            }\n            if (nRec == 4294967295U) {\n                ((void)0);\n                nRec = (int)((szJ - (pPager->sectorSize)) / ((pPager->pageSize) + 8));\n            }\n            if (nRec == 0 && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) {\n                nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));\n            }\n            if (pPager->journalOff == (pPager->sectorSize)) {\n                rc = pager_truncate(pPager, mxPg);\n                if (rc != 0) {\n                    goto end_playback;\n                }\n                pPager->dbSize = mxPg;\n                if (pPager->mxPgno < mxPg) {\n                    pPager->mxPgno = mxPg;\n                }\n            }\n            for (u = 0; u < nRec; u++) {\n                if (needPagerReset) {\n                    pager_reset(pPager);\n                    needPagerReset = 0;\n                }\n                rc = pager_playback_one_page(pPager, &pPager->journalOff, 0, 1, 0);\n                if (rc == 0) {\n                    nPlayback++;\n                } else {\n                    if (rc == 101) {\n                        pPager->journalOff = szJ;\n                        break;\n                    } else if (rc == (10 | (2 << 8))) {\n                        rc = 0;\n                        goto end_playback;\n                    } else {\n                        goto end_playback;\n                    }\n                }\n            }\n        }\n    ((void)0);\n  end_playback:\n    if (rc == 0) {\n        rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);\n    }\n    pPager->changeCountDone = pPager->tempFile;\n    if (rc == 0) {\n        zSuper = &pPager->pTmpSpace[4];\n        rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n        ;\n    }\n    if (rc == 0 && (pPager->eState >= 4 || pPager->eState == 0)) {\n        rc = sqlite3PagerSync(pPager, 0);\n    }\n    if (rc == 0) {\n        rc = pager_end_transaction(pPager, zSuper[0] != '\\x00', 0);\n        ;\n    }\n    if (rc == 0 && zSuper[0] && res) {\n        ((void)0);\n        __builtin___memset_chk(&zSuper[-4], 0, 4, __builtin_object_size(&zSuper[-4], 0));\n        rc = pager_delsuper(pPager, zSuper);\n        ;\n    }\n    if (isHot && nPlayback) {\n        sqlite3_log((27 | (2 << 8)), \"recovered %d pages from %s\", nPlayback, pPager->zJournal);\n    }\n    setSectorSize(pPager);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropTrigger",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Trigger *pTrigger = 0;\n    int i;\n    const char *zDb;\n    const char *zName;\n    sqlite3 *db = pParse->db;\n    if (db->mallocFailed)\n        goto drop_trigger_cleanup;\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto drop_trigger_cleanup;\n    }\n    ((void)0);\n    zDb = pName->a[0].zDatabase;\n    zName = pName->a[0].zName;\n    ((void)0);\n    for (i = 0; i < db->nDb; i++) {\n        int j = (i < 2) ? i ^ 1 : i;\n        if (zDb && sqlite3DbIsNamed(db, j, zDb) == 0)\n            continue;\n        ((void)0);\n        pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);\n        if (pTrigger)\n            break;\n    }\n    if (!pTrigger) {\n        if (!noErr) {\n            sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n        }\n        pParse->checkSchema = 1;\n        goto drop_trigger_cleanup;\n    }\n    sqlite3DropTriggerPtr(pParse, pTrigger);\n  drop_trigger_cleanup:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "sqlite3.c#111956:1#findOrCreateAggInfoColumn",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    struct AggInfo_col *pCol;\n    int k;\n    ((void)0);\n    pCol = pAggInfo->aCol;\n    for (k = 0; k < pAggInfo->nColumn; k++ , pCol++) {\n        if (pCol->iTable == pExpr->iTable && pCol->iColumn == pExpr->iColumn && pExpr->op != 179) {\n            goto fix_up_expr;\n        }\n    }\n    k = addAggInfoColumn(pParse->db, pAggInfo);\n    if (k < 0) {\n        ((void)0);\n        return;\n    }\n    pCol = &pAggInfo->aCol[k];\n    ((void)0);\n    pCol->pTab = pExpr->y.pTab;\n    pCol->iTable = pExpr->iTable;\n    pCol->iColumn = pExpr->iColumn;\n    pCol->iSorterColumn = -1;\n    pCol->pCExpr = pExpr;\n    if (pAggInfo->pGroupBy && pExpr->op != 179) {\n        int j, n;\n        ExprList *pGB = pAggInfo->pGroupBy;\n        struct ExprList_item *pTerm = pGB->a;\n        n = pGB->nExpr;\n        for (j = 0; j < n; j++ , pTerm++) {\n            Expr *pE = pTerm->pExpr;\n            if (pE->op == 167 && pE->iTable == pExpr->iTable && pE->iColumn == pExpr->iColumn) {\n                pCol->iSorterColumn = j;\n                break;\n            }\n        }\n    }\n    if (pCol->iSorterColumn < 0) {\n        pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n    }\n  fix_up_expr:\n    ;\n    ((void)0);\n    pExpr->pAggInfo = pAggInfo;\n    if (pExpr->op == 167) {\n        pExpr->op = 169;\n    }\n    pExpr->iAgg = (i16)k;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeIdxRowid",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    i64 nCellKey = 0;\n    int rc;\n    u32 szHdr;\n    u32 typeRowid;\n    u32 lenRowid;\n    Mem m, v;\n    ((void)0);\n    nCellKey = sqlite3BtreePayloadSize(pCur);\n    ((void)0);\n    sqlite3VdbeMemInit(&m, db, 0);\n    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n    if (rc) {\n        return rc;\n    }\n    szHdr = (u32)*((u8 *)m.z);\n    if (szHdr >= 128)\n        sqlite3GetVarint32(((u8 *)m.z), (u32 *)&(szHdr));\n    ;\n    ;\n    ;\n    ((void)0);\n    if ((szHdr < 3 || szHdr > (unsigned int)m.n)) {\n        goto idx_rowid_corruption;\n    }\n    typeRowid = (u32)*((u8 *)&m.z[szHdr - 1]);\n    if (typeRowid >= 128)\n        sqlite3GetVarint32(((u8 *)&m.z[szHdr - 1]), (u32 *)&(typeRowid));\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    if ((typeRowid < 1 || typeRowid > 9 || typeRowid == 7)) {\n        goto idx_rowid_corruption;\n    }\n    lenRowid = sqlite3SmallTypeSizes[typeRowid];\n    ;\n    if (((u32)m.n < szHdr + lenRowid)) {\n        goto idx_rowid_corruption;\n    }\n    sqlite3VdbeSerialGet((u8 *)&m.z[m.n - lenRowid], typeRowid, &v);\n    *rowid = v.u.i;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return 0;\n  idx_rowid_corruption:\n    ;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return sqlite3CorruptError(87409);\n}\n"
  },
  {
    "id": "#23:25#sqlite3InitOne",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    int rc;\n    int i;\n    int size;\n    Db *pDb;\n    const char *azArg[6];\n    int meta[5];\n    InitData initData;\n    const char *zSchemaTabName;\n    int openedTransaction = 0;\n    int mask = ((db->mDbFlags & 64) | ~64);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    db->init.busy = 1;\n    azArg[0] = \"table\";\n    azArg[1] = zSchemaTabName = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n    azArg[2] = azArg[1];\n    azArg[3] = \"1\";\n    azArg[4] = \"CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)\";\n    azArg[5] = 0;\n    initData.db = db;\n    initData.iDb = iDb;\n    initData.rc = 0;\n    initData.pzErrMsg = pzErrMsg;\n    initData.mInitFlags = mFlags;\n    initData.nInitRow = 0;\n    initData.mxPage = 0;\n    sqlite3InitCallback(&initData, 5, (char **)azArg, 0);\n    db->mDbFlags &= mask;\n    if (initData.rc) {\n        rc = initData.rc;\n        goto error_out;\n    }\n    pDb = &db->aDb[iDb];\n    if (pDb->pBt == 0) {\n        ((void)0);\n        (db)->aDb[1].pSchema->schemaFlags |= (1);\n        rc = 0;\n        goto error_out;\n    }\n    sqlite3BtreeEnter(pDb->pBt);\n    if (sqlite3BtreeTxnState(pDb->pBt) == 0) {\n        rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);\n        if (rc != 0) {\n            sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));\n            goto initone_error_out;\n        }\n        openedTransaction = 1;\n    }\n    for (i = 0; i < ((int)(sizeof (meta) / sizeof (meta[0]))); i++) {\n        sqlite3BtreeGetMeta(pDb->pBt, i + 1, (u32 *)&meta[i]);\n    }\n    if ((db->flags & 33554432) != 0) {\n        __builtin___memset_chk(meta, 0, sizeof (meta), __builtin_object_size(meta, 0));\n    }\n    pDb->pSchema->schema_cookie = meta[1 - 1];\n    if (meta[5 - 1]) {\n        if (iDb == 0 && (db->mDbFlags & 64) == 0) {\n            u8 encoding;\n            encoding = (u8)meta[5 - 1] & 3;\n            if (encoding == 0)\n                encoding = 1;\n            if (db->nVdbeActive > 0 && encoding != ((db)->enc)) {\n                rc = 6;\n                goto initone_error_out;\n            } else {\n                sqlite3SetTextEncoding(db, encoding);\n            }\n        } else {\n            if ((meta[5 - 1] & 3) != ((db)->enc)) {\n                sqlite3SetString(pzErrMsg, db, \"attached databases must use the same text encoding as main database\");\n                rc = 1;\n                goto initone_error_out;\n            }\n        }\n    }\n    pDb->pSchema->enc = ((db)->enc);\n    if (pDb->pSchema->cache_size == 0) {\n        size = sqlite3AbsInt32(meta[3 - 1]);\n        if (size == 0) {\n            size = -2000;\n        }\n        pDb->pSchema->cache_size = size;\n        sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    pDb->pSchema->file_format = (u8)meta[2 - 1];\n    if (pDb->pSchema->file_format == 0) {\n        pDb->pSchema->file_format = 1;\n    }\n    if (pDb->pSchema->file_format > 4) {\n        sqlite3SetString(pzErrMsg, db, \"unsupported file format\");\n        rc = 1;\n        goto initone_error_out;\n    }\n    if (iDb == 0 && meta[2 - 1] >= 4) {\n        db->flags &= ~(u64)2;\n    }\n    ((void)0);\n    initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);\n    {\n        char *zSql;\n        zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchemaTabName);\n        {\n            sqlite3_xauth xAuth;\n            xAuth = db->xAuth;\n            db->xAuth = 0;\n            rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n            db->xAuth = xAuth;\n        }\n        if (rc == 0)\n            rc = initData.rc;\n        sqlite3DbFree(db, zSql);\n        if (rc == 0) {\n            sqlite3AnalysisLoad(db, iDb);\n        }\n    }\n    ((void)0);\n    if (db->mallocFailed) {\n        rc = 7;\n        sqlite3ResetAllSchemasOfConnection(db);\n        pDb = &db->aDb[iDb];\n    } else if (rc == 0 || ((db->flags & 134217728) && rc != 7)) {\n        (db)->aDb[iDb].pSchema->schemaFlags |= (1);\n        rc = 0;\n    }\n  initone_error_out:\n    if (openedTransaction) {\n        sqlite3BtreeCommit(pDb->pBt);\n    }\n    sqlite3BtreeLeave(pDb->pBt);\n  error_out:\n    if (rc) {\n        if (rc == 7 || rc == (10 | (12 << 8))) {\n            sqlite3OomFault(db);\n        }\n        sqlite3ResetOneSchema(db, iDb);\n    }\n    db->init.busy = 0;\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprListAppendVector",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    int n;\n    int i;\n    int iFirst = pList ? pList->nExpr : 0;\n    if ((pColumns == 0))\n        goto vector_append_error;\n    if (pExpr == 0)\n        goto vector_append_error;\n    if (pExpr->op != 138 && pColumns->nId != (n = sqlite3ExprVectorSize(pExpr))) {\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pColumns->nId, n);\n        goto vector_append_error;\n    }\n    for (i = 0; i < pColumns->nId; i++) {\n        Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);\n        ((void)0);\n        if (pSubExpr == 0)\n            continue;\n        pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);\n        if (pList) {\n            ((void)0);\n            pList->a[pList->nExpr - 1].zEName = pColumns->a[i].zName;\n            pColumns->a[i].zName = 0;\n        }\n    }\n    if (!db->mallocFailed && pExpr->op == 138 && (pList != 0)) {\n        Expr *pFirst = pList->a[iFirst].pExpr;\n        ((void)0);\n        ((void)0);\n        pFirst->pRight = pExpr;\n        pExpr = 0;\n        pFirst->iTable = pColumns->nId;\n    }\n  vector_append_error:\n    sqlite3ExprUnmapAndDelete(pParse, pExpr);\n    sqlite3IdListDelete(db, pColumns);\n    return pList;\n}\n"
  },
  {
    "id": "sqlite3.c#87220:1#vdbeRecordCompareString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const u8 *aKey1 = (const u8 *)pKey1;\n    int serial_type;\n    int res;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ;\n    serial_type = (signed char)(aKey1[1]);\n  vrcs_restart:\n    if (serial_type < 12) {\n        if (serial_type < 0) {\n            sqlite3GetVarint32(&aKey1[1], (u32 *)&serial_type);\n            if (serial_type >= 12)\n                goto vrcs_restart;\n            ((void)0);\n        }\n        res = pPKey2->r1;\n    } else if (!(serial_type & 1)) {\n        res = pPKey2->r2;\n    } else {\n        int nCmp;\n        int nStr;\n        int szHdr = aKey1[0];\n        nStr = (serial_type - 12) / 2;\n        if ((szHdr + nStr) > nKey1) {\n            pPKey2->errCode = (u8)sqlite3CorruptError(87251);\n            return 0;\n        }\n        nCmp = ((pPKey2->n) < (nStr) ? (pPKey2->n) : (nStr));\n        res = memcmp(&aKey1[szHdr], pPKey2->u.z, nCmp);\n        if (res > 0) {\n            res = pPKey2->r2;\n        } else if (res < 0) {\n            res = pPKey2->r1;\n        } else {\n            res = nStr - pPKey2->n;\n            if (res == 0) {\n                if (pPKey2->nField > 1) {\n                    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n                } else {\n                    res = pPKey2->default_rc;\n                    pPKey2->eqSeen = 1;\n                }\n            } else if (res > 0) {\n                res = pPKey2->r2;\n            } else {\n                res = pPKey2->r1;\n            }\n        }\n    }\n    ((void)0);\n    return res;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeBeginTrans",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    BtShared *pBt = p->pBt;\n    Pager *pPager = pBt->pPager;\n    int rc = 0;\n    sqlite3BtreeEnter(p);\n    ((void)0);\n    ((void)0);\n    ;\n    if (p->inTrans == 2 || (p->inTrans == 1 && !wrflag)) {\n        goto trans_begun;\n    }\n    ((void)0);\n    if ((p->db->flags & 33554432) && sqlite3PagerIsreadonly(pPager) == 0) {\n        pBt->btsFlags &= ~1;\n    }\n    if ((pBt->btsFlags & 1) != 0 && wrflag) {\n        rc = 8;\n        goto trans_begun;\n    }\n    {\n        sqlite3 *pBlock = 0;\n        if ((wrflag && pBt->inTransaction == 2) || (pBt->btsFlags & 128) != 0) {\n            pBlock = pBt->pWriter->db;\n        } else if (wrflag > 1) {\n            BtLock *pIter;\n            for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {\n                if (pIter->pBtree != p) {\n                    pBlock = pIter->pBtree->db;\n                    break;\n                }\n            }\n        }\n        if (pBlock) {\n            ;\n            rc = (6 | (1 << 8));\n            goto trans_begun;\n        }\n    }\n    rc = querySharedCacheTableLock(p, 1, 1);\n    if (0 != rc)\n        goto trans_begun;\n    pBt->btsFlags &= ~16;\n    if (pBt->nPage == 0)\n        pBt->btsFlags |= 16;\n    do {\n        ;\n        while (pBt->pPage1 == 0 && 0 == (rc = lockBtree(pBt)))\n            ;\n        if (rc == 0 && wrflag) {\n            if ((pBt->btsFlags & 1) != 0) {\n                rc = 8;\n            } else {\n                rc = sqlite3PagerBegin(pPager, wrflag > 1, sqlite3TempInMemory(p->db));\n                if (rc == 0) {\n                    rc = newDatabase(pBt);\n                } else if (rc == (5 | (2 << 8)) && pBt->inTransaction == 0) {\n                    rc = 5;\n                }\n            }\n        }\n        if (rc != 0) {\n            (void)0;\n            unlockBtreeIfUnused(pBt);\n        }\n    } while ((rc & 255) == 5 && pBt->inTransaction == 0 && btreeInvokeBusyHandler(pBt));\n    ;\n    if (rc == 0) {\n        if (p->inTrans == 0) {\n            pBt->nTransaction++;\n            if (p->sharable) {\n                ((void)0);\n                p->lock.eLock = 1;\n                p->lock.pNext = pBt->pLock;\n                pBt->pLock = &p->lock;\n            }\n        }\n        p->inTrans = (wrflag ? 2 : 1);\n        if (p->inTrans > pBt->inTransaction) {\n            pBt->inTransaction = p->inTrans;\n        }\n        if (wrflag) {\n            MemPage *pPage1 = pBt->pPage1;\n            ((void)0);\n            pBt->pWriter = p;\n            pBt->btsFlags &= ~64;\n            if (wrflag > 1)\n                pBt->btsFlags |= 64;\n            if (pBt->nPage != sqlite3Get4byte(&pPage1->aData[28])) {\n                rc = sqlite3PagerWrite(pPage1->pDbPage);\n                if (rc == 0) {\n                    sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);\n                }\n            }\n        }\n    }\n  trans_begun:\n    if (rc == 0) {\n        if (pSchemaVersion) {\n            *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);\n        }\n        if (wrflag) {\n            rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);\n        }\n    }\n    ((void)0);\n    ((void)0);\n    ;\n    sqlite3BtreeLeave(p);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3StartTable",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    Table *pTable;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    Vdbe *v;\n    int iDb;\n    Token *pName;\n    if (db->init.busy && db->init.newTnum == 1) {\n        iDb = db->init.iDb;\n        zName = sqlite3DbStrDup(db, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"));\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            return;\n        if (!0 && isTemp && pName2->n > 0 && iDb != 1) {\n            sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n            return;\n        }\n        if (!0 && isTemp)\n            iDb = 1;\n        zName = sqlite3NameFromToken(db, pName);\n        if ((pParse->eParseMode >= 2)) {\n            sqlite3RenameTokenMap(pParse, (void *)zName, pName);\n        }\n    }\n    pParse->sNameToken = *pName;\n    if (zName == 0)\n        return;\n    if (sqlite3CheckObjectName(pParse, zName, isView ? \"view\" : \"table\", zName)) {\n        goto begin_table_error;\n    }\n    if (db->init.iDb == 1)\n        isTemp = 1;\n    ((void)0);\n    ((void)0);\n    {\n        static const u8 aCode[] = {2, 4, 8, 6};\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (isTemp == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto begin_table_error;\n        }\n        if (!isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp + 2 * isView], zName, 0, zDb)) {\n            goto begin_table_error;\n        }\n    }\n    if (!(pParse->eParseMode != 0)) {\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (0 != sqlite3ReadSchema(pParse)) {\n            goto begin_table_error;\n        }\n        pTable = sqlite3FindTable(db, zName, zDb);\n        if (pTable) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"%s %T already exists\", (((pTable)->eTabType == 2) ? \"view\" : \"table\"), pName);\n            } else {\n                ((void)0);\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3ForceNotReadOnly(pParse);\n            }\n            goto begin_table_error;\n        }\n        if (sqlite3FindIndex(db, zName, zDb) != 0) {\n            sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n            goto begin_table_error;\n        }\n    }\n    pTable = sqlite3DbMallocZero(db, sizeof(Table));\n    if (pTable == 0) {\n        ((void)0);\n        pParse->rc = 7;\n        pParse->nErr++;\n        goto begin_table_error;\n    }\n    pTable->zName = zName;\n    pTable->iPKey = -1;\n    pTable->pSchema = db->aDb[iDb].pSchema;\n    pTable->nTabRef = 1;\n    pTable->nRowLogEst = 200;\n    ((void)0);\n    ((void)0);\n    pParse->pNewTable = pTable;\n    if (!db->init.busy && (v = sqlite3GetVdbe(pParse)) != 0) {\n        int addr1;\n        int fileFormat;\n        int reg1, reg2, reg3;\n        static const char nullRow[] = {6, 0, 0, 0, 0, 0};\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (isVirtual) {\n            sqlite3VdbeAddOp0(v, 170);\n        }\n        reg1 = pParse->regRowid = ++pParse->nMem;\n        reg2 = pParse->regRoot = ++pParse->nMem;\n        reg3 = ++pParse->nMem;\n        sqlite3VdbeAddOp3(v, 99, iDb, reg3, 2);\n        sqlite3VdbeUsesBtree(v, iDb);\n        addr1 = sqlite3VdbeAddOp1(v, 16, reg3);\n        ;\n        fileFormat = (db->flags & 2) != 0 ? 1 : 4;\n        sqlite3VdbeAddOp3(v, 100, iDb, 2, fileFormat);\n        sqlite3VdbeAddOp3(v, 100, iDb, 5, ((db)->enc));\n        sqlite3VdbeJumpHere(v, addr1);\n        if (isView || isVirtual) {\n            sqlite3VdbeAddOp2(v, 71, 0, reg2);\n        } else {\n            ((void)0);\n            pParse->u1.addrCrTab = sqlite3VdbeAddOp3(v, 147, iDb, reg2, 1);\n        }\n        sqlite3OpenSchemaTable(pParse, iDb);\n        sqlite3VdbeAddOp2(v, 127, 0, reg1);\n        sqlite3VdbeAddOp4(v, 77, 6, reg3, 0, nullRow, (-1));\n        sqlite3VdbeAddOp3(v, 128, 0, reg3, reg1);\n        sqlite3VdbeChangeP5(v, 8);\n        sqlite3VdbeAddOp0(v, 122);\n    }\n    return;\n  begin_table_error:\n    pParse->checkSchema = 1;\n    sqlite3DbFree(db, zName);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeMultiLoad",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    va_list ap;\n    int i;\n    char c;\n    __builtin_va_start(ap, zTypes);\n    for (i = 0; (c = zTypes[i]) != 0; i++) {\n        if (c == 's') {\n            const char *z = __builtin_va_arg(ap, const char *);\n            sqlite3VdbeAddOp4(p, z == 0 ? 75 : 117, 0, iDest + i, 0, z, 0);\n        } else if (c == 'i') {\n            sqlite3VdbeAddOp2(p, 71, __builtin_va_arg(ap, int), iDest + i);\n        } else {\n            goto skip_op_resultrow;\n        }\n    }\n    sqlite3VdbeAddOp2(p, 84, iDest, i);\n  skip_op_resultrow:\n    __builtin_va_end(ap);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeIntegrityCheck",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Pgno i;\n    IntegrityCk sCheck;\n    BtShared *pBt = p->pBt;\n    u64 savedDbFlags = pBt->db->flags;\n    char zErr[100];\n    int bPartial = 0;\n    int bCkFreelist = 1;\n    ;\n    ((void)0);\n    if (aRoot[0] == 0) {\n        ((void)0);\n        bPartial = 1;\n        if (aRoot[1] != 1)\n            bCkFreelist = 0;\n    }\n    sqlite3BtreeEnter(p);\n    ((void)0);\n    ;\n    ((void)0);\n    __builtin___memset_chk(&sCheck, 0, sizeof (sCheck), __builtin_object_size(&sCheck, 0));\n    sCheck.db = db;\n    sCheck.pBt = pBt;\n    sCheck.pPager = pBt->pPager;\n    sCheck.nPage = btreePagecount(sCheck.pBt);\n    sCheck.mxErr = mxErr;\n    sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof (zErr), 1000000000);\n    sCheck.errMsg.printfFlags = 1;\n    if (sCheck.nPage == 0) {\n        goto integrity_ck_cleanup;\n    }\n    sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8) + 1);\n    if (!sCheck.aPgRef) {\n        checkOom(&sCheck);\n        goto integrity_ck_cleanup;\n    }\n    sCheck.heap = (u32 *)sqlite3PageMalloc(pBt->pageSize);\n    if (sCheck.heap == 0) {\n        checkOom(&sCheck);\n        goto integrity_ck_cleanup;\n    }\n    i = ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1));\n    if (i <= sCheck.nPage)\n        setPageReferenced(&sCheck, i);\n    if (bCkFreelist) {\n        sCheck.zPfx = \"Main freelist: \";\n        checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]), sqlite3Get4byte(&pBt->pPage1->aData[36]));\n        sCheck.zPfx = 0;\n    }\n    if (!bPartial) {\n        if (pBt->autoVacuum) {\n            Pgno mx = 0;\n            Pgno mxInHdr;\n            for (i = 0; (int)i < nRoot; i++)\n                if (mx < aRoot[i])\n                    mx = aRoot[i];\n            mxInHdr = sqlite3Get4byte(&pBt->pPage1->aData[52]);\n            if (mx != mxInHdr) {\n                checkAppendMsg(&sCheck, \"max rootpage (%d) disagrees with header (%d)\", mx, mxInHdr);\n            }\n        } else if (sqlite3Get4byte(&pBt->pPage1->aData[64]) != 0) {\n            checkAppendMsg(&sCheck, \"incremental_vacuum enabled with a max rootpage of zero\");\n        }\n    }\n    ;\n    pBt->db->flags &= ~(u64)2097152;\n    for (i = 0; (int)i < nRoot && sCheck.mxErr; i++) {\n        i64 notUsed;\n        if (aRoot[i] == 0)\n            continue;\n        if (pBt->autoVacuum && aRoot[i] > 1 && !bPartial) {\n            checkPtrmap(&sCheck, aRoot[i], 1, 0);\n        }\n        checkTreePage(&sCheck, aRoot[i], &notUsed, (4294967295U | (((i64)2147483647) << 32)));\n    }\n    pBt->db->flags = savedDbFlags;\n    if (!bPartial) {\n        for (i = 1; i <= sCheck.nPage && sCheck.mxErr; i++) {\n            if (getPageReferenced(&sCheck, i) == 0 && (ptrmapPageno(pBt, i) != i || !pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n            }\n            if (getPageReferenced(&sCheck, i) != 0 && (ptrmapPageno(pBt, i) == i && pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n            }\n        }\n    }\n  integrity_ck_cleanup:\n    sqlite3PageFree(sCheck.heap);\n    sqlite3_free(sCheck.aPgRef);\n    *pnErr = sCheck.nErr;\n    if (sCheck.nErr == 0) {\n        sqlite3_str_reset(&sCheck.errMsg);\n        *pzOut = 0;\n    } else {\n        *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);\n    }\n    ((void)0);\n    sqlite3BtreeLeave(p);\n    return sCheck.rc;\n}\n"
  },
  {
    "id": "sqlite3.c#78833:1#checkTreePage",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    MemPage *pPage = 0;\n    int i;\n    int rc;\n    int depth = -1, d2;\n    int pgno;\n    int nFrag;\n    int hdr;\n    int cellStart;\n    int nCell;\n    int doCoverageCheck = 1;\n    int keyCanBeEqual = 1;\n    u8 *data;\n    u8 *pCell;\n    u8 *pCellIdx;\n    BtShared *pBt;\n    u32 pc;\n    u32 usableSize;\n    u32 contentOffset;\n    u32 *heap = 0;\n    u32 x, prev = 0;\n    const char *saved_zPfx = pCheck->zPfx;\n    int saved_v1 = pCheck->v1;\n    int saved_v2 = pCheck->v2;\n    u8 savedIsInit = 0;\n    checkProgress(pCheck);\n    if (pCheck->mxErr == 0)\n        goto end_of_check;\n    pBt = pCheck->pBt;\n    usableSize = pBt->usableSize;\n    if (iPage == 0)\n        return 0;\n    if (checkRef(pCheck, iPage))\n        return 0;\n    pCheck->zPfx = \"Page %u: \";\n    pCheck->v1 = iPage;\n    if ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0) {\n        checkAppendMsg(pCheck, \"unable to get the page. error code=%d\", rc);\n        goto end_of_check;\n    }\n    savedIsInit = pPage->isInit;\n    pPage->isInit = 0;\n    if ((rc = btreeInitPage(pPage)) != 0) {\n        ((void)0);\n        checkAppendMsg(pCheck, \"btreeInitPage() returns error code %d\", rc);\n        goto end_of_check;\n    }\n    if ((rc = btreeComputeFreeSpace(pPage)) != 0) {\n        ((void)0);\n        checkAppendMsg(pCheck, \"free space corruption\", rc);\n        goto end_of_check;\n    }\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    pCheck->zPfx = \"On tree page %u cell %d: \";\n    contentOffset = (((((int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1])) - 1) & 65535) + 1);\n    ((void)0);\n    nCell = ((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]);\n    ((void)0);\n    cellStart = hdr + 12 - 4 * pPage->leaf;\n    ((void)0);\n    pCellIdx = &data[cellStart + 2 * (nCell - 1)];\n    if (!pPage->leaf) {\n        pgno = sqlite3Get4byte(&data[hdr + 8]);\n        if (pBt->autoVacuum) {\n            pCheck->zPfx = \"On page %u at right child: \";\n            checkPtrmap(pCheck, pgno, 5, iPage);\n        }\n        depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n        keyCanBeEqual = 0;\n    } else {\n        heap = pCheck->heap;\n        heap[0] = 0;\n    }\n    for (i = nCell - 1; i >= 0 && pCheck->mxErr; i--) {\n        CellInfo info;\n        pCheck->v2 = i;\n        ((void)0);\n        pc = ((pCellIdx)[0] << 8 | (pCellIdx)[1]);\n        pCellIdx -= 2;\n        if (pc < contentOffset || pc > usableSize - 4) {\n            checkAppendMsg(pCheck, \"Offset %d out of range %d..%d\", pc, contentOffset, usableSize - 4);\n            doCoverageCheck = 0;\n            continue;\n        }\n        pCell = &data[pc];\n        pPage->xParseCell(pPage, pCell, &info);\n        if (pc + info.nSize > usableSize) {\n            checkAppendMsg(pCheck, \"Extends off end of page\");\n            doCoverageCheck = 0;\n            continue;\n        }\n        if (pPage->intKey) {\n            if (keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey)) {\n                checkAppendMsg(pCheck, \"Rowid %lld out of order\", info.nKey);\n            }\n            maxKey = info.nKey;\n            keyCanBeEqual = 0;\n        }\n        if (info.nPayload > info.nLocal) {\n            u32 nPage;\n            Pgno pgnoOvfl;\n            ((void)0);\n            nPage = (info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4);\n            pgnoOvfl = sqlite3Get4byte(&pCell[info.nSize - 4]);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgnoOvfl, 3, iPage);\n            }\n            checkList(pCheck, 0, pgnoOvfl, nPage);\n        }\n        if (!pPage->leaf) {\n            pgno = sqlite3Get4byte(pCell);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgno, 5, iPage);\n            }\n            d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n            keyCanBeEqual = 0;\n            if (d2 != depth) {\n                checkAppendMsg(pCheck, \"Child page depth differs\");\n                depth = d2;\n            }\n        } else {\n            btreeHeapInsert(heap, (pc << 16) | (pc + info.nSize - 1));\n        }\n    }\n    *piMinKey = maxKey;\n    pCheck->zPfx = 0;\n    if (doCoverageCheck && pCheck->mxErr > 0) {\n        if (!pPage->leaf) {\n            heap = pCheck->heap;\n            heap[0] = 0;\n            for (i = nCell - 1; i >= 0; i--) {\n                u32 size;\n                pc = ((&data[cellStart + i * 2])[0] << 8 | (&data[cellStart + i * 2])[1]);\n                size = pPage->xCellSize(pPage, &data[pc]);\n                btreeHeapInsert(heap, (pc << 16) | (pc + size - 1));\n            }\n        }\n        i = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        while (i > 0)\n            {\n                int size, j;\n                ((void)0);\n                size = ((&data[i + 2])[0] << 8 | (&data[i + 2])[1]);\n                ((void)0);\n                btreeHeapInsert(heap, (((u32)i) << 16) | (i + size - 1));\n                j = ((&data[i])[0] << 8 | (&data[i])[1]);\n                ((void)0);\n                ((void)0);\n                i = j;\n            }\n        nFrag = 0;\n        prev = contentOffset - 1;\n        while (btreeHeapPull(heap, &x))\n            {\n                if ((prev & 65535) >= (x >> 16)) {\n                    checkAppendMsg(pCheck, \"Multiple uses for byte %u of page %u\", x >> 16, iPage);\n                    break;\n                } else {\n                    nFrag += (x >> 16) - (prev & 65535) - 1;\n                    prev = x;\n                }\n            }\n        nFrag += usableSize - (prev & 65535) - 1;\n        if (heap[0] == 0 && nFrag != data[hdr + 7]) {\n            checkAppendMsg(pCheck, \"Fragmentation of %d bytes reported as %d on page %u\", nFrag, data[hdr + 7], iPage);\n        }\n    }\n  end_of_check:\n    if (!doCoverageCheck)\n        pPage->isInit = savedIsInit;\n    releasePage(pPage);\n    pCheck->zPfx = saved_zPfx;\n    pCheck->v1 = saved_v1;\n    pCheck->v2 = saved_v2;\n    return depth + 1;\n}\n"
  },
  {
    "id": "sqlite3.c#76244:1#balance_nonroot",
    "gotos": 15,
    "labels": 1,
    "body": "{\n    BtShared *pBt;\n    int nMaxCells = 0;\n    int nNew = 0;\n    int nOld;\n    int i, j, k;\n    int nxDiv;\n    int rc = 0;\n    u16 leafCorrection;\n    int leafData;\n    int usableSpace;\n    int pageFlags;\n    int iSpace1 = 0;\n    int iOvflSpace = 0;\n    int szScratch;\n    MemPage *apOld[3];\n    MemPage *apNew[5];\n    u8 *pRight;\n    u8 *apDiv[2];\n    int cntNew[5];\n    int cntOld[5];\n    int szNew[5];\n    u8 *aSpace1;\n    Pgno pgno;\n    u8 abDone[5];\n    Pgno aPgno[5];\n    CellArray b;\n    __builtin___memset_chk(abDone, 0, sizeof (abDone), __builtin_object_size(abDone, 0));\n    __builtin___memset_chk(&b, 0, sizeof (b), __builtin_object_size(&b, 0));\n    pBt = pParent->pBt;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (!aOvflSpace) {\n        return 7;\n    }\n    ((void)0);\n    i = pParent->nOverflow + pParent->nCell;\n    if (i < 2) {\n        nxDiv = 0;\n    } else {\n        ((void)0);\n        if (iParentIdx == 0) {\n            nxDiv = 0;\n        } else if (iParentIdx == i) {\n            nxDiv = i - 2 + bBulk;\n        } else {\n            nxDiv = iParentIdx - 1;\n        }\n        i = 2 - bBulk;\n    }\n    nOld = i + 1;\n    if ((i + nxDiv - pParent->nOverflow) == pParent->nCell) {\n        pRight = &pParent->aData[pParent->hdrOffset + 8];\n    } else {\n        pRight = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n    }\n    pgno = sqlite3Get4byte(pRight);\n    while (1)\n        {\n            if (rc == 0) {\n                rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n            }\n            if (rc) {\n                __builtin___memset_chk(apOld, 0, (i + 1) * sizeof(MemPage *), __builtin_object_size(apOld, 0));\n                goto balance_cleanup;\n            }\n            if (apOld[i]->nFree < 0) {\n                rc = btreeComputeFreeSpace(apOld[i]);\n                if (rc) {\n                    __builtin___memset_chk(apOld, 0, (i) * sizeof(MemPage *), __builtin_object_size(apOld, 0));\n                    goto balance_cleanup;\n                }\n            }\n            nMaxCells += apOld[i]->nCell + ((int)(sizeof (pParent->apOvfl) / sizeof (pParent->apOvfl[0])));\n            if ((i--) == 0)\n                break;\n            if (pParent->nOverflow && i + nxDiv == pParent->aiOvfl[0]) {\n                apDiv[i] = pParent->apOvfl[0];\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                pParent->nOverflow = 0;\n            } else {\n                apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                if (pBt->btsFlags & 12) {\n                    int iOff;\n                    iOff = ((int)(intptr_t)(apDiv[i])) - ((int)(intptr_t)(pParent->aData));\n                    if ((iOff + szNew[i]) <= (int)pBt->usableSize) {\n                        __builtin___memcpy_chk(&aOvflSpace[iOff], apDiv[i], szNew[i], __builtin_object_size(&aOvflSpace[iOff], 0));\n                        apDiv[i] = &aOvflSpace[apDiv[i] - pParent->aData];\n                    }\n                }\n                dropCell(pParent, i + nxDiv - pParent->nOverflow, szNew[i], &rc);\n            }\n        }\n    nMaxCells = (nMaxCells + 3) & ~3;\n    szScratch = nMaxCells * sizeof(u8 *) + nMaxCells * sizeof(u16) + pBt->pageSize;\n    ((void)0);\n    b.apCell = sqlite3DbMallocRaw(0, szScratch);\n    if (b.apCell == 0) {\n        rc = 7;\n        goto balance_cleanup;\n    }\n    b.szCell = (u16 *)&b.apCell[nMaxCells];\n    aSpace1 = (u8 *)&b.szCell[nMaxCells];\n    ((void)0);\n    b.pRef = apOld[0];\n    leafCorrection = b.pRef->leaf * 4;\n    leafData = b.pRef->intKeyLeaf;\n    for (i = 0; i < nOld; i++) {\n        MemPage *pOld = apOld[i];\n        int limit = pOld->nCell;\n        u8 *aData = pOld->aData;\n        u16 maskPage = pOld->maskPage;\n        u8 *piCell = aData + pOld->cellOffset;\n        u8 *piEnd;\n        if (pOld->aData[0] != apOld[0]->aData[0]) {\n            rc = sqlite3CorruptError(76438);\n            goto balance_cleanup;\n        }\n        __builtin___memset_chk(&b.szCell[b.nCell], 0, sizeof (b.szCell[0]) * (limit + pOld->nOverflow), __builtin_object_size(&b.szCell[b.nCell], 0));\n        if (pOld->nOverflow > 0) {\n            if ((limit < pOld->aiOvfl[0])) {\n                rc = sqlite3CorruptError(76462);\n                goto balance_cleanup;\n            }\n            limit = pOld->aiOvfl[0];\n            for (j = 0; j < limit; j++) {\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n            for (k = 0; k < pOld->nOverflow; k++) {\n                ((void)0);\n                b.apCell[b.nCell] = pOld->apOvfl[k];\n                b.nCell++;\n            }\n        }\n        piEnd = aData + pOld->cellOffset + 2 * pOld->nCell;\n        while (piCell < piEnd)\n            {\n                ((void)0);\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n        ((void)0);\n        cntOld[i] = b.nCell;\n        if (i < nOld - 1 && !leafData) {\n            u16 sz = (u16)szNew[i];\n            u8 *pTemp;\n            ((void)0);\n            b.szCell[b.nCell] = sz;\n            pTemp = &aSpace1[iSpace1];\n            iSpace1 += sz;\n            ((void)0);\n            ((void)0);\n            __builtin___memcpy_chk(pTemp, apDiv[i], sz, __builtin_object_size(pTemp, 0));\n            b.apCell[b.nCell] = pTemp + leafCorrection;\n            ((void)0);\n            b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;\n            if (!pOld->leaf) {\n                ((void)0);\n                ((void)0);\n                __builtin___memcpy_chk(b.apCell[b.nCell], &pOld->aData[8], 4, __builtin_object_size(b.apCell[b.nCell], 0));\n            } else {\n                ((void)0);\n                while (b.szCell[b.nCell] < 4)\n                    {\n                        ((void)0);\n                        ((void)0);\n                        aSpace1[iSpace1++] = 0;\n                        b.szCell[b.nCell]++;\n                    }\n            }\n            b.nCell++;\n        }\n    }\n    usableSpace = pBt->usableSize - 12 + leafCorrection;\n    for (i = k = 0; i < nOld; i++ , k++) {\n        MemPage *p = apOld[i];\n        b.apEnd[k] = p->aDataEnd;\n        b.ixNx[k] = cntOld[i];\n        if (k && b.ixNx[k] == b.ixNx[k - 1]) {\n            k--;\n        }\n        if (!leafData) {\n            k++;\n            b.apEnd[k] = pParent->aDataEnd;\n            b.ixNx[k] = cntOld[i] + 1;\n        }\n        ((void)0);\n        szNew[i] = usableSpace - p->nFree;\n        for (j = 0; j < p->nOverflow; j++) {\n            szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);\n        }\n        cntNew[i] = cntOld[i];\n    }\n    k = nOld;\n    for (i = 0; i < k; i++) {\n        int sz;\n        while (szNew[i] > usableSpace)\n            {\n                if (i + 1 >= k) {\n                    k = i + 2;\n                    if (k > 3 + 2) {\n                        rc = sqlite3CorruptError(76563);\n                        goto balance_cleanup;\n                    }\n                    szNew[k - 1] = 0;\n                    cntNew[k - 1] = b.nCell;\n                }\n                sz = 2 + cachedCellSize(&b, cntNew[i] - 1);\n                szNew[i] -= sz;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] += sz;\n                cntNew[i]--;\n            }\n        while (cntNew[i] < b.nCell)\n            {\n                sz = 2 + cachedCellSize(&b, cntNew[i]);\n                if (szNew[i] + sz > usableSpace)\n                    break;\n                szNew[i] += sz;\n                cntNew[i]++;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] -= sz;\n            }\n        if (cntNew[i] >= b.nCell) {\n            k = i + 1;\n        } else if (cntNew[i] <= (i > 0 ? cntNew[i - 1] : 0)) {\n            rc = sqlite3CorruptError(76596);\n            goto balance_cleanup;\n        }\n    }\n    for (i = k - 1; i > 0; i--) {\n        int szRight = szNew[i];\n        int szLeft = szNew[i - 1];\n        int r;\n        int d;\n        r = cntNew[i - 1] - 1;\n        d = r + 1 - leafData;\n        (void)cachedCellSize(&b, d);\n        do {\n            int szR, szD;\n            ((void)0);\n            ((void)0);\n            szR = cachedCellSize(&b, r);\n            szD = b.szCell[d];\n            if (szRight != 0 && (bBulk || szRight + szD + 2 > szLeft - (szR + (i == k - 1 ? 0 : 2)))) {\n                break;\n            }\n            szRight += szD + 2;\n            szLeft -= szR + 2;\n            cntNew[i - 1] = r;\n            r--;\n            d--;\n        } while (r >= 0);\n        szNew[i] = szRight;\n        szNew[i - 1] = szLeft;\n        if (cntNew[i - 1] <= (i > 1 ? cntNew[i - 2] : 0)) {\n            rc = sqlite3CorruptError(76640);\n            goto balance_cleanup;\n        }\n    }\n    ((void)0);\n    ;\n    pageFlags = apOld[0]->aData[0];\n    for (i = 0; i < k; i++) {\n        MemPage *pNew;\n        if (i < nOld) {\n            pNew = apNew[i] = apOld[i];\n            apOld[i] = 0;\n            rc = sqlite3PagerWrite(pNew->pDbPage);\n            nNew++;\n            if (sqlite3PagerPageRefcount(pNew->pDbPage) != 1 + (i == (iParentIdx - nxDiv)) && rc == 0) {\n                rc = sqlite3CorruptError(76673);\n            }\n            if (rc)\n                goto balance_cleanup;\n        } else {\n            ((void)0);\n            rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);\n            if (rc)\n                goto balance_cleanup;\n            zeroPage(pNew, pageFlags);\n            apNew[i] = pNew;\n            nNew++;\n            cntOld[i] = b.nCell;\n            if ((pBt->autoVacuum)) {\n                ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);\n                if (rc != 0) {\n                    goto balance_cleanup;\n                }\n            }\n        }\n    }\n    for (i = 0; i < nNew; i++) {\n        aPgno[i] = apNew[i]->pgno;\n        ((void)0);\n        ((void)0);\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        int iB = i;\n        for (j = i + 1; j < nNew; j++) {\n            if (apNew[j]->pgno < apNew[iB]->pgno)\n                iB = j;\n        }\n        if (iB != i) {\n            Pgno pgnoA = apNew[i]->pgno;\n            Pgno pgnoB = apNew[iB]->pgno;\n            Pgno pgnoTemp = (sqlite3PendingByte / pBt->pageSize) + 1;\n            u16 fgA = apNew[i]->pDbPage->flags;\n            u16 fgB = apNew[iB]->pDbPage->flags;\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoTemp, fgB);\n            sqlite3PagerRekey(apNew[iB]->pDbPage, pgnoA, fgA);\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoB, fgB);\n            apNew[i]->pgno = pgnoB;\n            apNew[iB]->pgno = pgnoA;\n        }\n    }\n    ;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    sqlite3Put4byte(pRight, apNew[nNew - 1]->pgno);\n    if ((pageFlags & 8) == 0 && nOld != nNew) {\n        MemPage *pOld = (nNew > nOld ? apNew : apOld)[nOld - 1];\n        __builtin___memcpy_chk(&apNew[nNew - 1]->aData[8], &pOld->aData[8], 4, __builtin_object_size(&apNew[nNew - 1]->aData[8], 0));\n    }\n    if ((pBt->autoVacuum)) {\n        MemPage *pOld;\n        MemPage *pNew = pOld = apNew[0];\n        int cntOldNext = pNew->nCell + pNew->nOverflow;\n        int iNew = 0;\n        int iOld = 0;\n        for (i = 0; i < b.nCell; i++) {\n            u8 *pCell = b.apCell[i];\n            while (i == cntOldNext)\n                {\n                    iOld++;\n                    ((void)0);\n                    ((void)0);\n                    pOld = iOld < nNew ? apNew[iOld] : apOld[iOld];\n                    cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;\n                }\n            if (i == cntNew[iNew]) {\n                pNew = apNew[++iNew];\n                if (!leafData)\n                    continue;\n            }\n            if (iOld >= nNew || pNew->pgno != aPgno[iOld] || !(((uptr)(pCell) >= (uptr)(pOld->aData)) && ((uptr)(pCell) < (uptr)(pOld->aDataEnd)))) {\n                if (!leafCorrection) {\n                    ptrmapPut(pBt, sqlite3Get4byte(pCell), 5, pNew->pgno, &rc);\n                }\n                if (cachedCellSize(&b, i) > pNew->minLocal) {\n                    ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);\n                }\n                if (rc)\n                    goto balance_cleanup;\n            }\n        }\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        u8 *pCell;\n        u8 *pTemp;\n        int sz;\n        u8 *pSrcEnd;\n        MemPage *pNew = apNew[i];\n        j = cntNew[i];\n        ((void)0);\n        ((void)0);\n        pCell = b.apCell[j];\n        sz = b.szCell[j] + leafCorrection;\n        pTemp = &aOvflSpace[iOvflSpace];\n        if (!pNew->leaf) {\n            __builtin___memcpy_chk(&pNew->aData[8], pCell, 4, __builtin_object_size(&pNew->aData[8], 0));\n        } else if (leafData) {\n            CellInfo info;\n            j--;\n            pNew->xParseCell(pNew, b.apCell[j], &info);\n            pCell = pTemp;\n            sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);\n            pTemp = 0;\n        } else {\n            pCell -= 4;\n            if (b.szCell[j] == 4) {\n                ((void)0);\n                sz = pParent->xCellSize(pParent, pCell);\n            }\n        }\n        iOvflSpace += sz;\n        ((void)0);\n        ((void)0);\n        for (k = 0; b.ixNx[k] <= j && (k < 3 * 2); k++) {\n        }\n        pSrcEnd = b.apEnd[k];\n        if ((((uptr)(pSrcEnd) >= (uptr)(pCell)) && ((uptr)(pSrcEnd) < (uptr)(pCell + sz)))) {\n            rc = sqlite3CorruptError(76873);\n            goto balance_cleanup;\n        }\n        rc = insertCell(pParent, nxDiv + i, pCell, sz, pTemp, pNew->pgno);\n        if (rc != 0)\n            goto balance_cleanup;\n        ((void)0);\n    }\n    for (i = 1 - nNew; i < nNew; i++) {\n        int iPg = i < 0 ? -i : i;\n        ((void)0);\n        if (abDone[iPg])\n            continue;\n        if (i >= 0 || cntOld[iPg - 1] >= cntNew[iPg - 1]) {\n            int iNew;\n            int iOld;\n            int nNewCell;\n            ((void)0);\n            ((void)0);\n            if (iPg == 0) {\n                iNew = iOld = 0;\n                nNewCell = cntNew[0];\n            } else {\n                iOld = iPg < nOld ? (cntOld[iPg - 1] + !leafData) : b.nCell;\n                iNew = cntNew[iPg - 1] + !leafData;\n                nNewCell = cntNew[iPg] - iNew;\n            }\n            rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);\n            if (rc)\n                goto balance_cleanup;\n            abDone[iPg]++;\n            apNew[iPg]->nFree = usableSpace - szNew[iPg];\n            ((void)0);\n            ((void)0);\n        }\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (isRoot && pParent->nCell == 0 && pParent->hdrOffset <= apNew[0]->nFree) {\n        ((void)0);\n        rc = defragmentPage(apNew[0], -1);\n        ;\n        ((void)0);\n        copyNodeContent(apNew[0], pParent, &rc);\n        freePage(apNew[0], &rc);\n    } else if ((pBt->autoVacuum) && !leafCorrection) {\n        for (i = 0; i < nNew; i++) {\n            u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);\n            ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);\n        }\n    }\n    ((void)0);\n    ;\n    for (i = nNew; i < nOld; i++) {\n        freePage(apOld[i], &rc);\n    }\n  balance_cleanup:\n    sqlite3DbFree(0, b.apCell);\n    for (i = 0; i < nOld; i++) {\n        releasePage(apOld[i]);\n    }\n    for (i = 0; i < nNew; i++) {\n        releasePage(apNew[i]);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#116756:1#detachFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    const char *zName = (const char *)sqlite3_value_text(argv[0]);\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int i;\n    Db *pDb = 0;\n    HashElem *pEntry;\n    char zErr[128];\n    (void)(NotUsed);\n    if (zName == 0)\n        zName = \"\";\n    for (i = 0; i < db->nDb; i++) {\n        pDb = &db->aDb[i];\n        if (pDb->pBt == 0)\n            continue;\n        if (sqlite3DbIsNamed(db, i, zName))\n            break;\n    }\n    if (i >= db->nDb) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"no such database: %s\", zName);\n        goto detach_error;\n    }\n    if (i < 2) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"cannot detach database %s\", zName);\n        goto detach_error;\n    }\n    if (sqlite3BtreeTxnState(pDb->pBt) != 0 || sqlite3BtreeIsInBackup(pDb->pBt)) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"database %s is locked\", zName);\n        goto detach_error;\n    }\n    ((void)0);\n    pEntry = ((&db->aDb[1].pSchema->trigHash)->first);\n    while (pEntry)\n        {\n            Trigger *pTrig = (Trigger *)((pEntry)->data);\n            if (pTrig->pTabSchema == pDb->pSchema) {\n                pTrig->pTabSchema = pTrig->pSchema;\n            }\n            pEntry = ((pEntry)->next);\n        }\n    sqlite3BtreeClose(pDb->pBt);\n    pDb->pBt = 0;\n    pDb->pSchema = 0;\n    sqlite3CollapseDatabaseArray(db);\n    return;\n  detach_error:\n    sqlite3_result_error(context, zErr, -1);\n}\n"
  },
  {
    "id": "sqlite3.c#75878:1#editPage",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    u8 *const aData = pPg->aData;\n    const int hdr = pPg->hdrOffset;\n    u8 *pBegin = &pPg->aCellIdx[nNew * 2];\n    int nCell = pPg->nCell;\n    u8 *pData;\n    u8 *pCellptr;\n    int i;\n    int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;\n    int iNewEnd = iNew + nNew;\n    ((void)0);\n    if (iOld < iNew) {\n        int nShift = pageFreeArray(pPg, iOld, iNew - iOld, pCArray);\n        if ((nShift > nCell))\n            return sqlite3CorruptError(75904);\n        __builtin___memmove_chk(pPg->aCellIdx, &pPg->aCellIdx[nShift * 2], nCell * 2, __builtin_object_size(pPg->aCellIdx, 0));\n        nCell -= nShift;\n    }\n    if (iNewEnd < iOldEnd) {\n        int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);\n        ((void)0);\n        nCell -= nTail;\n    }\n    pData = &aData[(((((int)((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1])) - 1) & 65535) + 1)];\n    if (pData < pBegin)\n        goto editpage_fail;\n    if (pData > pPg->aDataEnd)\n        goto editpage_fail;\n    if (iNew < iOld) {\n        int nAdd = ((nNew) < (iOld - iNew) ? (nNew) : (iOld - iNew));\n        ((void)0);\n        ((void)0);\n        pCellptr = pPg->aCellIdx;\n        __builtin___memmove_chk(&pCellptr[nAdd * 2], pCellptr, nCell * 2, __builtin_object_size(&pCellptr[nAdd * 2], 0));\n        if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew, nAdd, pCArray))\n            goto editpage_fail;\n        nCell += nAdd;\n    }\n    for (i = 0; i < pPg->nOverflow; i++) {\n        int iCell = (iOld + pPg->aiOvfl[i]) - iNew;\n        if (iCell >= 0 && iCell < nNew) {\n            pCellptr = &pPg->aCellIdx[iCell * 2];\n            if (nCell > iCell) {\n                __builtin___memmove_chk(&pCellptr[2], pCellptr, (nCell - iCell) * 2, __builtin_object_size(&pCellptr[2], 0));\n            }\n            nCell++;\n            cachedCellSize(pCArray, iCell + iNew);\n            if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iCell + iNew, 1, pCArray))\n                goto editpage_fail;\n        }\n    }\n    ((void)0);\n    pCellptr = &pPg->aCellIdx[nCell * 2];\n    if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew + nCell, nNew - nCell, pCArray))\n        goto editpage_fail;\n    pPg->nCell = nNew;\n    pPg->nOverflow = 0;\n    ((&aData[hdr + 3])[0] = (u8)((pPg->nCell) >> 8) , (&aData[hdr + 3])[1] = (u8)(pPg->nCell));\n    ((&aData[hdr + 5])[0] = (u8)((pData - aData) >> 8) , (&aData[hdr + 5])[1] = (u8)(pData - aData));\n    return 0;\n  editpage_fail:\n    populateCellCache(pCArray, iNew, nNew);\n    return rebuildPage(pCArray, iNew, nNew, pPg);\n}\n"
  },
  {
    "id": "sqlite3.c#74943:1#freePage2",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    MemPage *pTrunk = 0;\n    Pgno iTrunk = 0;\n    MemPage *pPage1 = pBt->pPage1;\n    MemPage *pPage;\n    int rc;\n    u32 nFree;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (iPage < 2 || iPage > pBt->nPage) {\n        return sqlite3CorruptError(74956);\n    }\n    if (pMemPage) {\n        pPage = pMemPage;\n        sqlite3PagerRef(pPage->pDbPage);\n    } else {\n        pPage = btreePageLookup(pBt, iPage);\n    }\n    rc = sqlite3PagerWrite(pPage1->pDbPage);\n    if (rc)\n        goto freepage_out;\n    nFree = sqlite3Get4byte(&pPage1->aData[36]);\n    sqlite3Put4byte(&pPage1->aData[36], nFree + 1);\n    if (pBt->btsFlags & 4) {\n        if ((!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0)) || ((rc = sqlite3PagerWrite(pPage->pDbPage)) != 0)) {\n            goto freepage_out;\n        }\n        __builtin___memset_chk(pPage->aData, 0, pPage->pBt->pageSize, __builtin_object_size(pPage->aData, 0));\n    }\n    if ((pBt->autoVacuum)) {\n        ptrmapPut(pBt, iPage, 2, 0, &rc);\n        if (rc)\n            goto freepage_out;\n    }\n    if (nFree != 0) {\n        u32 nLeaf;\n        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n        if (iTrunk > btreePagecount(pBt)) {\n            rc = sqlite3CorruptError(75003);\n            goto freepage_out;\n        }\n        rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);\n        if (rc != 0) {\n            goto freepage_out;\n        }\n        nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);\n        ((void)0);\n        if (nLeaf > (u32)pBt->usableSize / 4 - 2) {\n            rc = sqlite3CorruptError(75014);\n            goto freepage_out;\n        }\n        if (nLeaf < (u32)pBt->usableSize / 4 - 8) {\n            rc = sqlite3PagerWrite(pTrunk->pDbPage);\n            if (rc == 0) {\n                sqlite3Put4byte(&pTrunk->aData[4], nLeaf + 1);\n                sqlite3Put4byte(&pTrunk->aData[8 + nLeaf * 4], iPage);\n                if (pPage && (pBt->btsFlags & 4) == 0) {\n                    sqlite3PagerDontWrite(pPage->pDbPage);\n                }\n                rc = btreeSetHasContent(pBt, iPage);\n            }\n            ;\n            goto freepage_out;\n        }\n    }\n    if (pPage == 0 && 0 != (rc = btreeGetPage(pBt, iPage, &pPage, 0))) {\n        goto freepage_out;\n    }\n    rc = sqlite3PagerWrite(pPage->pDbPage);\n    if (rc != 0) {\n        goto freepage_out;\n    }\n    sqlite3Put4byte(pPage->aData, iTrunk);\n    sqlite3Put4byte(&pPage->aData[4], 0);\n    sqlite3Put4byte(&pPage1->aData[32], iPage);\n    ;\n  freepage_out:\n    if (pPage) {\n        pPage->isInit = 0;\n    }\n    releasePage(pPage);\n    releasePage(pTrunk);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#74621:1#allocateBtreePage",
    "gotos": 11,
    "labels": 1,
    "body": "{\n    MemPage *pPage1;\n    int rc;\n    u32 n;\n    u32 k;\n    MemPage *pTrunk = 0;\n    MemPage *pPrevTrunk = 0;\n    Pgno mxPage;\n    ((void)0);\n    ((void)0);\n    pPage1 = pBt->pPage1;\n    mxPage = btreePagecount(pBt);\n    n = sqlite3Get4byte(&pPage1->aData[36]);\n    ;\n    if (n >= mxPage) {\n        return sqlite3CorruptError(74645);\n    }\n    if (n > 0) {\n        Pgno iTrunk;\n        u8 searchList = 0;\n        u32 nSearch = 0;\n        if (eMode == 1) {\n            if (nearby <= mxPage) {\n                u8 eType;\n                ((void)0);\n                ((void)0);\n                rc = ptrmapGet(pBt, nearby, &eType, 0);\n                if (rc)\n                    return rc;\n                if (eType == 2) {\n                    searchList = 1;\n                }\n            }\n        } else if (eMode == 2) {\n            searchList = 1;\n        }\n        rc = sqlite3PagerWrite(pPage1->pDbPage);\n        if (rc)\n            return rc;\n        sqlite3Put4byte(&pPage1->aData[36], n - 1);\n        do {\n            pPrevTrunk = pTrunk;\n            if (pPrevTrunk) {\n                iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);\n            } else {\n                iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n            }\n            ;\n            if (iTrunk > mxPage || nSearch++ > n) {\n                rc = sqlite3CorruptError(74701);\n            } else {\n                rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);\n            }\n            if (rc) {\n                pTrunk = 0;\n                goto end_allocate_page;\n            }\n            ((void)0);\n            ((void)0);\n            k = sqlite3Get4byte(&pTrunk->aData[4]);\n            if (k == 0 && !searchList) {\n                ((void)0);\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                *pPgno = iTrunk;\n                __builtin___memcpy_chk(&pPage1->aData[32], &pTrunk->aData[0], 4, __builtin_object_size(&pPage1->aData[32], 0));\n                *ppPage = pTrunk;\n                pTrunk = 0;\n                ;\n            } else if (k > (u32)(pBt->usableSize / 4 - 2)) {\n                rc = sqlite3CorruptError(74730);\n                goto end_allocate_page;\n            } else if (searchList && (nearby == iTrunk || (iTrunk < nearby && eMode == 2))) {\n                *pPgno = iTrunk;\n                *ppPage = pTrunk;\n                searchList = 0;\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                if (k == 0) {\n                    if (!pPrevTrunk) {\n                        __builtin___memcpy_chk(&pPage1->aData[32], &pTrunk->aData[0], 4, __builtin_object_size(&pPage1->aData[32], 0));\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc != 0) {\n                            goto end_allocate_page;\n                        }\n                        __builtin___memcpy_chk(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4, __builtin_object_size(&pPrevTrunk->aData[0], 0));\n                    }\n                } else {\n                    MemPage *pNewTrunk;\n                    Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);\n                    if (iNewTrunk > mxPage) {\n                        rc = sqlite3CorruptError(74764);\n                        goto end_allocate_page;\n                    }\n                    ;\n                    rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);\n                    if (rc != 0) {\n                        goto end_allocate_page;\n                    }\n                    rc = sqlite3PagerWrite(pNewTrunk->pDbPage);\n                    if (rc != 0) {\n                        releasePage(pNewTrunk);\n                        goto end_allocate_page;\n                    }\n                    __builtin___memcpy_chk(&pNewTrunk->aData[0], &pTrunk->aData[0], 4, __builtin_object_size(&pNewTrunk->aData[0], 0));\n                    sqlite3Put4byte(&pNewTrunk->aData[4], k - 1);\n                    __builtin___memcpy_chk(&pNewTrunk->aData[8], &pTrunk->aData[12], (k - 1) * 4, __builtin_object_size(&pNewTrunk->aData[8], 0));\n                    releasePage(pNewTrunk);\n                    if (!pPrevTrunk) {\n                        ((void)0);\n                        sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc) {\n                            goto end_allocate_page;\n                        }\n                        sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);\n                    }\n                }\n                pTrunk = 0;\n                ;\n            } else if (k > 0) {\n                u32 closest;\n                Pgno iPage;\n                unsigned char *aData = pTrunk->aData;\n                if (nearby > 0) {\n                    u32 i;\n                    closest = 0;\n                    if (eMode == 2) {\n                        for (i = 0; i < k; i++) {\n                            iPage = sqlite3Get4byte(&aData[8 + i * 4]);\n                            if (iPage <= nearby) {\n                                closest = i;\n                                break;\n                            }\n                        }\n                    } else {\n                        int dist;\n                        dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);\n                        for (i = 1; i < k; i++) {\n                            int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8 + i * 4]) - nearby);\n                            if (d2 < dist) {\n                                closest = i;\n                                dist = d2;\n                            }\n                        }\n                    }\n                } else {\n                    closest = 0;\n                }\n                iPage = sqlite3Get4byte(&aData[8 + closest * 4]);\n                ;\n                if (iPage > mxPage || iPage < 2) {\n                    rc = sqlite3CorruptError(74829);\n                    goto end_allocate_page;\n                }\n                ;\n                if (!searchList || (iPage == nearby || (iPage < nearby && eMode == 2))) {\n                    int noContent;\n                    *pPgno = iPage;\n                    ;\n                    rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                    if (rc)\n                        goto end_allocate_page;\n                    if (closest < k - 1) {\n                        __builtin___memcpy_chk(&aData[8 + closest * 4], &aData[4 + k * 4], 4, __builtin_object_size(&aData[8 + closest * 4], 0));\n                    }\n                    sqlite3Put4byte(&aData[4], k - 1);\n                    noContent = !btreeGetHasContent(pBt, *pPgno) ? 1 : 0;\n                    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);\n                    if (rc == 0) {\n                        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n                        if (rc != 0) {\n                            releasePage(*ppPage);\n                            *ppPage = 0;\n                        }\n                    }\n                    searchList = 0;\n                }\n            }\n            releasePage(pPrevTrunk);\n            pPrevTrunk = 0;\n        } while (searchList);\n    } else {\n        int bNoContent = (0 == (pBt->bDoTruncate)) ? 1 : 0;\n        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\n        if (rc)\n            return rc;\n        pBt->nPage++;\n        if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))\n            pBt->nPage++;\n        if (pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage)) == (pBt->nPage))) {\n            MemPage *pPg = 0;\n            ;\n            ((void)0);\n            rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);\n            if (rc == 0) {\n                rc = sqlite3PagerWrite(pPg->pDbPage);\n                releasePage(pPg);\n            }\n            if (rc)\n                return rc;\n            pBt->nPage++;\n            if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1))) {\n                pBt->nPage++;\n            }\n        }\n        sqlite3Put4byte(28 + (u8 *)pBt->pPage1->aData, pBt->nPage);\n        *pPgno = pBt->nPage;\n        ((void)0);\n        rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);\n        if (rc)\n            return rc;\n        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n        if (rc != 0) {\n            releasePage(*ppPage);\n            *ppPage = 0;\n        }\n        ;\n    }\n    ((void)0);\n  end_allocate_page:\n    releasePage(pTrunk);\n    releasePage(pPrevTrunk);\n    ((void)0);\n    ((void)0);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeIndexMoveto",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    int rc;\n    RecordCompare xRecordCompare;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);\n    pIdxKey->errCode = 0;\n    ((void)0);\n    if (pCur->eState == 0 && pCur->pPage->leaf && cursorOnLastPage(pCur)) {\n        int c;\n        if (pCur->ix == pCur->pPage->nCell - 1 && (c = indexCellCompare(pCur, pCur->ix, pIdxKey, xRecordCompare)) <= 0 && pIdxKey->errCode == 0) {\n            *pRes = c;\n            return 0;\n        }\n        if (pCur->iPage > 0 && indexCellCompare(pCur, 0, pIdxKey, xRecordCompare) <= 0 && pIdxKey->errCode == 0) {\n            pCur->curFlags &= ~4;\n            if (!pCur->pPage->isInit) {\n                return sqlite3CorruptError(74230);\n            }\n            goto bypass_moveto_root;\n        }\n        pIdxKey->errCode = 0;\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            ((void)0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n  bypass_moveto_root:\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        ((void)0);\n        ((void)0);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        idx = upr >> 1;\n        for (;;) {\n            int nCell;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            nCell = pCell[0];\n            if (nCell <= pPage->max1bytePayload) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[1], pIdxKey);\n            } else if (!(pCell[1] & 128) && (nCell = ((nCell & 127) << 7) + pCell[1]) <= pPage->maxLocal) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[2], pIdxKey);\n            } else {\n                void *pCellKey;\n                u8 *const pCellBody = pCell - pPage->childPtrSize;\n                const int nOverrun = 18;\n                pPage->xParseCell(pPage, pCellBody, &pCur->info);\n                nCell = (int)pCur->info.nKey;\n                ;\n                ;\n                ;\n                ;\n                if (nCell < 2 || nCell / pCur->pBt->usableSize > pCur->pBt->nPage) {\n                    rc = sqlite3CorruptError(74317);\n                    goto moveto_index_finish;\n                }\n                pCellKey = sqlite3Malloc(nCell + nOverrun);\n                if (pCellKey == 0) {\n                    rc = 7;\n                    goto moveto_index_finish;\n                }\n                pCur->ix = (u16)idx;\n                rc = accessPayload(pCur, 0, nCell, (unsigned char *)pCellKey, 0);\n                __builtin___memset_chk(((u8 *)pCellKey) + nCell, 0, nOverrun, __builtin_object_size(((u8 *)pCellKey) + nCell, 0));\n                pCur->curFlags &= ~4;\n                if (rc) {\n                    sqlite3_free(pCellKey);\n                    goto moveto_index_finish;\n                }\n                c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n                sqlite3_free(pCellKey);\n            }\n            ((void)0);\n            if (c < 0) {\n                lwr = idx + 1;\n            } else if (c > 0) {\n                upr = idx - 1;\n            } else {\n                ((void)0);\n                *pRes = 0;\n                rc = 0;\n                pCur->ix = (u16)idx;\n                if (pIdxKey->errCode)\n                    rc = sqlite3CorruptError(74349);\n                goto moveto_index_finish;\n            }\n            if (lwr > upr)\n                break;\n            ((void)0);\n            idx = (lwr + upr) >> 1;\n        }\n        ((void)0);\n        ((void)0);\n        if (pPage->leaf) {\n            ((void)0);\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_index_finish;\n        }\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_index_finish:\n    pCur->info.nSize = 0;\n    ((void)0);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeTableMoveto",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    int rc;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pCur->eState == 0 && (pCur->curFlags & 2) != 0) {\n        if (pCur->info.nKey == intKey) {\n            *pRes = 0;\n            return 0;\n        }\n        if (pCur->info.nKey < intKey) {\n            if ((pCur->curFlags & 8) != 0) {\n                *pRes = -1;\n                return 0;\n            }\n            if (pCur->info.nKey + 1 == intKey) {\n                *pRes = 0;\n                rc = sqlite3BtreeNext(pCur, 0);\n                if (rc == 0) {\n                    getCellInfo(pCur);\n                    if (pCur->info.nKey == intKey) {\n                        return 0;\n                    }\n                } else if (rc != 101) {\n                    return rc;\n                }\n            }\n        }\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            ((void)0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        ((void)0);\n        ((void)0);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        ((void)0);\n        idx = upr >> (1 - biasRight);\n        for (;;) {\n            i64 nCellKey;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            if (pPage->intKeyLeaf) {\n                while (128 <= *(pCell++))\n                    {\n                        if (pCell >= pPage->aDataEnd) {\n                            return sqlite3CorruptError(74034);\n                        }\n                    }\n            }\n            sqlite3GetVarint(pCell, (u64 *)&nCellKey);\n            if (nCellKey < intKey) {\n                lwr = idx + 1;\n                if (lwr > upr) {\n                    c = -1;\n                    break;\n                }\n            } else if (nCellKey > intKey) {\n                upr = idx - 1;\n                if (lwr > upr) {\n                    c = +1;\n                    break;\n                }\n            } else {\n                ((void)0);\n                pCur->ix = (u16)idx;\n                if (!pPage->leaf) {\n                    lwr = idx;\n                    goto moveto_table_next_layer;\n                } else {\n                    pCur->curFlags |= 2;\n                    pCur->info.nKey = nCellKey;\n                    pCur->info.nSize = 0;\n                    *pRes = 0;\n                    return 0;\n                }\n            }\n            ((void)0);\n            idx = (lwr + upr) >> 1;\n        }\n        ((void)0);\n        ((void)0);\n        if (pPage->leaf) {\n            ((void)0);\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_table_finish;\n        }\n      moveto_table_next_layer:\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_table_finish:\n    pCur->info.nSize = 0;\n    ((void)0);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#44213:1#proxyTakeConch",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if (pCtx->conchHeld != 0) {\n        return 0;\n    } else {\n        unixFile *conchFile = pCtx->conchFile;\n        uuid_t myHostID;\n        int pError = 0;\n        char readBuf[1041];\n        char lockPath[1024];\n        char *tempLockPath = ((void *)0);\n        int rc = 0;\n        int createConch = 0;\n        int hostIdMatch = 0;\n        int readLen = 0;\n        int tryOldLockPath = 0;\n        int forceNewLockPath = 0;\n        ;\n        rc = proxyGetHostID(myHostID, &pError);\n        if ((rc & 255) == 10) {\n            storeLastErrno(pFile, pError);\n            goto end_takeconch;\n        }\n        rc = proxyConchLock(pFile, myHostID, 1);\n        if (rc != 0) {\n            goto end_takeconch;\n        }\n        readLen = seekAndRead((unixFile *)conchFile, 0, readBuf, (1 + 16 + 1024));\n        if (readLen < 0) {\n            storeLastErrno(pFile, conchFile->lastErrno);\n            rc = (10 | (1 << 8));\n            goto end_takeconch;\n        } else if (readLen <= (1 + 16) || readBuf[0] != (char)2) {\n            createConch = 1;\n        }\n        do {\n            if (!createConch && !forceNewLockPath) {\n                hostIdMatch = !memcmp(&readBuf[1], myHostID, 16);\n                if (!pCtx->lockProxyPath) {\n                    if (hostIdMatch) {\n                        size_t pathLen = (readLen - (1 + 16));\n                        if (pathLen >= 1024) {\n                            pathLen = 1024 - 1;\n                        }\n                        __builtin___memcpy_chk(lockPath, &readBuf[(1 + 16)], pathLen, __builtin_object_size(lockPath, 0));\n                        lockPath[pathLen] = 0;\n                        tempLockPath = lockPath;\n                        tryOldLockPath = 1;\n                        goto end_takeconch;\n                    }\n                } else if (hostIdMatch && !strncmp(pCtx->lockProxyPath, &readBuf[(1 + 16)], readLen - (1 + 16))) {\n                    goto end_takeconch;\n                }\n            }\n            if ((conchFile->openFlags & 2) == 0) {\n                rc = 5;\n                goto end_takeconch;\n            }\n            if (!pCtx->lockProxyPath) {\n                proxyGetLockPath(pCtx->dbPath, lockPath, 1024);\n                tempLockPath = lockPath;\n            }\n            futimes(conchFile->h, ((void *)0));\n            if (hostIdMatch && !createConch) {\n                if (conchFile->pInode && conchFile->pInode->nShared > 1) {\n                    rc = 5;\n                } else {\n                    rc = proxyConchLock(pFile, myHostID, 4);\n                }\n            } else {\n                rc = proxyConchLock(pFile, myHostID, 4);\n            }\n            if (rc == 0) {\n                char writeBuffer[1041];\n                int writeSize = 0;\n                writeBuffer[0] = (char)2;\n                __builtin___memcpy_chk(&writeBuffer[1], myHostID, 16, __builtin_object_size(&writeBuffer[1], 0));\n                if (pCtx->lockProxyPath != ((void *)0)) {\n                    __builtin___strlcpy_chk(&writeBuffer[(1 + 16)], pCtx->lockProxyPath, 1024, __builtin_object_size(&writeBuffer[(1 + 16)], 2 > 1 ? 1 : 0));\n                } else {\n                    __builtin___strlcpy_chk(&writeBuffer[(1 + 16)], tempLockPath, 1024, __builtin_object_size(&writeBuffer[(1 + 16)], 2 > 1 ? 1 : 0));\n                }\n                writeSize = (1 + 16) + strlen(&writeBuffer[(1 + 16)]);\n                robust_ftruncate(conchFile->h, writeSize);\n                rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);\n                full_fsync(conchFile->h, 0, 0);\n                if (rc == 0 && createConch) {\n                    struct stat buf;\n                    int err = ((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pFile->h, &buf);\n                    if (err == 0) {\n                        mode_t cmode = buf.st_mode & (256 | 128 | 32 | 16 | 4 | 2);\n                        ((int (*)(int, mode_t))aSyscall[14].pCurrent)(conchFile->h, cmode);\n                    }\n                }\n            }\n            conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 1);\n          end_takeconch:\n            ;\n            if (rc == 0 && pFile->openFlags) {\n                int fd;\n                if (pFile->h >= 0) {\n                    robust_close(pFile, pFile->h, 44378);\n                }\n                pFile->h = -1;\n                fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);\n                ;\n                if (fd >= 0) {\n                    pFile->h = fd;\n                } else {\n                    rc = sqlite3CantopenError(44386);\n                }\n            }\n            if (rc == 0 && !pCtx->lockProxy) {\n                char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;\n                rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);\n                if (rc != 0 && rc != 7 && tryOldLockPath) {\n                    forceNewLockPath = 1;\n                    tryOldLockPath = 0;\n                    continue;\n                }\n            }\n            if (rc == 0) {\n                if (tempLockPath) {\n                    pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);\n                    if (!pCtx->lockProxyPath) {\n                        rc = 7;\n                    }\n                }\n            }\n            if (rc == 0) {\n                pCtx->conchHeld = 1;\n                if (pCtx->lockProxy->pMethod == &afpIoMethods) {\n                    afpLockingContext *afpCtx;\n                    afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;\n                    afpCtx->dbPath = pCtx->lockProxyPath;\n                }\n            } else {\n                conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 0);\n            }\n            ;\n            return rc;\n        } while (1);\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#83133:1#resolveP2Values",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int nMaxArgs = *pMaxFuncArgs;\n    Op *pOp;\n    Parse *pParse = p->pParse;\n    int *aLabel = pParse->aLabel;\n    p->readOnly = 1;\n    p->bIsReader = 0;\n    pOp = &p->aOp[p->nOp - 1];\n    ((void)0);\n    while (1)\n        {\n            if (pOp->opcode <= 64) {\n                switch (pOp->opcode) {\n                  case 2:\n                    {\n                        if (pOp->p2 != 0)\n                            p->readOnly = 0;\n                    }\n                  case 1:\n                  case 0:\n                    {\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 3:\n                  case 5:\n                  case 4:\n                    {\n                        p->readOnly = 0;\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 8:\n                    {\n                        ((void)0);\n                        goto resolve_p2_values_loop_exit;\n                    }\n                  case 7:\n                    {\n                        if (pOp->p2 > nMaxArgs)\n                            nMaxArgs = pOp->p2;\n                        break;\n                    }\n                  case 6:\n                    {\n                        int n;\n                        ((void)0);\n                        ((void)0);\n                        n = pOp[-1].p1;\n                        if (n > nMaxArgs)\n                            nMaxArgs = n;\n                    }\n                  default:\n                    {\n                        if (pOp->p2 < 0) {\n                            ((void)0);\n                            ((void)0);\n                            pOp->p2 = aLabel[(~(pOp->p2))];\n                        }\n                        break;\n                    }\n                }\n                ((void)0);\n            }\n            ((void)0);\n            pOp--;\n        }\n  resolve_p2_values_loop_exit:\n    if (aLabel) {\n        sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n        pParse->aLabel = 0;\n    }\n    pParse->nLabel = 0;\n    *pMaxFuncArgs = nMaxArgs;\n    ((void)0);\n}\n"
  },
  {
    "id": "sqlite3.c#39819:1#afpLock",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode = pFile->pInode;\n    afpLockingContext *context = (afpLockingContext *)pFile->lockingContext;\n    ((void)0);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        int failed;\n        failed = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 1);\n        if (failed) {\n            rc = failed;\n            goto afp_end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        int lrc1, lrc2, lrc1Errno = 0;\n        long lk, mask;\n        ((void)0);\n        ((void)0);\n        mask = (sizeof(long) == 8) ? (4294967295U | (((i64)2147483647) << 32)) : 2147483647;\n        lk = random();\n        pInode->sharedByte = (lk & mask) % (510 - 1);\n        lrc1 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            lrc1Errno = pFile->lastErrno;\n        }\n        lrc2 = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 0);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            storeLastErrno(pFile, lrc1Errno);\n            rc = lrc1;\n            goto afp_end_lock;\n        } else if (((lrc2 != 0) && (lrc2 != 5))) {\n            rc = lrc2;\n            goto afp_end_lock;\n        } else if (lrc1 != 0) {\n            rc = lrc1;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        int failed = 0;\n        ((void)0);\n        if (eFileLock >= 2 && pFile->eFileLock < 2) {\n            failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 1), 1, 1);\n            if (!failed) {\n                context->reserved = 1;\n            }\n        }\n        if (!failed && eFileLock == 4) {\n            if (!(failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 0))) {\n                int failed2 = 0;\n                failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2), 510, 1);\n                if (failed && (failed2 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1))) {\n                    rc = ((failed & 255) == 10) ? failed2 : (10 | (15 << 8));\n                    goto afp_end_lock;\n                }\n            } else {\n                rc = failed;\n            }\n        }\n        if (failed) {\n            rc = failed;\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  afp_end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerOpen",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u8 *pPtr;\n    Pager *pPager = 0;\n    int rc = 0;\n    int tempFile = 0;\n    int memDb = 0;\n    int memJM = 0;\n    int readOnly = 0;\n    int journalFileSize;\n    char *zPathname = 0;\n    int nPathname = 0;\n    int useJournal = (flags & 1) == 0;\n    int pcacheSize = sqlite3PcacheSize();\n    u32 szPageDflt = 4096;\n    const char *zUri = 0;\n    int nUriByte = 1;\n    int nUri = 0;\n    journalFileSize = (((sqlite3JournalSize(pVfs)) + 7) & ~7);\n    *ppPager = 0;\n    if (flags & 2) {\n        memDb = 1;\n        if (zFilename && zFilename[0]) {\n            zPathname = sqlite3DbStrDup(0, zFilename);\n            if (zPathname == 0)\n                return 7;\n            nPathname = sqlite3Strlen30(zPathname);\n            zFilename = 0;\n        }\n    }\n    if (zFilename && zFilename[0]) {\n        const char *z;\n        nPathname = pVfs->mxPathname + 1;\n        zPathname = sqlite3DbMallocRaw(0, nPathname * 2);\n        if (zPathname == 0) {\n            return 7;\n        }\n        zPathname[0] = 0;\n        rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);\n        if (rc != 0) {\n            if (rc == (0 | (2 << 8))) {\n                if (vfsFlags & 16777216) {\n                    rc = (14 | (6 << 8));\n                } else {\n                    rc = 0;\n                }\n            }\n        }\n        nPathname = sqlite3Strlen30(zPathname);\n        z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];\n        while (*z)\n            {\n                z += strlen(z) + 1;\n                z += strlen(z) + 1;\n                nUri++;\n            }\n        nUriByte = (int)(&z[1] - zUri);\n        ((void)0);\n        if (rc == 0 && nPathname + 8 > pVfs->mxPathname) {\n            rc = sqlite3CantopenError(60181);\n        }\n        if (rc != 0) {\n            sqlite3DbFree(0, zPathname);\n            return rc;\n        }\n    }\n    pPtr = (u8 *)sqlite3MallocZero((((sizeof (*pPager)) + 7) & ~7) + (((pcacheSize) + 7) & ~7) + (((pVfs->szOsFile) + 7) & ~7) + journalFileSize * 2 + sizeof (pPager) + 4 + nPathname + 1 + nUriByte + nPathname + 8 + 1 + nPathname + 4 + 1 + 3);\n    ((void)0);\n    if (!pPtr) {\n        sqlite3DbFree(0, zPathname);\n        return 7;\n    }\n    pPager = (Pager *)pPtr;\n    pPtr += (((sizeof (*pPager)) + 7) & ~7);\n    pPager->pPCache = (PCache *)pPtr;\n    pPtr += (((pcacheSize) + 7) & ~7);\n    pPager->fd = (sqlite3_file *)pPtr;\n    pPtr += (((pVfs->szOsFile) + 7) & ~7);\n    pPager->sjfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    pPager->jfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    ((void)0);\n    __builtin___memcpy_chk(pPtr, &pPager, sizeof (pPager), __builtin_object_size(pPtr, 0));\n    pPtr += sizeof (pPager);\n    pPtr += 4;\n    pPager->zFilename = (char *)pPtr;\n    if (nPathname > 0) {\n        __builtin___memcpy_chk(pPtr, zPathname, nPathname, __builtin_object_size(pPtr, 0));\n        pPtr += nPathname + 1;\n        if (zUri) {\n            __builtin___memcpy_chk(pPtr, zUri, nUriByte, __builtin_object_size(pPtr, 0));\n            pPtr += nUriByte;\n        } else {\n            pPtr++;\n        }\n    }\n    if (nPathname > 0) {\n        pPager->zJournal = (char *)pPtr;\n        __builtin___memcpy_chk(pPtr, zPathname, nPathname, __builtin_object_size(pPtr, 0));\n        pPtr += nPathname;\n        __builtin___memcpy_chk(pPtr, \"-journal\", 8, __builtin_object_size(pPtr, 0));\n        pPtr += 8 + 1;\n    } else {\n        pPager->zJournal = 0;\n    }\n    if (nPathname > 0) {\n        pPager->zWal = (char *)pPtr;\n        __builtin___memcpy_chk(pPtr, zPathname, nPathname, __builtin_object_size(pPtr, 0));\n        pPtr += nPathname;\n        __builtin___memcpy_chk(pPtr, \"-wal\", 4, __builtin_object_size(pPtr, 0));\n        pPtr += 4 + 1;\n    } else {\n        pPager->zWal = 0;\n    }\n    (void)pPtr;\n    if (nPathname)\n        sqlite3DbFree(0, zPathname);\n    pPager->pVfs = pVfs;\n    pPager->vfsFlags = vfsFlags;\n    if (zFilename && zFilename[0]) {\n        int fout = 0;\n        rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);\n        ((void)0);\n        pPager->memVfs = memJM = (fout & 128) != 0;\n        readOnly = (fout & 1) != 0;\n        if (rc == 0) {\n            int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n            if (!readOnly) {\n                setSectorSize(pPager);\n                ((void)0);\n                if (szPageDflt < pPager->sectorSize) {\n                    if (pPager->sectorSize > 8192) {\n                        szPageDflt = 8192;\n                    } else {\n                        szPageDflt = (u32)pPager->sectorSize;\n                    }\n                }\n            }\n            pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, \"nolock\", 0);\n            if ((iDc & 8192) != 0 || sqlite3_uri_boolean(pPager->zFilename, \"immutable\", 0)) {\n                vfsFlags |= 1;\n                goto act_like_temp_file;\n            }\n        }\n    } else {\n      act_like_temp_file:\n        tempFile = 1;\n        pPager->eState = 1;\n        pPager->eLock = 4;\n        pPager->noLock = 1;\n        readOnly = (vfsFlags & 1);\n    }\n    if (rc == 0) {\n        ((void)0);\n        rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);\n        ;\n    }\n    if (rc == 0) {\n        nExtra = (((nExtra) + 7) & ~7);\n        ((void)0);\n        rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb, !memDb ? pagerStress : 0, (void *)pPager, pPager->pPCache);\n    }\n    if (rc != 0) {\n        sqlite3OsClose(pPager->fd);\n        sqlite3PageFree(pPager->pTmpSpace);\n        sqlite3_free(pPager);\n        return rc;\n    }\n    ;\n    pPager->useJournal = (u8)useJournal;\n    pPager->mxPgno = 1073741823;\n    pPager->tempFile = (u8)tempFile;\n    ((void)0);\n    ((void)0);\n    pPager->exclusiveMode = (u8)tempFile;\n    pPager->changeCountDone = pPager->tempFile;\n    pPager->memDb = (u8)memDb;\n    pPager->readOnly = (u8)readOnly;\n    ((void)0);\n    pPager->noSync = pPager->tempFile;\n    if (pPager->noSync) {\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        ((void)0);\n    } else {\n        pPager->fullSync = 1;\n        pPager->extraSync = 0;\n        pPager->syncFlags = 2;\n        pPager->walSyncFlags = 2 | (2 << 2);\n    }\n    pPager->nExtra = (u16)nExtra;\n    pPager->journalSizeLimit = -1;\n    ((void)0);\n    setSectorSize(pPager);\n    if (!useJournal) {\n        pPager->journalMode = 2;\n    } else if (memDb || memJM) {\n        pPager->journalMode = 4;\n    }\n    pPager->xReiniter = xReinit;\n    setGetterMethod(pPager);\n    *ppPager = pPager;\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeOpen",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    BtShared *pBt = 0;\n    Btree *p;\n    sqlite3_mutex *mutexOpen = 0;\n    int rc = 0;\n    u8 nReserve;\n    unsigned char zDbHeader[100];\n    const int isTempDb = zFilename == 0 || zFilename[0] == 0;\n    const int isMemdb = (zFilename && strcmp(zFilename, \":memory:\") == 0) || (isTempDb && sqlite3TempInMemory(db)) || (vfsFlags & 128) != 0;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (isMemdb) {\n        flags |= 2;\n    }\n    if ((vfsFlags & 256) != 0 && (isMemdb || isTempDb)) {\n        vfsFlags = (vfsFlags & ~256) | 512;\n    }\n    p = sqlite3MallocZero(sizeof(Btree));\n    if (!p) {\n        return 7;\n    }\n    p->inTrans = 0;\n    p->db = db;\n    p->lock.pBtree = p;\n    p->lock.iTable = 1;\n    if (isTempDb == 0 && (isMemdb == 0 || (vfsFlags & 64) != 0)) {\n        if (vfsFlags & 131072) {\n            int nFilename = sqlite3Strlen30(zFilename) + 1;\n            int nFullPathname = pVfs->mxPathname + 1;\n            char *zFullPathname = sqlite3Malloc(((nFullPathname) > (nFilename) ? (nFullPathname) : (nFilename)));\n            sqlite3_mutex *mutexShared;\n            p->sharable = 1;\n            if (!zFullPathname) {\n                sqlite3_free(p);\n                return 7;\n            }\n            if (isMemdb) {\n                __builtin___memcpy_chk(zFullPathname, zFilename, nFilename, __builtin_object_size(zFullPathname, 0));\n            } else {\n                rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);\n                if (rc) {\n                    if (rc == (0 | (2 << 8))) {\n                        rc = 0;\n                    } else {\n                        sqlite3_free(zFullPathname);\n                        sqlite3_free(p);\n                        return rc;\n                    }\n                }\n            }\n            mutexOpen = sqlite3MutexAlloc(4);\n            sqlite3_mutex_enter(mutexOpen);\n            mutexShared = sqlite3MutexAlloc(2);\n            sqlite3_mutex_enter(mutexShared);\n            for (pBt = sqlite3SharedCacheList; pBt; pBt = pBt->pNext) {\n                ((void)0);\n                if (0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0)) && sqlite3PagerVfs(pBt->pPager) == pVfs) {\n                    int iDb;\n                    for (iDb = db->nDb - 1; iDb >= 0; iDb--) {\n                        Btree *pExisting = db->aDb[iDb].pBt;\n                        if (pExisting && pExisting->pBt == pBt) {\n                            sqlite3_mutex_leave(mutexShared);\n                            sqlite3_mutex_leave(mutexOpen);\n                            sqlite3_free(zFullPathname);\n                            sqlite3_free(p);\n                            return 19;\n                        }\n                    }\n                    p->pBt = pBt;\n                    pBt->nRef++;\n                    break;\n                }\n            }\n            sqlite3_mutex_leave(mutexShared);\n            sqlite3_free(zFullPathname);\n        }\n    }\n    if (pBt == 0) {\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pBt = sqlite3MallocZero(sizeof (*pBt));\n        if (pBt == 0) {\n            rc = 7;\n            goto btree_open_out;\n        }\n        rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename, sizeof(MemPage), flags, vfsFlags, pageReinit);\n        if (rc == 0) {\n            sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);\n            rc = sqlite3PagerReadFileheader(pBt->pPager, sizeof (zDbHeader), zDbHeader);\n        }\n        if (rc != 0) {\n            goto btree_open_out;\n        }\n        pBt->openFlags = (u8)flags;\n        pBt->db = db;\n        sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);\n        p->pBt = pBt;\n        pBt->pCursor = 0;\n        pBt->pPage1 = 0;\n        if (sqlite3PagerIsreadonly(pBt->pPager))\n            pBt->btsFlags |= 1;\n        pBt->pageSize = (zDbHeader[16] << 8) | (zDbHeader[17] << 16);\n        if (pBt->pageSize < 512 || pBt->pageSize > 65536 || ((pBt->pageSize - 1) & pBt->pageSize) != 0) {\n            pBt->pageSize = 0;\n            if (zFilename && !isMemdb) {\n                pBt->autoVacuum = (0 ? 1 : 0);\n                pBt->incrVacuum = (0 == 2 ? 1 : 0);\n            }\n            nReserve = 0;\n        } else {\n            nReserve = zDbHeader[20];\n            pBt->btsFlags |= 2;\n            pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4 * 4]) ? 1 : 0);\n            pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7 * 4]) ? 1 : 0);\n        }\n        rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);\n        if (rc)\n            goto btree_open_out;\n        pBt->usableSize = pBt->pageSize - nReserve;\n        ((void)0);\n        pBt->nRef = 1;\n        if (p->sharable) {\n            sqlite3_mutex *mutexShared;\n            mutexShared = sqlite3MutexAlloc(2);\n            if (1 && sqlite3Config.bCoreMutex) {\n                pBt->mutex = sqlite3MutexAlloc(0);\n                if (pBt->mutex == 0) {\n                    rc = 7;\n                    goto btree_open_out;\n                }\n            }\n            sqlite3_mutex_enter(mutexShared);\n            pBt->pNext = sqlite3SharedCacheList;\n            sqlite3SharedCacheList = pBt;\n            sqlite3_mutex_leave(mutexShared);\n        }\n    }\n    if (p->sharable) {\n        int i;\n        Btree *pSib;\n        for (i = 0; i < db->nDb; i++) {\n            if ((pSib = db->aDb[i].pBt) != 0 && pSib->sharable) {\n                while (pSib->pPrev)\n                    {\n                        pSib = pSib->pPrev;\n                    }\n                if ((uptr)p->pBt < (uptr)pSib->pBt) {\n                    p->pNext = pSib;\n                    p->pPrev = 0;\n                    pSib->pPrev = p;\n                } else {\n                    while (pSib->pNext && (uptr)pSib->pNext->pBt < (uptr)p->pBt)\n                        {\n                            pSib = pSib->pNext;\n                        }\n                    p->pNext = pSib->pNext;\n                    p->pPrev = pSib;\n                    if (p->pNext) {\n                        p->pNext->pPrev = p;\n                    }\n                    pSib->pNext = p;\n                }\n                break;\n            }\n        }\n    }\n    *ppBtree = p;\n  btree_open_out:\n    if (rc != 0) {\n        if (pBt && pBt->pPager) {\n            sqlite3PagerClose(pBt->pPager, 0);\n        }\n        sqlite3_free(pBt);\n        sqlite3_free(p);\n        *ppBtree = 0;\n    } else {\n        sqlite3_file *pFile;\n        if (sqlite3BtreeSchema(p, 0, 0) == 0) {\n            sqlite3BtreeSetCacheSize(p, -2000);\n        }\n        pFile = sqlite3PagerFile(pBt->pPager);\n        if (pFile->pMethods) {\n            sqlite3OsFileControlHint(pFile, 30, (void *)&pBt->db);\n        }\n    }\n    if (mutexOpen) {\n        ((void)0);\n        sqlite3_mutex_leave(mutexOpen);\n    }\n    ((void)0);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#71554:1#lockBtree",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int rc;\n    MemPage *pPage1;\n    u32 nPage;\n    u32 nPageFile = 0;\n    ((void)0);\n    ((void)0);\n    rc = sqlite3PagerSharedLock(pBt->pPager);\n    if (rc != 0)\n        return rc;\n    rc = btreeGetPage(pBt, 1, &pPage1, 0);\n    if (rc != 0)\n        return rc;\n    nPage = sqlite3Get4byte(28 + (u8 *)pPage1->aData);\n    sqlite3PagerPagecount(pBt->pPager, (int *)&nPageFile);\n    if (nPage == 0 || memcmp(24 + (u8 *)pPage1->aData, 92 + (u8 *)pPage1->aData, 4) != 0) {\n        nPage = nPageFile;\n    }\n    if ((pBt->db->flags & 33554432) != 0) {\n        nPage = 0;\n    }\n    if (nPage > 0) {\n        u32 pageSize;\n        u32 usableSize;\n        u8 *page1 = pPage1->aData;\n        rc = 26;\n        if (memcmp(page1, zMagicHeader, 16) != 0) {\n            goto page1_init_failed;\n        }\n        if (page1[18] > 2) {\n            pBt->btsFlags |= 1;\n        }\n        if (page1[19] > 2) {\n            goto page1_init_failed;\n        }\n        if (page1[19] == 2 && (pBt->btsFlags & 32) == 0) {\n            int isOpen = 0;\n            rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);\n            if (rc != 0) {\n                goto page1_init_failed;\n            } else {\n                ;\n                if (isOpen == 0) {\n                    releasePageOne(pPage1);\n                    return 0;\n                }\n            }\n            rc = 26;\n        } else {\n            ;\n        }\n        if (memcmp(&page1[21], \"@  \", 3) != 0) {\n            goto page1_init_failed;\n        }\n        pageSize = (page1[16] << 8) | (page1[17] << 16);\n        if (((pageSize - 1) & pageSize) != 0 || pageSize > 65536 || pageSize <= 256) {\n            goto page1_init_failed;\n        }\n        pBt->btsFlags |= 2;\n        ((void)0);\n        usableSize = pageSize - page1[20];\n        if ((u32)pageSize != pBt->pageSize) {\n            releasePageOne(pPage1);\n            pBt->usableSize = usableSize;\n            pBt->pageSize = pageSize;\n            freeTempSpace(pBt);\n            rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, pageSize - usableSize);\n            return rc;\n        }\n        if (nPage > nPageFile) {\n            if (sqlite3WritableSchema(pBt->db) == 0) {\n                rc = sqlite3CorruptError(71679);\n                goto page1_init_failed;\n            } else {\n                nPage = nPageFile;\n            }\n        }\n        if (usableSize < 480) {\n            goto page1_init_failed;\n        }\n        pBt->pageSize = pageSize;\n        pBt->usableSize = usableSize;\n        pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4 * 4]) ? 1 : 0);\n        pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7 * 4]) ? 1 : 0);\n    }\n    pBt->maxLocal = (u16)((pBt->usableSize - 12) * 64 / 255 - 23);\n    pBt->minLocal = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    pBt->maxLeaf = (u16)(pBt->usableSize - 35);\n    pBt->minLeaf = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    if (pBt->maxLocal > 127) {\n        pBt->max1bytePayload = 127;\n    } else {\n        pBt->max1bytePayload = (u8)pBt->maxLocal;\n    }\n    ((void)0);\n    pBt->pPage1 = pPage1;\n    pBt->nPage = nPage;\n    return 0;\n  page1_init_failed:\n    releasePageOne(pPage1);\n    pBt->pPage1 = 0;\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#70642:1#getAndInitPage",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    int rc;\n    DbPage *pDbPage;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pgno > btreePagecount(pBt)) {\n        rc = sqlite3CorruptError(70657);\n        goto getAndInitPage_error1;\n    }\n    rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage **)&pDbPage, bReadOnly);\n    if (rc) {\n        goto getAndInitPage_error1;\n    }\n    *ppPage = (MemPage *)sqlite3PagerGetExtra(pDbPage);\n    if ((*ppPage)->isInit == 0) {\n        btreePageFromDbPage(pDbPage, pgno, pBt);\n        rc = btreeInitPage(*ppPage);\n        if (rc != 0) {\n            goto getAndInitPage_error2;\n        }\n    }\n    ((void)0);\n    ((void)0);\n    if (pCur && ((*ppPage)->nCell < 1 || (*ppPage)->intKey != pCur->curIntKey)) {\n        rc = sqlite3CorruptError(70678);\n        goto getAndInitPage_error2;\n    }\n    return 0;\n  getAndInitPage_error2:\n    releasePage(*ppPage);\n  getAndInitPage_error1:\n    if (pCur) {\n        pCur->iPage--;\n        pCur->pPage = pCur->apPage[pCur->iPage];\n    }\n    ;\n    ((void)0);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#69372:1#ptrmapPut",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    DbPage *pDbPage;\n    u8 *pPtrmap;\n    Pgno iPtrmap;\n    int offset;\n    int rc;\n    if (*pRC)\n        return;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (key == 0) {\n        *pRC = sqlite3CorruptError(69387);\n        return;\n    }\n    iPtrmap = ptrmapPageno(pBt, key);\n    rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);\n    if (rc != 0) {\n        *pRC = rc;\n        return;\n    }\n    if (((char *)sqlite3PagerGetExtra(pDbPage))[0] != 0) {\n        *pRC = sqlite3CorruptError(69400);\n        goto ptrmap_exit;\n    }\n    offset = (5 * (key - iPtrmap - 1));\n    if (offset < 0) {\n        *pRC = sqlite3CorruptError(69405);\n        goto ptrmap_exit;\n    }\n    ((void)0);\n    pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);\n    if (eType != pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset + 1]) != parent) {\n        ;\n        *pRC = rc = sqlite3PagerWrite(pDbPage);\n        if (rc == 0) {\n            pPtrmap[offset] = eType;\n            sqlite3Put4byte(&pPtrmap[offset + 1], parent);\n        }\n    }\n  ptrmap_exit:\n    sqlite3PagerUnref(pDbPage);\n}\n"
  },
  {
    "id": "sqlite3.c#116818:1#codeAttach",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int rc;\n    NameContext sName;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int regArgs;\n    if (0 != sqlite3ReadSchema(pParse))\n        goto attach_end;\n    if (pParse->nErr)\n        goto attach_end;\n    __builtin___memset_chk(&sName, 0, sizeof(NameContext), __builtin_object_size(&sName, 0));\n    sName.pParse = pParse;\n    if (0 != resolveAttachExpr(&sName, pFilename) || 0 != resolveAttachExpr(&sName, pDbname) || 0 != resolveAttachExpr(&sName, pKey)) {\n        goto attach_end;\n    }\n    if ((pAuthArg)) {\n        char *zAuthArg;\n        if (pAuthArg->op == 117) {\n            ((void)0);\n            zAuthArg = pAuthArg->u.zToken;\n        } else {\n            zAuthArg = 0;\n        }\n        rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n        if (rc != 0) {\n            goto attach_end;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    regArgs = sqlite3GetTempRange(pParse, 4);\n    sqlite3ExprCode(pParse, pFilename, regArgs);\n    sqlite3ExprCode(pParse, pDbname, regArgs + 1);\n    sqlite3ExprCode(pParse, pKey, regArgs + 2);\n    ((void)0);\n    if (v) {\n        sqlite3VdbeAddFunctionCall(pParse, 0, regArgs + 3 - pFunc->nArg, regArgs + 3, pFunc->nArg, pFunc, 0);\n        sqlite3VdbeAddOp1(v, 166, (type == 24));\n    }\n  attach_end:\n    sqlite3ExprDelete(db, pFilename);\n    sqlite3ExprDelete(db, pDbname);\n    sqlite3ExprDelete(db, pKey);\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateIndex",
    "gotos": 28,
    "labels": 1,
    "body": "{\n    Table *pTab = 0;\n    Index *pIndex = 0;\n    char *zName = 0;\n    int nName;\n    int i, j;\n    DbFixer sFix;\n    int sortOrderMask;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    int iDb;\n    Token *pName = 0;\n    struct ExprList_item *pListItem;\n    int nExtra = 0;\n    int nExtraCol;\n    char *zExtra = 0;\n    Index *pPk = 0;\n    ((void)0);\n    if (pParse->nErr) {\n        goto exit_create_index;\n    }\n    ((void)0);\n    if ((pParse->eParseMode == 1) && idxType != 2) {\n        goto exit_create_index;\n    }\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_create_index;\n    }\n    if (sqlite3HasExplicitNulls(pParse, pList)) {\n        goto exit_create_index;\n    }\n    if (pTblName != 0) {\n        ((void)0);\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            goto exit_create_index;\n        ((void)0);\n        if (!db->init.busy) {\n            pTab = sqlite3SrcListLookup(pParse, pTblName);\n            if (pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n                iDb = 1;\n            }\n        }\n        sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName);\n        if (sqlite3FixSrcList(&sFix, pTblName)) {\n            ((void)0);\n        }\n        pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);\n        ((void)0);\n        if (pTab == 0)\n            goto exit_create_index;\n        if (iDb == 1 && db->aDb[iDb].pSchema != pTab->pSchema) {\n            sqlite3ErrorMsg(pParse, \"cannot create a TEMP index on non-TEMP table \\\"%s\\\"\", pTab->zName);\n            goto exit_create_index;\n        }\n        if (!(((pTab)->tabFlags & 128) == 0))\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n    } else {\n        ((void)0);\n        ((void)0);\n        pTab = pParse->pNewTable;\n        if (!pTab)\n            goto exit_create_index;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    }\n    pDb = &db->aDb[iDb];\n    ((void)0);\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0 && db->init.busy == 0 && pTblName != 0) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n        goto exit_create_index;\n    }\n    if (pName) {\n        zName = sqlite3NameFromToken(db, pName);\n        if (zName == 0)\n            goto exit_create_index;\n        ((void)0);\n        if (0 != sqlite3CheckObjectName(pParse, zName, \"index\", pTab->zName)) {\n            goto exit_create_index;\n        }\n        if (!(pParse->eParseMode >= 2)) {\n            if (!db->init.busy) {\n                if (sqlite3FindTable(db, zName, pDb->zDbSName) != 0) {\n                    sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n                    goto exit_create_index;\n                }\n            }\n            if (sqlite3FindIndex(db, zName, pDb->zDbSName) != 0) {\n                if (!ifNotExist) {\n                    sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n                } else {\n                    ((void)0);\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3ForceNotReadOnly(pParse);\n                }\n                goto exit_create_index;\n            }\n        }\n    } else {\n        int n;\n        Index *pLoop;\n        for (pLoop = pTab->pIndex , n = 1; pLoop; pLoop = pLoop->pNext , n++) {\n        }\n        zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n        if (zName == 0) {\n            goto exit_create_index;\n        }\n        if ((pParse->eParseMode != 0))\n            zName[7]++;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        const char *zDb = pDb->zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto exit_create_index;\n        }\n        i = 1;\n        if (!0 && iDb == 1)\n            i = 3;\n        if (sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb)) {\n            goto exit_create_index;\n        }\n    }\n    if (pList == 0) {\n        Token prevCol;\n        Column *pCol = &pTab->aCol[pTab->nCol - 1];\n        pCol->colFlags |= 8;\n        sqlite3TokenInit(&prevCol, pCol->zCnName);\n        pList = sqlite3ExprListAppend(pParse, 0, sqlite3ExprAlloc(db, 59, &prevCol, 0));\n        if (pList == 0)\n            goto exit_create_index;\n        ((void)0);\n        sqlite3ExprListSetSortOrder(pList, sortOrder, -1);\n    } else {\n        sqlite3ExprListCheckLength(pParse, pList, \"index\");\n        if (pParse->nErr)\n            goto exit_create_index;\n    }\n    for (i = 0; i < pList->nExpr; i++) {\n        Expr *pExpr = pList->a[i].pExpr;\n        ((void)0);\n        if (pExpr->op == 113) {\n            ((void)0);\n            nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));\n        }\n    }\n    nName = sqlite3Strlen30(zName);\n    nExtraCol = pPk ? pPk->nKeyCol : 1;\n    ((void)0);\n    pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol, nName + nExtra + 1, &zExtra);\n    if (db->mallocFailed) {\n        goto exit_create_index;\n    }\n    ((void)0);\n    ((void)0);\n    pIndex->zName = zExtra;\n    zExtra += nName + 1;\n    __builtin___memcpy_chk(pIndex->zName, zName, nName + 1, __builtin_object_size(pIndex->zName, 0));\n    pIndex->pTable = pTab;\n    pIndex->onError = (u8)onError;\n    pIndex->uniqNotNull = onError != 0;\n    pIndex->idxType = idxType;\n    pIndex->pSchema = db->aDb[iDb].pSchema;\n    pIndex->nKeyCol = pList->nExpr;\n    if (pPIWhere) {\n        sqlite3ResolveSelfReference(pParse, pTab, 2, pPIWhere, 0);\n        pIndex->pPartIdxWhere = pPIWhere;\n        pPIWhere = 0;\n    }\n    ((void)0);\n    if (pDb->pSchema->file_format >= 4) {\n        sortOrderMask = -1;\n    } else {\n        sortOrderMask = 0;\n    }\n    pListItem = pList->a;\n    if ((pParse->eParseMode >= 2)) {\n        pIndex->aColExpr = pList;\n        pList = 0;\n    }\n    for (i = 0; i < pIndex->nKeyCol; i++ , pListItem++) {\n        Expr *pCExpr;\n        int requestedSortOrder;\n        const char *zColl;\n        sqlite3StringToId(pListItem->pExpr);\n        sqlite3ResolveSelfReference(pParse, pTab, 32, pListItem->pExpr, 0);\n        if (pParse->nErr)\n            goto exit_create_index;\n        pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);\n        if (pCExpr->op != 167) {\n            if (pTab == pParse->pNewTable) {\n                sqlite3ErrorMsg(pParse, \"expressions prohibited in PRIMARY KEY and UNIQUE constraints\");\n                goto exit_create_index;\n            }\n            if (pIndex->aColExpr == 0) {\n                pIndex->aColExpr = pList;\n                pList = 0;\n            }\n            j = (-2);\n            pIndex->aiColumn[i] = (-2);\n            pIndex->uniqNotNull = 0;\n            pIndex->bHasExpr = 1;\n        } else {\n            j = pCExpr->iColumn;\n            ((void)0);\n            if (j < 0) {\n                j = pTab->iPKey;\n            } else {\n                if (pTab->aCol[j].notNull == 0) {\n                    pIndex->uniqNotNull = 0;\n                }\n                if (pTab->aCol[j].colFlags & 32) {\n                    pIndex->bHasVCol = 1;\n                    pIndex->bHasExpr = 1;\n                }\n            }\n            pIndex->aiColumn[i] = (i16)j;\n        }\n        zColl = 0;\n        if (pListItem->pExpr->op == 113) {\n            int nColl;\n            ((void)0);\n            zColl = pListItem->pExpr->u.zToken;\n            nColl = sqlite3Strlen30(zColl) + 1;\n            ((void)0);\n            __builtin___memcpy_chk(zExtra, zColl, nColl, __builtin_object_size(zExtra, 0));\n            zColl = zExtra;\n            zExtra += nColl;\n            nExtra -= nColl;\n        } else if (j >= 0) {\n            zColl = sqlite3ColumnColl(&pTab->aCol[j]);\n        }\n        if (!zColl)\n            zColl = sqlite3StrBINARY;\n        if (!db->init.busy && !sqlite3LocateCollSeq(pParse, zColl)) {\n            goto exit_create_index;\n        }\n        pIndex->azColl[i] = zColl;\n        requestedSortOrder = pListItem->fg.sortFlags & sortOrderMask;\n        pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n    }\n    if (pPk) {\n        for (j = 0; j < pPk->nKeyCol; j++) {\n            int x = pPk->aiColumn[j];\n            ((void)0);\n            if (isDupColumn(pIndex, pIndex->nKeyCol, pPk, j)) {\n                pIndex->nColumn--;\n            } else {\n                ;\n                pIndex->aiColumn[i] = x;\n                pIndex->azColl[i] = pPk->azColl[j];\n                pIndex->aSortOrder[i] = pPk->aSortOrder[j];\n                i++;\n            }\n        }\n        ((void)0);\n    } else {\n        pIndex->aiColumn[i] = (-1);\n        pIndex->azColl[i] = sqlite3StrBINARY;\n    }\n    sqlite3DefaultRowEst(pIndex);\n    if (pParse->pNewTable == 0)\n        estimateIndexWidth(pIndex);\n    ((void)0);\n    recomputeColumnsNotIndexed(pIndex);\n    if (pTblName != 0 && pIndex->nColumn >= pTab->nCol) {\n        pIndex->isCovering = 1;\n        for (j = 0; j < pTab->nCol; j++) {\n            if (j == pTab->iPKey)\n                continue;\n            if (sqlite3TableColumnToIndex(pIndex, j) >= 0)\n                continue;\n            pIndex->isCovering = 0;\n            break;\n        }\n    }\n    if (pTab == pParse->pNewTable) {\n        Index *pIdx;\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            int k;\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            if (pIdx->nKeyCol != pIndex->nKeyCol)\n                continue;\n            for (k = 0; k < pIdx->nKeyCol; k++) {\n                const char *z1;\n                const char *z2;\n                ((void)0);\n                if (pIdx->aiColumn[k] != pIndex->aiColumn[k])\n                    break;\n                z1 = pIdx->azColl[k];\n                z2 = pIndex->azColl[k];\n                if (sqlite3StrICmp(z1, z2))\n                    break;\n            }\n            if (k == pIdx->nKeyCol) {\n                if (pIdx->onError != pIndex->onError) {\n                    if (!(pIdx->onError == 11 || pIndex->onError == 11)) {\n                        sqlite3ErrorMsg(pParse, \"conflicting ON CONFLICT clauses specified\", 0);\n                    }\n                    if (pIdx->onError == 11) {\n                        pIdx->onError = pIndex->onError;\n                    }\n                }\n                if (idxType == 2)\n                    pIdx->idxType = idxType;\n                if ((pParse->eParseMode >= 2)) {\n                    pIndex->pNext = pParse->pNewIndex;\n                    pParse->pNewIndex = pIndex;\n                    pIndex = 0;\n                }\n                goto exit_create_index;\n            }\n        }\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        ((void)0);\n        if (db->init.busy) {\n            Index *p;\n            ((void)0);\n            ((void)0);\n            if (pTblName != 0) {\n                pIndex->tnum = db->init.newTnum;\n                if (sqlite3IndexHasDuplicateRootPage(pIndex)) {\n                    sqlite3ErrorMsg(pParse, \"invalid rootpage\");\n                    pParse->rc = sqlite3CorruptError(121736);\n                    goto exit_create_index;\n                }\n            }\n            p = sqlite3HashInsert(&pIndex->pSchema->idxHash, pIndex->zName, pIndex);\n            if (p) {\n                ((void)0);\n                sqlite3OomFault(db);\n                goto exit_create_index;\n            }\n            db->mDbFlags |= 1;\n        } else if ((((pTab)->tabFlags & 128) == 0) || pTblName != 0) {\n            Vdbe *v;\n            char *zStmt;\n            int iMem = ++pParse->nMem;\n            v = sqlite3GetVdbe(pParse);\n            if (v == 0)\n                goto exit_create_index;\n            sqlite3BeginWriteOperation(pParse, 1, iDb);\n            pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, 184);\n            sqlite3VdbeAddOp3(v, 147, iDb, iMem, 2);\n            ((void)0);\n            if (pStart) {\n                int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;\n                if (pName->z[n - 1] == ';')\n                    n--;\n                zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\", onError == 0 ? \"\" : \" UNIQUE\", n, pName->z);\n            } else {\n                zStmt = 0;\n            }\n            sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);\", db->aDb[iDb].zDbSName, pIndex->zName, pTab->zName, iMem, zStmt);\n            sqlite3DbFree(db, zStmt);\n            if (pTblName) {\n                sqlite3RefillIndex(pParse, pIndex, iMem);\n                sqlite3ChangeCookie(pParse, iDb);\n                sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName), 0);\n                sqlite3VdbeAddOp2(v, 166, 0, 1);\n            }\n            sqlite3VdbeJumpHere(v, (int)pIndex->tnum);\n        }\n    }\n    if (db->init.busy || pTblName == 0) {\n        pIndex->pNext = pTab->pIndex;\n        pTab->pIndex = pIndex;\n        pIndex = 0;\n    } else if ((pParse->eParseMode >= 2)) {\n        ((void)0);\n        pParse->pNewIndex = pIndex;\n        pIndex = 0;\n    }\n  exit_create_index:\n    if (pIndex)\n        sqlite3FreeIndex(db, pIndex);\n    if (pTab) {\n        Index **ppFrom;\n        Index *pThis;\n        for (ppFrom = &pTab->pIndex; (pThis = *ppFrom) != 0; ppFrom = &pThis->pNext) {\n            Index *pNext;\n            if (pThis->onError != 5)\n                continue;\n            while ((pNext = pThis->pNext) != 0 && pNext->onError != 5)\n                {\n                    *ppFrom = pNext;\n                    pThis->pNext = pNext->pNext;\n                    pNext->pNext = pThis;\n                    ppFrom = &pNext->pNext;\n                }\n            break;\n        }\n    }\n    sqlite3ExprDelete(db, pPIWhere);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3SrcListDelete(db, pTblName);\n    sqlite3DbFree(db, zName);\n}\n"
  },
  {
    "id": "sqlite3.c#65684:1#walBeginShmUnreliable",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    i64 szWal;\n    i64 iOffset;\n    u8 aBuf[32];\n    u8 *aFrame = 0;\n    int szFrame;\n    u8 *aData;\n    volatile void *pDummy;\n    int rc;\n    u32 aSaveCksum[2];\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    rc = walLockShared(pWal, (3 + (0)));\n    if (rc != 0) {\n        if (rc == 5)\n            rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    pWal->readLock = 0;\n    rc = sqlite3OsShmMap(pWal->pDbFd, 0, (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)), 0, &pDummy);\n    ((void)0);\n    if (rc != (8 | (5 << 8))) {\n        rc = (rc == 8 ? (-1) : rc);\n        goto begin_unreliable_shm_out;\n    }\n    __builtin___memcpy_chk(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr), __builtin_object_size(&pWal->hdr, 0));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (szWal < 32) {\n        *pChanged = 1;\n        rc = (pWal->hdr.mxFrame == 0 ? 0 : (-1));\n        goto begin_unreliable_shm_out;\n    }\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (memcmp(&pWal->hdr.aSalt, &aBuf[16], 8)) {\n        rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    ((void)0);\n    ((void)0);\n    szFrame = pWal->szPage + 24;\n    aFrame = (u8 *)sqlite3_malloc64(szFrame);\n    if (aFrame == 0) {\n        rc = 7;\n        goto begin_unreliable_shm_out;\n    }\n    aData = &aFrame[24];\n    aSaveCksum[0] = pWal->hdr.aFrameCksum[0];\n    aSaveCksum[1] = pWal->hdr.aFrameCksum[1];\n    for (iOffset = (32 + ((pWal->hdr.mxFrame + 1) - 1) * (i64)((pWal->szPage) + 24)); iOffset + szFrame <= szWal; iOffset += szFrame) {\n        u32 pgno;\n        u32 nTruncate;\n        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n        if (rc != 0)\n            break;\n        if (!walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame))\n            break;\n        if (nTruncate) {\n            rc = (-1);\n            break;\n        }\n    }\n    pWal->hdr.aFrameCksum[0] = aSaveCksum[0];\n    pWal->hdr.aFrameCksum[1] = aSaveCksum[1];\n  begin_unreliable_shm_out:\n    sqlite3_free(aFrame);\n    if (rc != 0) {\n        int i;\n        for (i = 0; i < pWal->nWiData; i++) {\n            sqlite3_free((void *)pWal->apWiData[i]);\n            pWal->apWiData[i] = 0;\n        }\n        pWal->bShmUnreliable = 0;\n        sqlite3WalEndReadTransaction(pWal);\n        *pChanged = 1;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#198721:1#jsonAppendString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u32 i;\n    if (zIn == 0 || ((N + p->nUsed + 2 >= p->nAlloc) && jsonGrow(p, N + 2) != 0))\n        return;\n    p->zBuf[p->nUsed++] = '\"';\n    for (i = 0; i < N; i++) {\n        unsigned char c = ((const unsigned char *)zIn)[i];\n        if (c == '\"' || c == '\\\\') {\n          json_simple_escape:\n            if ((p->nUsed + N + 3 - i > p->nAlloc) && jsonGrow(p, N + 3 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n        } else if (c <= 31) {\n            static const char aSpecial[] = {0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            if (aSpecial[c]) {\n                c = aSpecial[c];\n                goto json_simple_escape;\n            }\n            if ((p->nUsed + N + 7 + i > p->nAlloc) && jsonGrow(p, N + 7 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n            p->zBuf[p->nUsed++] = 'u';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0' + (c >> 4);\n            c = \"0123456789abcdef\"[c & 15];\n        }\n        p->zBuf[p->nUsed++] = c;\n    }\n    p->zBuf[p->nUsed++] = '\"';\n    ((void)0);\n}\n"
  },
  {
    "id": "sqlite3.c#43938:1#proxyCreateUnixFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int fd = -1;\n    unixFile *pNew;\n    int rc = 0;\n    int openFlags = 2 | 512 | 256;\n    sqlite3_vfs dummyVfs;\n    int terrno = 0;\n    UnixUnusedFd *pUnused = ((void *)0);\n    pUnused = findReusableFd(path, openFlags);\n    if (pUnused) {\n        fd = pUnused->fd;\n    } else {\n        pUnused = sqlite3_malloc64(sizeof (*pUnused));\n        if (!pUnused) {\n            return 7;\n        }\n    }\n    if (fd < 0) {\n        fd = robust_open(path, openFlags, 0);\n        terrno = (*__error());\n        if (fd < 0 && (*__error()) == 2 && islockfile) {\n            if (proxyCreateLockPath(path) == 0) {\n                fd = robust_open(path, openFlags, 0);\n            }\n        }\n    }\n    if (fd < 0) {\n        openFlags = 0 | 256;\n        fd = robust_open(path, openFlags, 0);\n        terrno = (*__error());\n    }\n    if (fd < 0) {\n        if (islockfile) {\n            return 5;\n        }\n        switch (terrno) {\n          case 13:\n            return 3;\n          case 5:\n            return (10 | (15 << 8));\n          default:\n            return sqlite3CantopenError(43990);\n        }\n    }\n    pNew = (unixFile *)sqlite3_malloc64(sizeof (*pNew));\n    if (pNew == ((void *)0)) {\n        rc = 7;\n        goto end_create_proxy;\n    }\n    __builtin___memset_chk(pNew, 0, sizeof(unixFile), __builtin_object_size(pNew, 0));\n    pNew->openFlags = openFlags;\n    __builtin___memset_chk(&dummyVfs, 0, sizeof (dummyVfs), __builtin_object_size(&dummyVfs, 0));\n    dummyVfs.pAppData = (void *)&autolockIoFinder;\n    dummyVfs.zName = \"dummy\";\n    pUnused->fd = fd;\n    pUnused->flags = openFlags;\n    pNew->pPreallocatedUnused = pUnused;\n    rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file *)pNew, path, 0);\n    if (rc == 0) {\n        *ppFile = pNew;\n        return 0;\n    }\n  end_create_proxy:\n    robust_close(pNew, fd, 44014);\n    sqlite3_free(pNew);\n    sqlite3_free(pUnused);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterBeginAddColumn",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    Table *pNew;\n    Table *pTab;\n    int iDb;\n    int i;\n    int nAlloc;\n    sqlite3 *db = pParse->db;\n    ((void)0);\n    ((void)0);\n    if (db->mallocFailed)\n        goto exit_begin_add_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_begin_add_column;\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n        goto exit_begin_add_column;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n        goto exit_begin_add_column;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_begin_add_column;\n    }\n    sqlite3MayAbort(pParse);\n    ((void)0);\n    ((void)0);\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    pNew = (Table *)sqlite3DbMallocZero(db, sizeof(Table));\n    if (!pNew)\n        goto exit_begin_add_column;\n    pParse->pNewTable = pNew;\n    pNew->nTabRef = 1;\n    pNew->nCol = pTab->nCol;\n    ((void)0);\n    nAlloc = (((pNew->nCol - 1) / 8) * 8) + 8;\n    ((void)0);\n    pNew->aCol = (Column *)sqlite3DbMallocZero(db, sizeof(Column) * nAlloc);\n    pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n    if (!pNew->aCol || !pNew->zName) {\n        ((void)0);\n        goto exit_begin_add_column;\n    }\n    __builtin___memcpy_chk(pNew->aCol, pTab->aCol, sizeof(Column) * pNew->nCol, __builtin_object_size(pNew->aCol, 0));\n    for (i = 0; i < pNew->nCol; i++) {\n        Column *pCol = &pNew->aCol[i];\n        pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);\n        pCol->hName = sqlite3StrIHash(pCol->zCnName);\n    }\n    ((void)0);\n    pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);\n    pNew->pSchema = db->aDb[iDb].pSchema;\n    pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;\n    pNew->nTabRef = 1;\n  exit_begin_add_column:\n    sqlite3SrcListDelete(db, pSrc);\n    return;\n}\n"
  },
  {
    "id": "sqlite3.c#65206:1#walCheckpoint",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    int szPage;\n    WalIterator *pIter = 0;\n    u32 iDbpage = 0;\n    u32 iFrame = 0;\n    u32 mxSafeFrame;\n    u32 mxPage;\n    int i;\n    volatile WalCkptInfo *pInfo;\n    szPage = walPagesize(pWal);\n    ;\n    ;\n    pInfo = walCkptInfo(pWal);\n    if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n        ((void)0);\n        mxSafeFrame = pWal->hdr.mxFrame;\n        mxPage = pWal->hdr.nPage;\n        for (i = 1; i < (8 - 3); i++) {\n            u32 y = __atomic_load_n((pInfo->aReadMark + i), 0);\n            if (mxSafeFrame > y) {\n                ((void)0);\n                rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (i)), 1);\n                if (rc == 0) {\n                    u32 iMark = (i == 1 ? mxSafeFrame : 4294967295U);\n                    __atomic_store_n((pInfo->aReadMark + i), (iMark), 0);\n                    walUnlockExclusive(pWal, (3 + (i)), 1);\n                } else if (rc == 5) {\n                    mxSafeFrame = y;\n                    xBusy = 0;\n                } else {\n                    goto walcheckpoint_out;\n                }\n            }\n        }\n        if (pInfo->nBackfill < mxSafeFrame) {\n            rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);\n            ((void)0);\n        }\n        if (pIter && (rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (0)), 1)) == 0) {\n            u32 nBackfill = pInfo->nBackfill;\n            pInfo->nBackfillAttempted = mxSafeFrame;\n            rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags) >> 2) & 3));\n            if (rc == 0) {\n                i64 nReq = ((i64)mxPage * szPage);\n                i64 nSize;\n                sqlite3OsFileControl(pWal->pDbFd, 39, 0);\n                rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n                if (rc == 0 && nSize < nReq) {\n                    if ((nSize + 65536 + (i64)pWal->hdr.mxFrame * szPage) < nReq) {\n                        rc = sqlite3CorruptError(65290);\n                    } else {\n                        sqlite3OsFileControlHint(pWal->pDbFd, 5, &nReq);\n                    }\n                }\n            }\n            while (rc == 0 && 0 == walIteratorNext(pIter, &iDbpage, &iFrame))\n                {\n                    i64 iOffset;\n                    ((void)0);\n                    if (__atomic_load_n((&db->u1.isInterrupted), 0)) {\n                        rc = db->mallocFailed ? 7 : 9;\n                        break;\n                    }\n                    if (iFrame <= nBackfill || iFrame > mxSafeFrame || iDbpage > mxPage) {\n                        continue;\n                    }\n                    iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24)) + 24;\n                    rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                    iOffset = (iDbpage - 1) * (i64)szPage;\n                    ;\n                    rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                }\n            sqlite3OsFileControl(pWal->pDbFd, 37, 0);\n            if (rc == 0) {\n                if (mxSafeFrame == walIndexHdr(pWal)->mxFrame) {\n                    i64 szDb = pWal->hdr.nPage * (i64)szPage;\n                    ;\n                    rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n                    if (rc == 0) {\n                        rc = sqlite3OsSync(pWal->pDbFd, (((sync_flags) >> 2) & 3));\n                    }\n                }\n                if (rc == 0) {\n                    __atomic_store_n((&pInfo->nBackfill), (mxSafeFrame), 0);\n                }\n            }\n            walUnlockExclusive(pWal, (3 + (0)), 1);\n        }\n        if (rc == 5) {\n            rc = 0;\n        }\n    }\n    if (rc == 0 && eMode != 0) {\n        ((void)0);\n        if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n            rc = 5;\n        } else if (eMode >= 2) {\n            u32 salt1;\n            sqlite3_randomness(4, &salt1);\n            ((void)0);\n            rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (1)), (8 - 3) - 1);\n            if (rc == 0) {\n                if (eMode == 3) {\n                    walRestartHdr(pWal, salt1);\n                    rc = sqlite3OsTruncate(pWal->pWalFd, 0);\n                }\n                walUnlockExclusive(pWal, (3 + (1)), (8 - 3) - 1);\n            }\n        }\n    }\n  walcheckpoint_out:\n    walIteratorFree(pIter);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfTrue",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    ((void)0);\n    if ((v == 0))\n        return;\n    if ((pExpr == 0))\n        return;\n    ((void)0);\n    op = pExpr->op;\n    switch (op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n            } else if (op == 44) {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            } else {\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            } else {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (op == 45) ? 53 : 52;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = jumpIfNull ? dest : destIfFalse;\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeGoto(v, dest);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "sqlite3.c#64393:1#walIndexRecover",
    "gotos": 7,
    "labels": 2,
    "body": "{\n    int rc;\n    i64 nSize;\n    u32 aFrameCksum[2] = {0, 0};\n    int iLock;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    iLock = 1 + pWal->ckptLock;\n    rc = walLockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    if (rc) {\n        return rc;\n    }\n    ;\n    __builtin___memset_chk(&pWal->hdr, 0, sizeof(WalIndexHdr), __builtin_object_size(&pWal->hdr, 0));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n    if (rc != 0) {\n        goto recovery_error;\n    }\n    if (nSize > 32) {\n        u8 aBuf[32];\n        u32 *aPrivate = 0;\n        u8 *aFrame = 0;\n        int szFrame;\n        u8 *aData;\n        int szPage;\n        u32 magic;\n        u32 version;\n        int isValid;\n        u32 iPg;\n        u32 iLastFrame;\n        rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n        if (rc != 0) {\n            goto recovery_error;\n        }\n        magic = sqlite3Get4byte(&aBuf[0]);\n        szPage = sqlite3Get4byte(&aBuf[8]);\n        if ((magic & 4294967294U) != 931071618 || szPage & (szPage - 1) || szPage > 65536 || szPage < 512) {\n            goto finished;\n        }\n        pWal->hdr.bigEndCksum = (u8)(magic & 1);\n        pWal->szPage = szPage;\n        pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n        __builtin___memcpy_chk(&pWal->hdr.aSalt, &aBuf[16], 8, __builtin_object_size(&pWal->hdr.aSalt, 0));\n        walChecksumBytes(pWal->hdr.bigEndCksum == 0, aBuf, 32 - 2 * 4, 0, pWal->hdr.aFrameCksum);\n        if (pWal->hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24]) || pWal->hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])) {\n            goto finished;\n        }\n        version = sqlite3Get4byte(&aBuf[4]);\n        if (version != 3007000) {\n            rc = sqlite3CantopenError(64476);\n            goto finished;\n        }\n        szFrame = szPage + 24;\n        aFrame = (u8 *)sqlite3_malloc64(szFrame + (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)));\n        if (!aFrame) {\n            rc = 7;\n            goto recovery_error;\n        }\n        aData = &aFrame[24];\n        aPrivate = (u32 *)&aData[szPage];\n        iLastFrame = (nSize - 32) / szFrame;\n        for (iPg = 0; iPg <= (u32)walFramePage(iLastFrame); iPg++) {\n            u32 *aShare;\n            u32 iFrame;\n            u32 iLast = ((iLastFrame) < ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096));\n            u32 iFirst = 1 + (iPg == 0 ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + (iPg - 1) * 4096);\n            u32 nHdr, nHdr32;\n            rc = walIndexPage(pWal, iPg, (volatile u32 **)&aShare);\n            ((void)0);\n            if (aShare == 0)\n                break;\n            pWal->apWiData[iPg] = aPrivate;\n            for (iFrame = iFirst; iFrame <= iLast; iFrame++) {\n                i64 iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24));\n                u32 pgno;\n                u32 nTruncate;\n                rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n                if (rc != 0)\n                    break;\n                isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n                if (!isValid)\n                    break;\n                rc = walIndexAppend(pWal, iFrame, pgno);\n                if ((rc != 0))\n                    break;\n                if (nTruncate) {\n                    pWal->hdr.mxFrame = iFrame;\n                    pWal->hdr.nPage = nTruncate;\n                    pWal->hdr.szPage = (u16)((szPage & 65280) | (szPage >> 16));\n                    ;\n                    ;\n                    aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n                    aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n                }\n            }\n            pWal->apWiData[iPg] = aShare;\n            nHdr = (iPg == 0 ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);\n            nHdr32 = nHdr / sizeof(u32);\n            __builtin___memcpy_chk(&aShare[nHdr32], &aPrivate[nHdr32], (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)) - nHdr, __builtin_object_size(&aShare[nHdr32], 0));\n            if (iFrame <= iLast)\n                break;\n        }\n        sqlite3_free(aFrame);\n    }\n  finished:\n    if (rc == 0) {\n        volatile WalCkptInfo *pInfo;\n        int i;\n        pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n        pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n        walIndexWriteHdr(pWal);\n        pInfo = walCkptInfo(pWal);\n        pInfo->nBackfill = 0;\n        pInfo->nBackfillAttempted = pWal->hdr.mxFrame;\n        pInfo->aReadMark[0] = 0;\n        for (i = 1; i < (8 - 3); i++) {\n            rc = walLockExclusive(pWal, (3 + (i)), 1);\n            if (rc == 0) {\n                if (i == 1 && pWal->hdr.mxFrame) {\n                    pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n                } else {\n                    pInfo->aReadMark[i] = 4294967295U;\n                }\n                walUnlockExclusive(pWal, (3 + (i)), 1);\n            } else if (rc != 5) {\n                goto recovery_error;\n            }\n        }\n        if (pWal->hdr.nPage) {\n            sqlite3_log((27 | (1 << 8)), \"recovered %d frames from WAL file %s\", pWal->hdr.mxFrame, pWal->zWalName);\n        }\n    }\n  recovery_error:\n    ;\n    walUnlockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerCommitPhaseOne",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    ((void)0);\n    ((void)0);\n    if ((pPager->errCode))\n        return pPager->errCode;\n    if (sqlite3FaultSim(400))\n        return 10;\n    ;\n    if (pPager->eState < 3)\n        return 0;\n    ((void)0);\n    ((void)0);\n    if (0 == pagerFlushOnCommit(pPager, 1)) {\n        sqlite3BackupRestart(pPager->pBackup);\n    } else {\n        PgHdr *pList;\n        if (((pPager)->pWal != 0)) {\n            PgHdr *pPageOne = 0;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (pList == 0) {\n                rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);\n                pList = pPageOne;\n                pList->pDirty = 0;\n            }\n            ((void)0);\n            if ((pList)) {\n                rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);\n            }\n            sqlite3PagerUnref(pPageOne);\n            if (rc == 0) {\n                sqlite3PcacheCleanAll(pPager->pPCache);\n            }\n        } else {\n            rc = pager_incr_changecounter(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = writeSuperJournal(pPager, zSuper);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = syncJournal(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (0 == 0) {\n                rc = pager_write_pagelist(pPager, pList);\n            }\n            if (rc != 0) {\n                ((void)0);\n                goto commit_phase_one_exit;\n            }\n            sqlite3PcacheCleanAll(pPager->pPCache);\n            if (pPager->dbSize > pPager->dbFileSize) {\n                Pgno nNew = pPager->dbSize - (pPager->dbSize == ((pPager)->lckPgno));\n                ((void)0);\n                rc = pager_truncate(pPager, nNew);\n                if (rc != 0)\n                    goto commit_phase_one_exit;\n            }\n            if (!noSync) {\n                rc = sqlite3PagerSync(pPager, zSuper);\n            }\n        }\n    }\n  commit_phase_one_exit:\n    if (rc == 0 && !((pPager)->pWal != 0)) {\n        pPager->eState = 5;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#81883:1#valueFromExpr",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int op;\n    char *zVal = 0;\n    sqlite3_value *pVal = 0;\n    int negInt = 1;\n    const char *zNeg = \"\";\n    int rc = 0;\n    ((void)0);\n    while ((op = pExpr->op) == 174 || op == 181)\n        pExpr = pExpr->pLeft;\n    if (op == 176)\n        op = pExpr->op2;\n    ((void)0);\n    if (op == 36) {\n        u8 aff;\n        ((void)0);\n        aff = sqlite3AffinityType(pExpr->u.zToken, 0);\n        rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);\n        ;\n        if (*ppVal) {\n            sqlite3VdbeMemCast(*ppVal, aff, enc);\n            sqlite3ValueApplyAffinity(*ppVal, affinity, enc);\n        }\n        return rc;\n    }\n    if (op == 173 && (pExpr->pLeft->op == 155 || pExpr->pLeft->op == 153)) {\n        pExpr = pExpr->pLeft;\n        op = pExpr->op;\n        negInt = -1;\n        zNeg = \"-\";\n    }\n    if (op == 117 || op == 153 || op == 155) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        if ((((pExpr)->flags & (2048)) != 0)) {\n            sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue * negInt);\n        } else {\n            zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n            if (zVal == 0)\n                goto no_mem;\n            sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3OomClear));\n        }\n        if ((op == 155 || op == 153) && affinity == 65) {\n            sqlite3ValueApplyAffinity(pVal, 67, 1);\n        } else {\n            sqlite3ValueApplyAffinity(pVal, affinity, 1);\n        }\n        ((void)0);\n        if (pVal->flags & (4 | 32 | 8)) {\n            ;\n            ;\n            pVal->flags &= ~2;\n        }\n        if (enc != 1) {\n            rc = sqlite3VdbeChangeEncoding(pVal, enc);\n        }\n    } else if (op == 173) {\n        if (0 == valueFromExpr(db, pExpr->pLeft, enc, affinity, &pVal, pCtx) && pVal != 0) {\n            sqlite3VdbeMemNumerify(pVal);\n            if (pVal->flags & 8) {\n                pVal->u.r = -pVal->u.r;\n            } else if (pVal->u.i == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) {\n                pVal->u.r = -(double)(((i64)-1) - (4294967295U | (((i64)2147483647) << 32)));\n                ((pVal)->flags = ((pVal)->flags & ~(3519 | 1024)) | 8);\n            } else {\n                pVal->u.i = -pVal->u.i;\n            }\n            sqlite3ValueApplyAffinity(pVal, affinity, enc);\n        }\n    } else if (op == 121) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        sqlite3VdbeMemSetNull(pVal);\n    } else if (op == 154) {\n        int nVal;\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pVal = valueNew(db, pCtx);\n        if (!pVal)\n            goto no_mem;\n        zVal = &pExpr->u.zToken[2];\n        nVal = sqlite3Strlen30(zVal) - 1;\n        ((void)0);\n        sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal / 2, 0, ((sqlite3_destructor_type)sqlite3OomClear));\n    } else if (op == 170) {\n        ((void)0);\n        pVal = valueNew(db, pCtx);\n        if (pVal) {\n            pVal->flags = 4;\n            pVal->u.i = pExpr->u.zToken[4] == 0;\n        }\n    }\n    *ppVal = pVal;\n    return rc;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3DbFree(db, zVal);\n    ((void)0);\n    ((void)0);\n    sqlite3ValueFree(pVal);\n    return 7;\n}\n"
  },
  {
    "id": "sqlite3.c#99182:12#sqlite3_blob_open",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int nAttempt = 0;\n    int iCol;\n    int rc = 0;\n    char *zErr = 0;\n    Table *pTab;\n    Incrblob *pBlob = 0;\n    Parse sParse;\n    *ppBlob = 0;\n    wrFlag = !!wrFlag;\n    sqlite3_mutex_enter(db->mutex);\n    pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n    while (1)\n        {\n            sqlite3ParseObjectInit(&sParse, db);\n            if (!pBlob)\n                goto blob_open_out;\n            sqlite3DbFree(db, zErr);\n            zErr = 0;\n            sqlite3BtreeEnterAll(db);\n            pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);\n            if (pTab && ((pTab)->eTabType == 1)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open virtual table: %s\", zTable);\n            }\n            if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open table without rowid: %s\", zTable);\n            }\n            if (pTab && ((pTab)->eTabType == 2)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open view: %s\", zTable);\n            }\n            if (!pTab) {\n                if (sParse.zErrMsg) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sParse.zErrMsg;\n                    sParse.zErrMsg = 0;\n                }\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            pBlob->pTab = pTab;\n            pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;\n            for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                if (sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn) == 0) {\n                    break;\n                }\n            }\n            if (iCol == pTab->nCol) {\n                sqlite3DbFree(db, zErr);\n                zErr = sqlite3MPrintf(db, \"no such column: \\\"%s\\\"\", zColumn);\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            if (wrFlag) {\n                const char *zFault = 0;\n                Index *pIdx;\n                if (db->flags & 16384) {\n                    FKey *pFKey;\n                    ((void)0);\n                    for (pFKey = pTab->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                        int j;\n                        for (j = 0; j < pFKey->nCol; j++) {\n                            if (pFKey->aCol[j].iFrom == iCol) {\n                                zFault = \"foreign key\";\n                            }\n                        }\n                    }\n                }\n                for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    int j;\n                    for (j = 0; j < pIdx->nKeyCol; j++) {\n                        if (pIdx->aiColumn[j] == iCol || pIdx->aiColumn[j] == (-2)) {\n                            zFault = \"indexed\";\n                        }\n                    }\n                }\n                if (zFault) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sqlite3MPrintf(db, \"cannot open %s column for writing\", zFault);\n                    rc = 1;\n                    sqlite3BtreeLeaveAll(db);\n                    goto blob_open_out;\n                }\n            }\n            pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);\n            ((void)0);\n            if (pBlob->pStmt) {\n                static const int iLn = 0;\n                static const VdbeOpList openBlob[] = {{169, 0, 0, 0}, {112, 0, 0, 0}, {31, 0, 5, 1}, {94, 0, 0, 1}, {84, 1, 0, 0}, {70, 0, 0, 0}};\n                Vdbe *v = (Vdbe *)pBlob->pStmt;\n                int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                VdbeOp *aOp;\n                sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag, pTab->pSchema->schema_cookie, pTab->pSchema->iGeneration);\n                sqlite3VdbeChangeP5(v, 1);\n                ((void)0);\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (openBlob) / sizeof (openBlob[0]))), openBlob, iLn);\n                sqlite3VdbeUsesBtree(v, iDb);\n                if (db->mallocFailed == 0) {\n                    ((void)0);\n                    aOp[0].p1 = iDb;\n                    aOp[0].p2 = pTab->tnum;\n                    aOp[0].p3 = wrFlag;\n                    sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);\n                }\n                if (db->mallocFailed == 0) {\n                    if (wrFlag)\n                        aOp[1].opcode = 113;\n                    aOp[1].p2 = pTab->tnum;\n                    aOp[1].p3 = iDb;\n                    aOp[1].p4type = (-3);\n                    aOp[1].p4.i = pTab->nCol + 1;\n                    aOp[3].p2 = pTab->nCol;\n                    sParse.nVar = 0;\n                    sParse.nMem = 1;\n                    sParse.nTab = 1;\n                    sqlite3VdbeMakeReady(v, &sParse);\n                }\n            }\n            pBlob->iCol = iCol;\n            pBlob->db = db;\n            sqlite3BtreeLeaveAll(db);\n            if (db->mallocFailed) {\n                goto blob_open_out;\n            }\n            rc = blobSeekToRow(pBlob, iRow, &zErr);\n            if ((++nAttempt) >= 50 || rc != 17)\n                break;\n            sqlite3ParseObjectReset(&sParse);\n        }\n  blob_open_out:\n    if (rc == 0 && db->mallocFailed == 0) {\n        *ppBlob = (sqlite3_blob *)pBlob;\n    } else {\n        if (pBlob && pBlob->pStmt)\n            sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n        sqlite3DbFree(db, pBlob);\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n    sqlite3DbFree(db, zErr);\n    sqlite3ParseObjectReset(&sParse);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#88347:1#sqlite3Step",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    sqlite3 *db;\n    int rc;\n    ((void)0);\n    db = p->db;\n    if (p->eVdbeState != 2) {\n      restart_step:\n        if (p->eVdbeState == 1) {\n            if (p->expired) {\n                p->rc = 17;\n                rc = 1;\n                if ((p->prepFlags & 128) != 0) {\n                    rc = sqlite3VdbeTransferError(p);\n                }\n                goto end_of_step;\n            }\n            if (db->nVdbeActive == 0) {\n                __atomic_store_n((&db->u1.isInterrupted), (0), 0);\n            }\n            ((void)0);\n            if ((db->mTrace & (2 | 128)) != 0 && !db->init.busy && p->zSql) {\n                sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n            } else {\n                ((void)0);\n            }\n            db->nVdbeActive++;\n            if (p->readOnly == 0)\n                db->nVdbeWrite++;\n            if (p->bIsReader)\n                db->nVdbeRead++;\n            p->pc = 0;\n            p->eVdbeState = 2;\n        } else if ((p->eVdbeState == 3)) {\n            sqlite3_reset((sqlite3_stmt *)p);\n            ((void)0);\n            goto restart_step;\n        }\n    }\n    if (p->explain) {\n        rc = sqlite3VdbeList(p);\n    } else {\n        db->nVdbeExec++;\n        rc = sqlite3VdbeExec(p);\n        db->nVdbeExec--;\n    }\n    if (rc == 100) {\n        ((void)0);\n        ((void)0);\n        db->errCode = 100;\n        return 100;\n    } else {\n        if (((p)->startTime) > 0) {\n            invokeProfileCallback(db, p);\n        }\n        ;\n        p->pResultRow = 0;\n        if (rc == 101 && db->autoCommit) {\n            ((void)0);\n            p->rc = doWalCallbacks(db);\n            if (p->rc != 0) {\n                rc = 1;\n            }\n        } else if (rc != 101 && (p->prepFlags & 128) != 0) {\n            rc = sqlite3VdbeTransferError(p);\n        }\n    }\n    db->errCode = rc;\n    if (7 == sqlite3ApiExit(p->db, p->rc)) {\n        p->rc = 7;\n        if ((p->prepFlags & 128) != 0)\n            rc = p->rc;\n    }\n  end_of_step:\n    ((void)0);\n    return (rc & db->errMask);\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateForeignKey",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    FKey *pFKey = 0;\n    FKey *pNextTo;\n    Table *p = pParse->pNewTable;\n    i64 nByte;\n    int i;\n    int nCol;\n    char *z;\n    ((void)0);\n    if (p == 0 || (pParse->eParseMode == 1))\n        goto fk_end;\n    if (pFromCol == 0) {\n        int iCol = p->nCol - 1;\n        if ((iCol < 0))\n            goto fk_end;\n        if (pToCol && pToCol->nExpr != 1) {\n            sqlite3ErrorMsg(pParse, \"foreign key on %s should reference only one column of table %T\", p->aCol[iCol].zCnName, pTo);\n            goto fk_end;\n        }\n        nCol = 1;\n    } else if (pToCol && pToCol->nExpr != pFromCol->nExpr) {\n        sqlite3ErrorMsg(pParse, \"number of columns in foreign key does not match the number of columns in the referenced table\");\n        goto fk_end;\n    } else {\n        nCol = pFromCol->nExpr;\n    }\n    nByte = sizeof (*pFKey) + (nCol - 1) * sizeof (pFKey->aCol[0]) + pTo->n + 1;\n    if (pToCol) {\n        for (i = 0; i < pToCol->nExpr; i++) {\n            nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;\n        }\n    }\n    pFKey = sqlite3DbMallocZero(db, nByte);\n    if (pFKey == 0) {\n        goto fk_end;\n    }\n    pFKey->pFrom = p;\n    ((void)0);\n    pFKey->pNextFrom = p->u.tab.pFKey;\n    z = (char *)&pFKey->aCol[nCol];\n    pFKey->zTo = z;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenMap(pParse, (void *)z, pTo);\n    }\n    __builtin___memcpy_chk(z, pTo->z, pTo->n, __builtin_object_size(z, 0));\n    z[pTo->n] = 0;\n    sqlite3Dequote(z);\n    z += pTo->n + 1;\n    pFKey->nCol = nCol;\n    if (pFromCol == 0) {\n        pFKey->aCol[0].iFrom = p->nCol - 1;\n    } else {\n        for (i = 0; i < nCol; i++) {\n            int j;\n            for (j = 0; j < p->nCol; j++) {\n                if (sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName) == 0) {\n                    pFKey->aCol[i].iFrom = j;\n                    break;\n                }\n            }\n            if (j >= p->nCol) {\n                sqlite3ErrorMsg(pParse, \"unknown column \\\"%s\\\" in foreign key definition\", pFromCol->a[i].zEName);\n                goto fk_end;\n            }\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);\n            }\n        }\n    }\n    if (pToCol) {\n        for (i = 0; i < nCol; i++) {\n            int n = sqlite3Strlen30(pToCol->a[i].zEName);\n            pFKey->aCol[i].zCol = z;\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);\n            }\n            __builtin___memcpy_chk(z, pToCol->a[i].zEName, n, __builtin_object_size(z, 0));\n            z[n] = 0;\n            z += n + 1;\n        }\n    }\n    pFKey->isDeferred = 0;\n    pFKey->aAction[0] = (u8)(flags & 255);\n    pFKey->aAction[1] = (u8)((flags >> 8) & 255);\n    ((void)0);\n    pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, pFKey->zTo, (void *)pFKey);\n    if (pNextTo == pFKey) {\n        sqlite3OomFault(db);\n        goto fk_end;\n    }\n    if (pNextTo) {\n        ((void)0);\n        pFKey->pNextTo = pNextTo;\n        pNextTo->pPrevTo = pFKey;\n    }\n    ((void)0);\n    p->u.tab.pFKey = pFKey;\n    pFKey = 0;\n  fk_end:\n    sqlite3DbFree(db, pFKey);\n    sqlite3ExprListDelete(db, pFromCol);\n    sqlite3ExprListDelete(db, pToCol);\n}\n"
  },
  {
    "id": "sqlite3.c#57912:1#pager_delsuper",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    int rc;\n    sqlite3_file *pSuper;\n    sqlite3_file *pJournal;\n    char *zSuperJournal = 0;\n    i64 nSuperJournal;\n    char *zJournal;\n    char *zSuperPtr;\n    char *zFree = 0;\n    int nSuperPtr;\n    pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n    if (!pSuper) {\n        rc = 7;\n        pJournal = 0;\n    } else {\n        const int flags = (1 | 16384);\n        rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);\n        pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);\n    }\n    if (rc != 0)\n        goto delsuper_out;\n    rc = sqlite3OsFileSize(pSuper, &nSuperJournal);\n    if (rc != 0)\n        goto delsuper_out;\n    nSuperPtr = pVfs->mxPathname + 1;\n    zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);\n    if (!zFree) {\n        rc = 7;\n        goto delsuper_out;\n    }\n    zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;\n    zSuperJournal = &zFree[4];\n    zSuperPtr = &zSuperJournal[nSuperJournal + 2];\n    rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);\n    if (rc != 0)\n        goto delsuper_out;\n    zSuperJournal[nSuperJournal] = 0;\n    zSuperJournal[nSuperJournal + 1] = 0;\n    zJournal = zSuperJournal;\n    while ((zJournal - zSuperJournal) < nSuperJournal)\n        {\n            int exists;\n            rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);\n            if (rc != 0) {\n                goto delsuper_out;\n            }\n            if (exists) {\n                int c;\n                int flags = (1 | 16384);\n                rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);\n                sqlite3OsClose(pJournal);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                c = zSuperPtr[0] != 0 && strcmp(zSuperPtr, zSuper) == 0;\n                if (c) {\n                    goto delsuper_out;\n                }\n            }\n            zJournal += (sqlite3Strlen30(zJournal) + 1);\n        }\n    sqlite3OsClose(pSuper);\n    rc = sqlite3OsDelete(pVfs, zSuper, 0);\n  delsuper_out:\n    sqlite3_free(zFree);\n    if (pSuper) {\n        sqlite3OsClose(pSuper);\n        ((void)0);\n        sqlite3_free(pSuper);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeMemTranslate",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    sqlite3_int64 len;\n    unsigned char *zOut;\n    unsigned char *zIn;\n    unsigned char *zTerm;\n    unsigned char *z;\n    unsigned int c;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pMem->enc != 1 && desiredEnc != 1) {\n        u8 temp;\n        int rc;\n        rc = sqlite3VdbeMemMakeWriteable(pMem);\n        if (rc != 0) {\n            ((void)0);\n            return 7;\n        }\n        zIn = (u8 *)pMem->z;\n        zTerm = &zIn[pMem->n & ~1];\n        while (zIn < zTerm)\n            {\n                temp = *zIn;\n                *zIn = *(zIn + 1);\n                zIn++;\n                *zIn++ = temp;\n            }\n        pMem->enc = desiredEnc;\n        goto translate_out;\n    }\n    if (desiredEnc == 1) {\n        pMem->n &= ~1;\n        len = 2 * (sqlite3_int64)pMem->n + 1;\n    } else {\n        len = 2 * (sqlite3_int64)pMem->n + 2;\n    }\n    zIn = (u8 *)pMem->z;\n    zTerm = &zIn[pMem->n];\n    zOut = sqlite3DbMallocRaw(pMem->db, len);\n    if (!zOut) {\n        return 7;\n    }\n    z = zOut;\n    if (pMem->enc == 1) {\n        if (desiredEnc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)((c >> 8) & 255);\n                        } else {\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                        }\n                    }\n                    ;\n                }\n        } else {\n            ((void)0);\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)((c >> 8) & 255);\n                            *z++ = (u8)(c & 255);\n                        } else {\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                            *z++ = (u8)(c & 255);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n        *z++ = 0;\n    } else {\n        ((void)0);\n        if (pMem->enc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    c += (*(zIn++)) << 8;\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = (*zIn++);\n                            c2 += ((*zIn++) << 8);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        } else {\n            while (zIn < zTerm)\n                {\n                    c = (*(zIn++)) << 8;\n                    c += *(zIn++);\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = ((*zIn++) << 8);\n                            c2 += (*zIn++);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n    }\n    *z = 0;\n    ((void)0);\n    c = 2 | 512 | (pMem->flags & (63 | 2048));\n    sqlite3VdbeMemRelease(pMem);\n    pMem->flags = c;\n    pMem->enc = desiredEnc;\n    pMem->z = (char *)zOut;\n    pMem->zMalloc = pMem->z;\n    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);\n  translate_out:\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeInsert",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int rc;\n    int loc = seekResult;\n    int szNew = 0;\n    int idx;\n    MemPage *pPage;\n    Btree *p = pCur->pBtree;\n    unsigned char *oldCell;\n    unsigned char *newCell = 0;\n    ((void)0);\n    ((void)0);\n    if (pCur->curFlags & 32) {\n        rc = saveAllCursors(p->pBt, pCur->pgnoRoot, pCur);\n        if (rc)\n            return rc;\n        if (loc && pCur->iPage < 0) {\n            return sqlite3CorruptError(77436);\n        }\n    }\n    if (pCur->eState >= 3) {\n        ;\n        ;\n        rc = moveToRoot(pCur);\n        if (rc && rc != 16)\n            return rc;\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pCur->pKeyInfo == 0) {\n        ((void)0);\n        if (p->hasIncrblobCur) {\n            invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);\n        }\n        if ((pCur->curFlags & 2) != 0 && pX->nKey == pCur->info.nKey) {\n            ((void)0);\n            if (pCur->info.nSize != 0 && pCur->info.nPayload == (u32)pX->nData + pX->nZero) {\n                return btreeOverwriteCell(pCur, pX);\n            }\n            ((void)0);\n        } else if (loc == 0) {\n            rc = sqlite3BtreeTableMoveto(pCur, pX->nKey, (flags & 8) != 0, &loc);\n            if (rc)\n                return rc;\n        }\n    } else {\n        ((void)0);\n        if (loc == 0 && (flags & 2) == 0) {\n            if (pX->nMem) {\n                UnpackedRecord r;\n                r.pKeyInfo = pCur->pKeyInfo;\n                r.aMem = pX->aMem;\n                r.nField = pX->nMem;\n                r.default_rc = 0;\n                r.eqSeen = 0;\n                rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);\n            } else {\n                rc = btreeMoveto(pCur, pX->pKey, pX->nKey, (flags & 8) != 0, &loc);\n            }\n            if (rc)\n                return rc;\n        }\n        if (loc == 0) {\n            getCellInfo(pCur);\n            if (pCur->info.nKey == pX->nKey) {\n                BtreePayload x2;\n                x2.pData = pX->pKey;\n                x2.nData = pX->nKey;\n                x2.nZero = 0;\n                return btreeOverwriteCell(pCur, &x2);\n            }\n        }\n    }\n    ((void)0);\n    pPage = pCur->pPage;\n    ((void)0);\n    ((void)0);\n    if (pPage->nFree < 0) {\n        if ((pCur->eState > 1)) {\n            rc = sqlite3CorruptError(77559);\n        } else {\n            rc = btreeComputeFreeSpace(pPage);\n        }\n        if (rc)\n            return rc;\n    }\n    ;\n    ((void)0);\n    newCell = p->pBt->pTmpSpace;\n    ((void)0);\n    ((void)0);\n    if (flags & 128) {\n        rc = 0;\n        szNew = p->pBt->nPreformatSize;\n        if (szNew < 4)\n            szNew = 4;\n        if ((p->pBt->autoVacuum) && szNew > pPage->maxLocal) {\n            CellInfo info;\n            pPage->xParseCell(pPage, newCell, &info);\n            if (info.nPayload != info.nLocal) {\n                Pgno ovfl = sqlite3Get4byte(&newCell[szNew - 4]);\n                ptrmapPut(p->pBt, ovfl, 3, pPage->pgno, &rc);\n                if ((rc))\n                    goto end_insert;\n            }\n        }\n    } else {\n        rc = fillInCell(pPage, newCell, pX, &szNew);\n        if (rc)\n            goto end_insert;\n    }\n    ((void)0);\n    ((void)0);\n    idx = pCur->ix;\n    if (loc == 0) {\n        CellInfo info;\n        ((void)0);\n        if (idx >= pPage->nCell) {\n            return sqlite3CorruptError(77597);\n        }\n        rc = sqlite3PagerWrite(pPage->pDbPage);\n        if (rc) {\n            goto end_insert;\n        }\n        oldCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n        if (!pPage->leaf) {\n            __builtin___memcpy_chk(newCell, oldCell, 4, __builtin_object_size(newCell, 0));\n        }\n        pPage->xParseCell(pPage, oldCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, oldCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        ;\n        (pCur->curFlags &= ~4);\n        if (info.nSize == szNew && info.nLocal == info.nPayload && (!(p->pBt->autoVacuum) || szNew < pPage->minLocal)) {\n            ((void)0);\n            if (oldCell < pPage->aData + pPage->hdrOffset + 10) {\n                return sqlite3CorruptError(77624);\n            }\n            if (oldCell + szNew > pPage->aDataEnd) {\n                return sqlite3CorruptError(77627);\n            }\n            __builtin___memcpy_chk(oldCell, newCell, szNew, __builtin_object_size(oldCell, 0));\n            return 0;\n        }\n        dropCell(pPage, idx, info.nSize, &rc);\n        if (rc)\n            goto end_insert;\n    } else if (loc < 0 && pPage->nCell > 0) {\n        ((void)0);\n        idx = ++pCur->ix;\n        pCur->curFlags &= ~2;\n    } else {\n        ((void)0);\n    }\n    rc = insertCell(pPage, idx, newCell, szNew, 0, 0);\n    ((void)0);\n    ((void)0);\n    pCur->info.nSize = 0;\n    if (pPage->nOverflow) {\n        ((void)0);\n        pCur->curFlags &= ~(2);\n        rc = balance(pCur);\n        pCur->pPage->nOverflow = 0;\n        pCur->eState = 1;\n        if ((flags & 2) && rc == 0) {\n            btreeReleaseAllCursorPages(pCur);\n            if (pCur->pKeyInfo) {\n                ((void)0);\n                pCur->pKey = sqlite3Malloc(pX->nKey);\n                if (pCur->pKey == 0) {\n                    rc = 7;\n                } else {\n                    __builtin___memcpy_chk(pCur->pKey, pX->pKey, pX->nKey, __builtin_object_size(pCur->pKey, 0));\n                }\n            }\n            pCur->eState = 3;\n            pCur->nKey = pX->nKey;\n        }\n    }\n    ((void)0);\n  end_insert:\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerSharedLock",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (!((pPager)->pWal != 0) && pPager->eState == 0) {\n        int bHotJournal = 1;\n        ((void)0);\n        ((void)0);\n        rc = pager_wait_on_lock(pPager, 1);\n        if (rc != 0) {\n            ((void)0);\n            goto failed;\n        }\n        if (pPager->eLock <= 1) {\n            rc = hasHotJournal(pPager, &bHotJournal);\n        }\n        if (rc != 0) {\n            goto failed;\n        }\n        if (bHotJournal) {\n            if (pPager->readOnly) {\n                rc = (8 | (3 << 8));\n                goto failed;\n            }\n            rc = pagerLockDb(pPager, 4);\n            if (rc != 0) {\n                goto failed;\n            }\n            if (!((pPager->jfd)->pMethods != 0) && pPager->journalMode != 2) {\n                sqlite3_vfs *const pVfs = pPager->pVfs;\n                int bExists;\n                rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &bExists);\n                if (rc == 0 && bExists) {\n                    int fout = 0;\n                    int f = 2 | 2048;\n                    ((void)0);\n                    rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);\n                    ((void)0);\n                    if (rc == 0 && fout & 1) {\n                        rc = sqlite3CantopenError(60711);\n                        sqlite3OsClose(pPager->jfd);\n                    }\n                }\n            }\n            if (((pPager->jfd)->pMethods != 0)) {\n                ((void)0);\n                rc = pagerSyncHotJournal(pPager);\n                if (rc == 0) {\n                    rc = pager_playback(pPager, !pPager->tempFile);\n                    pPager->eState = 0;\n                }\n            } else if (!pPager->exclusiveMode) {\n                pagerUnlockDb(pPager, 1);\n            }\n            if (rc != 0) {\n                pager_error(pPager, rc);\n                goto failed;\n            }\n            ((void)0);\n            ((void)0);\n        }\n        if (!pPager->tempFile && pPager->hasHeldSharedLock) {\n            char dbFileVers[16];\n            ;\n            rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof (dbFileVers), 24);\n            if (rc != 0) {\n                if (rc != (10 | (2 << 8))) {\n                    goto failed;\n                }\n                __builtin___memset_chk(dbFileVers, 0, sizeof (dbFileVers), __builtin_object_size(dbFileVers, 0));\n            }\n            if (memcmp(pPager->dbFileVers, dbFileVers, sizeof (dbFileVers)) != 0) {\n                pager_reset(pPager);\n                if (((pPager)->bUseFetch)) {\n                    sqlite3OsUnfetch(pPager->fd, 0, 0);\n                }\n            }\n        }\n        rc = pagerOpenWalIfPresent(pPager);\n        ((void)0);\n    }\n    if (((pPager)->pWal != 0)) {\n        ((void)0);\n        rc = pagerBeginReadTransaction(pPager);\n    }\n    if (pPager->tempFile == 0 && pPager->eState == 0 && rc == 0) {\n        rc = pagerPagecount(pPager, &pPager->dbSize);\n    }\n  failed:\n    if (rc != 0) {\n        ((void)0);\n        pager_unlock(pPager);\n        ((void)0);\n    } else {\n        pPager->eState = 1;\n        pPager->hasHeldSharedLock = 1;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterRenameTable",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    int iDb;\n    char *zDb;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int nTabName;\n    const char *zTabName;\n    Vdbe *v;\n    VTable *pVTab = 0;\n    if ((db->mallocFailed))\n        goto exit_rename_table;\n    ((void)0);\n    ((void)0);\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_table;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    zDb = db->aDb[iDb].zDbSName;\n    zName = sqlite3NameFromToken(db, pName);\n    if (!zName)\n        goto exit_rename_table;\n    if (sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) || sqlite3IsShadowTableOf(db, pTab, zName)) {\n        sqlite3ErrorMsg(pParse, \"there is already another table or index with this name: %s\", zName);\n        goto exit_rename_table;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (0 != sqlite3CheckObjectName(pParse, zName, \"table\", zName)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n        goto exit_rename_table;\n    }\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_table;\n    }\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 1)) {\n        pVTab = sqlite3GetVTable(db, pTab);\n        if (pVTab->pVtab->pModule->xRename == 0) {\n            pVTab = 0;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto exit_rename_table;\n    }\n    sqlite3MayAbort(pParse);\n    zTabName = pTab->zName;\n    nTabName = sqlite3Utf8CharLen(zTabName, -1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\", zDb, zDb, zTabName, zName, (iDb == 1), zTabName);\n    sqlite3NestedParse(pParse, \"UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');\", zDb, zName, zName, zName, nTabName, zTabName);\n    if (sqlite3FindTable(db, \"sqlite_sequence\", zDb)) {\n        sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\", zDb, zName, pTab->zName);\n    }\n    if (iDb != 1) {\n        sqlite3NestedParse(pParse, \"UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')\", zDb, zTabName, zName, zTabName, zDb, zName);\n    }\n    if (pVTab) {\n        int i = ++pParse->nMem;\n        sqlite3VdbeLoadString(v, i, zName);\n        sqlite3VdbeAddOp4(v, 176, i, 0, 0, (const char *)pVTab, (-11));\n    }\n    renameReloadSchema(pParse, iDb, 1);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after rename\", 0);\n  exit_rename_table:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zName);\n}\n"
  },
  {
    "id": "sqlite3.c#78194:1#clearDatabasePage",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    MemPage *pPage;\n    int rc;\n    unsigned char *pCell;\n    int i;\n    int hdr;\n    CellInfo info;\n    ((void)0);\n    if (pgno > btreePagecount(pBt)) {\n        return sqlite3CorruptError(78209);\n    }\n    rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);\n    if (rc)\n        return rc;\n    if ((pBt->openFlags & 4) == 0 && sqlite3PagerPageRefcount(pPage->pDbPage) != (1 + (pgno == 1))) {\n        rc = sqlite3CorruptError(78216);\n        goto cleardatabasepage_out;\n    }\n    hdr = pPage->hdrOffset;\n    for (i = 0; i < pPage->nCell; i++) {\n        pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (i)])[0] << 8 | (&(pPage)->aCellIdx[2 * (i)])[1])));\n        if (!pPage->leaf) {\n            rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);\n            if (rc)\n                goto cleardatabasepage_out;\n        }\n        pPage->xParseCell(pPage, pCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, pCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        if (rc)\n            goto cleardatabasepage_out;\n    }\n    if (!pPage->leaf) {\n        rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[hdr + 8]), 1, pnChange);\n        if (rc)\n            goto cleardatabasepage_out;\n        if (pPage->intKey)\n            pnChange = 0;\n    }\n    if (pnChange) {\n        ;\n        *pnChange += pPage->nCell;\n    }\n    if (freePageFlag) {\n        freePage(pPage, &rc);\n    } else if ((rc = sqlite3PagerWrite(pPage->pDbPage)) == 0) {\n        zeroPage(pPage, pPage->aData[hdr] | 8);\n    }\n  cleardatabasepage_out:\n    releasePage(pPage);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#52040:12#sqlite3_deserialize",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    MemFile *p;\n    char *zSql;\n    sqlite3_stmt *pStmt = 0;\n    int rc;\n    int iDb;\n    sqlite3_mutex_enter(db->mutex);\n    if (zSchema == 0)\n        zSchema = db->aDb[0].zDbSName;\n    iDb = sqlite3FindDbName(db, zSchema);\n    ;\n    if (iDb < 2 && iDb != 0) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    zSql = sqlite3_mprintf(\"ATTACH x AS %Q\", zSchema);\n    if (zSql == 0) {\n        rc = 7;\n    } else {\n        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n    }\n    if (rc)\n        goto end_deserialize;\n    db->init.iDb = (u8)iDb;\n    db->init.reopenMemdb = 1;\n    rc = sqlite3_step(pStmt);\n    db->init.reopenMemdb = 0;\n    if (rc != 101) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    p = memdbFromDbSchema(db, zSchema);\n    if (p == 0) {\n        rc = 1;\n    } else {\n        MemStore *pStore = p->pStore;\n        pStore->aData = pData;\n        pData = 0;\n        pStore->sz = szDb;\n        pStore->szAlloc = szBuf;\n        pStore->szMax = szBuf;\n        if (pStore->szMax < sqlite3Config.mxMemdbSize) {\n            pStore->szMax = sqlite3Config.mxMemdbSize;\n        }\n        pStore->mFlags = mFlags;\n        rc = 0;\n    }\n  end_deserialize:\n    sqlite3_finalize(pStmt);\n    if (pData && (mFlags & 1) != 0) {\n        sqlite3_free(pData);\n    }\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#73724:1#moveToRoot",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    MemPage *pRoot;\n    int rc = 0;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pCur->iPage >= 0) {\n        if (pCur->iPage) {\n            releasePageNotNull(pCur->pPage);\n            while (--pCur->iPage)\n                {\n                    releasePageNotNull(pCur->apPage[pCur->iPage]);\n                }\n            pRoot = pCur->pPage = pCur->apPage[0];\n            goto skip_init;\n        }\n    } else if (pCur->pgnoRoot == 0) {\n        pCur->eState = 1;\n        return 16;\n    } else {\n        ((void)0);\n        if (pCur->eState >= 3) {\n            if (pCur->eState == 4) {\n                ((void)0);\n                return pCur->skipNext;\n            }\n            sqlite3BtreeClearCursor(pCur);\n        }\n        rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage, 0, pCur->curPagerFlags);\n        if (rc != 0) {\n            pCur->eState = 1;\n            return rc;\n        }\n        pCur->iPage = 0;\n        pCur->curIntKey = pCur->pPage->intKey;\n    }\n    pRoot = pCur->pPage;\n    ((void)0);\n    ((void)0);\n    if (pRoot->isInit == 0 || (pCur->pKeyInfo == 0) != pRoot->intKey) {\n        return sqlite3CorruptError(73780);\n    }\n  skip_init:\n    pCur->ix = 0;\n    pCur->info.nSize = 0;\n    pCur->curFlags &= ~(8 | 2 | 4);\n    if (pRoot->nCell > 0) {\n        pCur->eState = 0;\n    } else if (!pRoot->leaf) {\n        Pgno subpage;\n        if (pRoot->pgno != 1)\n            return sqlite3CorruptError(73792);\n        subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset + 8]);\n        pCur->eState = 0;\n        rc = moveToChild(pCur, subpage);\n    } else {\n        pCur->eState = 1;\n        rc = 16;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#23644:1#parseTimezone",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int sgn = 0;\n    int nHr, nMn;\n    int c;\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tz = 0;\n    c = *zDate;\n    if (c == '-') {\n        sgn = -1;\n    } else if (c == '+') {\n        sgn = +1;\n    } else if (c == 'Z' || c == 'z') {\n        zDate++;\n        goto zulu_time;\n    } else {\n        return c != 0;\n    }\n    zDate++;\n    if (getDigits(zDate, \"20b:20e\", &nHr, &nMn) != 2) {\n        return 1;\n    }\n    zDate += 5;\n    p->tz = sgn * (nMn + nHr * 60);\n  zulu_time:\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tzSet = 1;\n    return *zDate != 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BitvecSet",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    u32 h;\n    if (p == 0)\n        return 0;\n    ((void)0);\n    ((void)0);\n    i--;\n    while ((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) && p->iDivisor)\n        {\n            u32 bin = i / p->iDivisor;\n            i = i % p->iDivisor;\n            if (p->u.apSub[bin] == 0) {\n                p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor);\n                if (p->u.apSub[bin] == 0)\n                    return 7;\n            }\n            p = p->u.apSub[bin];\n        }\n    if (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) {\n        p->u.aBitmap[i / 8] |= 1 << (i & (8 - 1));\n        return 0;\n    }\n    h = (((i++) * 1) % ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)));\n    if (!p->u.aHash[h]) {\n        if (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) {\n            goto bitvec_set_end;\n        } else {\n            goto bitvec_set_rehash;\n        }\n    }\n    do {\n        if (p->u.aHash[h] == i)\n            return 0;\n        h++;\n        if (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)))\n            h = 0;\n    } while (p->u.aHash[h]);\n  bitvec_set_rehash:\n    if (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) {\n        unsigned int j;\n        int rc;\n        u32 *aiValues = sqlite3DbMallocRaw(0, sizeof (p->u.aHash));\n        if (aiValues == 0) {\n            return 7;\n        } else {\n            __builtin___memcpy_chk(aiValues, p->u.aHash, sizeof (p->u.aHash), __builtin_object_size(aiValues, 0));\n            __builtin___memset_chk(p->u.apSub, 0, sizeof (p->u.apSub), __builtin_object_size(p->u.apSub, 0));\n            p->iDivisor = (p->iSize + ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) - 1) / ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *));\n            rc = sqlite3BitvecSet(p, i);\n            for (j = 0; j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)); j++) {\n                if (aiValues[j])\n                    rc |= sqlite3BitvecSet(p, aiValues[j]);\n            }\n            sqlite3DbFree(0, aiValues);\n            return rc;\n        }\n    }\n  bitvec_set_end:\n    p->nSet++;\n    p->u.aHash[h] = i;\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BitvecBuiltinTest",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Bitvec *pBitvec = 0;\n    unsigned char *pV = 0;\n    int rc = -1;\n    int i, nx, pc, op;\n    void *pTmpSpace;\n    pBitvec = sqlite3BitvecCreate(sz);\n    pV = sqlite3MallocZero((sz + 7) / 8 + 1);\n    pTmpSpace = sqlite3_malloc64(512);\n    if (pBitvec == 0 || pV == 0 || pTmpSpace == 0)\n        goto bitvec_end;\n    sqlite3BitvecSet(0, 1);\n    sqlite3BitvecClear(0, 1, pTmpSpace);\n    pc = i = 0;\n    while ((op = aOp[pc]) != 0)\n        {\n            switch (op) {\n              case 1:\n              case 2:\n              case 5:\n                {\n                    nx = 4;\n                    i = aOp[pc + 2] - 1;\n                    aOp[pc + 2] += aOp[pc + 3];\n                    break;\n                }\n              case 3:\n              case 4:\n              default:\n                {\n                    nx = 2;\n                    sqlite3_randomness(sizeof (i), &i);\n                    break;\n                }\n            }\n            if ((--aOp[pc + 1]) > 0)\n                nx = 0;\n            pc += nx;\n            i = (i & 2147483647) % sz;\n            if ((op & 1) != 0) {\n                pV[(i + 1) >> 3] |= (1 << ((i + 1) & 7));\n                if (op != 5) {\n                    if (sqlite3BitvecSet(pBitvec, i + 1))\n                        goto bitvec_end;\n                }\n            } else {\n                pV[(i + 1) >> 3] &= ~(1 << ((i + 1) & 7));\n                sqlite3BitvecClear(pBitvec, i + 1, pTmpSpace);\n            }\n        }\n    rc = sqlite3BitvecTest(0, 0) + sqlite3BitvecTest(pBitvec, sz + 1) + sqlite3BitvecTest(pBitvec, 0) + (sqlite3BitvecSize(pBitvec) - sz);\n    for (i = 1; i <= sz; i++) {\n        if (((pV[i >> 3] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, i)) {\n            rc = i;\n            break;\n        }\n    }\n  bitvec_end:\n    sqlite3_free(pTmpSpace);\n    sqlite3_free(pV);\n    sqlite3BitvecDestroy(pBitvec);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#116550:1#attachFunc",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int i;\n    int rc = 0;\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    const char *zName;\n    const char *zFile;\n    char *zPath = 0;\n    char *zErr = 0;\n    unsigned int flags;\n    Db *aNew;\n    Db *pNew = 0;\n    char *zErrDyn = 0;\n    sqlite3_vfs *pVfs;\n    (void)(NotUsed);\n    zFile = (const char *)sqlite3_value_text(argv[0]);\n    zName = (const char *)sqlite3_value_text(argv[1]);\n    if (zFile == 0)\n        zFile = \"\";\n    if (zName == 0)\n        zName = \"\";\n    if ((db->init.reopenMemdb)) {\n        Btree *pNewBt = 0;\n        pVfs = sqlite3_vfs_find(\"memdb\");\n        if (pVfs == 0)\n            return;\n        rc = sqlite3BtreeOpen(pVfs, \"x\\000\", db, &pNewBt, 0, 256);\n        if (rc == 0) {\n            Schema *pNewSchema = sqlite3SchemaGet(db, pNewBt);\n            if (pNewSchema) {\n                pNew = &db->aDb[db->init.iDb];\n                if ((pNew->pBt))\n                    sqlite3BtreeClose(pNew->pBt);\n                pNew->pBt = pNewBt;\n                pNew->pSchema = pNewSchema;\n            } else {\n                sqlite3BtreeClose(pNewBt);\n                rc = 7;\n            }\n        }\n        if (rc)\n            goto attach_error;\n    } else {\n        if (db->nDb >= db->aLimit[7] + 2) {\n            zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", db->aLimit[7]);\n            goto attach_error;\n        }\n        for (i = 0; i < db->nDb; i++) {\n            ((void)0);\n            if (sqlite3DbIsNamed(db, i, zName)) {\n                zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n                goto attach_error;\n            }\n        }\n        if (db->aDb == db->aDbStatic) {\n            aNew = sqlite3DbMallocRawNN(db, sizeof (db->aDb[0]) * 3);\n            if (aNew == 0)\n                return;\n            __builtin___memcpy_chk(aNew, db->aDb, sizeof (db->aDb[0]) * 2, __builtin_object_size(aNew, 0));\n        } else {\n            aNew = sqlite3DbRealloc(db, db->aDb, sizeof (db->aDb[0]) * (db->nDb + 1));\n            if (aNew == 0)\n                return;\n        }\n        db->aDb = aNew;\n        pNew = &db->aDb[db->nDb];\n        __builtin___memset_chk(pNew, 0, sizeof (*pNew), __builtin_object_size(pNew, 0));\n        flags = db->openFlags;\n        rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n        if (rc != 0) {\n            if (rc == 7)\n                sqlite3OomFault(db);\n            sqlite3_result_error(context, zErr, -1);\n            sqlite3_free(zErr);\n            return;\n        }\n        ((void)0);\n        flags |= 256;\n        rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);\n        db->nDb++;\n        pNew->zDbSName = sqlite3DbStrDup(db, zName);\n    }\n    db->noSharedCache = 0;\n    if (rc == 19) {\n        rc = 1;\n        zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n    } else if (rc == 0) {\n        Pager *pPager;\n        pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);\n        if (!pNew->pSchema) {\n            rc = 7;\n        } else if (pNew->pSchema->file_format && pNew->pSchema->enc != ((db)->enc)) {\n            zErrDyn = sqlite3MPrintf(db, \"attached databases must use the same text encoding as main database\");\n            rc = 1;\n        }\n        sqlite3BtreeEnter(pNew->pBt);\n        pPager = sqlite3BtreePager(pNew->pBt);\n        sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n        sqlite3BtreeSecureDelete(pNew->pBt, sqlite3BtreeSecureDelete(db->aDb[0].pBt, -1));\n        sqlite3BtreeSetPagerFlags(pNew->pBt, 3 | (db->flags & 56));\n        sqlite3BtreeLeave(pNew->pBt);\n    }\n    pNew->safety_level = 2 + 1;\n    if (rc == 0 && pNew->zDbSName == 0) {\n        rc = 7;\n    }\n    sqlite3_free_filename(zPath);\n    if (rc == 0) {\n        sqlite3BtreeEnterAll(db);\n        db->init.iDb = 0;\n        db->mDbFlags &= ~(16);\n        if (!(db->init.reopenMemdb)) {\n            rc = sqlite3Init(db, &zErrDyn);\n        }\n        sqlite3BtreeLeaveAll(db);\n        ((void)0);\n    }\n    if (rc) {\n        if ((!(db->init.reopenMemdb))) {\n            int iDb = db->nDb - 1;\n            ((void)0);\n            if (db->aDb[iDb].pBt) {\n                sqlite3BtreeClose(db->aDb[iDb].pBt);\n                db->aDb[iDb].pBt = 0;\n                db->aDb[iDb].pSchema = 0;\n            }\n            sqlite3ResetAllSchemasOfConnection(db);\n            db->nDb = iDb;\n            if (rc == 7 || rc == (10 | (12 << 8))) {\n                sqlite3OomFault(db);\n                sqlite3DbFree(db, zErrDyn);\n                zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n            } else if (zErrDyn == 0) {\n                zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n            }\n        }\n        goto attach_error;\n    }\n    return;\n  attach_error:\n    if (zErrDyn) {\n        sqlite3_result_error(context, zErrDyn, -1);\n        sqlite3DbFree(db, zErrDyn);\n    }\n    if (rc)\n        sqlite3_result_error_code(context, rc);\n}\n"
  },
  {
    "id": "sqlite3.c#30134:12#sqlite3_str_vappendf",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int c;\n    char *bufpt;\n    int precision;\n    int length;\n    int idx;\n    int width;\n    etByte flag_leftjustify;\n    etByte flag_prefix;\n    etByte flag_alternateform;\n    etByte flag_altform2;\n    etByte flag_zeropad;\n    etByte flag_long;\n    etByte done;\n    etByte cThousand;\n    etByte xtype = 17;\n    u8 bArgList;\n    char prefix;\n    sqlite_uint64 longvalue;\n    long double realvalue;\n    const et_info *infop;\n    char *zOut;\n    int nOut;\n    char *zExtra = 0;\n    int exp, e2;\n    int nsd;\n    double rounder;\n    etByte flag_dp;\n    etByte flag_rtz;\n    PrintfArguments *pArgList = 0;\n    char buf[70];\n    ((void)0);\n    bufpt = 0;\n    if ((pAccum->printfFlags & 2) != 0) {\n        pArgList = __builtin_va_arg(ap, PrintfArguments *);\n        bArgList = 1;\n    } else {\n        bArgList = 0;\n    }\n    for (; (c = (*fmt)) != 0; ++fmt) {\n        if (c != '%') {\n            bufpt = (char *)fmt;\n            do {\n                fmt++;\n            } while (*fmt && *fmt != '%');\n            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n            if (*fmt == 0)\n                break;\n        }\n        if ((c = (*++fmt)) == 0) {\n            sqlite3_str_append(pAccum, \"%\", 1);\n            break;\n        }\n        flag_leftjustify = flag_prefix = cThousand = flag_alternateform = flag_altform2 = flag_zeropad = 0;\n        done = 0;\n        width = 0;\n        flag_long = 0;\n        precision = -1;\n        do {\n            switch (c) {\n              case '-':\n                flag_leftjustify = 1;\n                break;\n              case '+':\n                flag_prefix = '+';\n                break;\n              case ' ':\n                flag_prefix = ' ';\n                break;\n              case '#':\n                flag_alternateform = 1;\n                break;\n              case '!':\n                flag_altform2 = 1;\n                break;\n              case '0':\n                flag_zeropad = 1;\n                break;\n              case ',':\n                cThousand = ',';\n                break;\n              default:\n                done = 1;\n                break;\n              case 'l':\n                {\n                    flag_long = 1;\n                    c = *++fmt;\n                    if (c == 'l') {\n                        c = *++fmt;\n                        flag_long = 2;\n                    }\n                    done = 1;\n                    break;\n                }\n              case '1':\n              case '2':\n              case '3':\n              case '4':\n              case '5':\n              case '6':\n              case '7':\n              case '8':\n              case '9':\n                {\n                    unsigned int wx = c - '0';\n                    while ((c = *++fmt) >= '0' && c <= '9')\n                        {\n                            wx = wx * 10 + c - '0';\n                        }\n                    ;\n                    width = wx & 2147483647;\n                    if (c != '.' && c != 'l') {\n                        done = 1;\n                    } else {\n                        fmt--;\n                    }\n                    break;\n                }\n              case '*':\n                {\n                    if (bArgList) {\n                        width = (int)getIntArg(pArgList);\n                    } else {\n                        width = __builtin_va_arg(ap, int);\n                    }\n                    if (width < 0) {\n                        flag_leftjustify = 1;\n                        width = width >= -2147483647 ? -width : 0;\n                    }\n                    if ((c = fmt[1]) != '.' && c != 'l') {\n                        c = *++fmt;\n                        done = 1;\n                    }\n                    break;\n                }\n              case '.':\n                {\n                    c = *++fmt;\n                    if (c == '*') {\n                        if (bArgList) {\n                            precision = (int)getIntArg(pArgList);\n                        } else {\n                            precision = __builtin_va_arg(ap, int);\n                        }\n                        if (precision < 0) {\n                            precision = precision >= -2147483647 ? -precision : -1;\n                        }\n                        c = *++fmt;\n                    } else {\n                        unsigned int px = 0;\n                        while (c >= '0' && c <= '9')\n                            {\n                                px = px * 10 + c - '0';\n                                c = *++fmt;\n                            }\n                        ;\n                        precision = px & 2147483647;\n                    }\n                    if (c == 'l') {\n                        --fmt;\n                    } else {\n                        done = 1;\n                    }\n                    break;\n                }\n            }\n        } while (!done && (c = (*++fmt)) != 0);\n        infop = &fmtinfo[0];\n        xtype = 17;\n        for (idx = 0; idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0]))); idx++) {\n            if (c == fmtinfo[idx].fmttype) {\n                infop = &fmtinfo[idx];\n                xtype = infop->type;\n                break;\n            }\n        }\n        ((void)0);\n        ((void)0);\n        switch (xtype) {\n          case 13:\n            flag_long = sizeof(char *) == sizeof(i64) ? 2 : sizeof(char *) == sizeof(long) ? 1 : 0;\n          case 15:\n          case 0:\n            cThousand = 0;\n          case 16:\n            if (infop->flags & 1) {\n                i64 v;\n                if (bArgList) {\n                    v = getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        v = __builtin_va_arg(ap, i64);\n                    } else {\n                        v = __builtin_va_arg(ap, long);\n                    }\n                } else {\n                    v = __builtin_va_arg(ap, int);\n                }\n                if (v < 0) {\n                    ;\n                    ;\n                    longvalue = ~v;\n                    longvalue++;\n                    prefix = '-';\n                } else {\n                    longvalue = v;\n                    prefix = flag_prefix;\n                }\n            } else {\n                if (bArgList) {\n                    longvalue = (u64)getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        longvalue = __builtin_va_arg(ap, u64);\n                    } else {\n                        longvalue = __builtin_va_arg(ap, unsigned long);\n                    }\n                } else {\n                    longvalue = __builtin_va_arg(ap, unsigned int);\n                }\n                prefix = 0;\n            }\n            if (longvalue == 0)\n                flag_alternateform = 0;\n            if (flag_zeropad && precision < width - (prefix != 0)) {\n                precision = width - (prefix != 0);\n            }\n            if (precision < 70 - 10 - 70 / 3) {\n                nOut = 70;\n                zOut = buf;\n            } else {\n                u64 n;\n                n = (u64)precision + 10;\n                if (cThousand)\n                    n += precision / 3;\n                zOut = zExtra = printfTempBuf(pAccum, n);\n                if (zOut == 0)\n                    return;\n                nOut = (int)n;\n            }\n            bufpt = &zOut[nOut - 1];\n            if (xtype == 15) {\n                static const char zOrd[] = \"thstndrd\";\n                int x = (int)(longvalue % 10);\n                if (x >= 4 || (longvalue / 10) % 10 == 1) {\n                    x = 0;\n                }\n                *(--bufpt) = zOrd[x * 2 + 1];\n                *(--bufpt) = zOrd[x * 2];\n            }\n            {\n                const char *cset = &aDigits[infop->charset];\n                u8 base = infop->base;\n                do {\n                    *(--bufpt) = cset[longvalue % base];\n                    longvalue = longvalue / base;\n                } while (longvalue > 0);\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            while (precision > length)\n                {\n                    *(--bufpt) = '0';\n                    length++;\n                }\n            if (cThousand) {\n                int nn = (length - 1) / 3;\n                int ix = (length - 1) % 3 + 1;\n                bufpt -= nn;\n                for (idx = 0; nn > 0; idx++) {\n                    bufpt[idx] = bufpt[idx + nn];\n                    ix--;\n                    if (ix == 0) {\n                        bufpt[++idx] = cThousand;\n                        nn--;\n                        ix = 3;\n                    }\n                }\n            }\n            if (prefix)\n                *(--bufpt) = prefix;\n            if (flag_alternateform && infop->prefix) {\n                const char *pre;\n                char x;\n                pre = &aPrefix[infop->prefix];\n                for (; (x = (*pre)) != 0; pre++)\n                    *(--bufpt) = x;\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            break;\n          case 1:\n          case 2:\n          case 3:\n            if (bArgList) {\n                realvalue = getDoubleArg(pArgList);\n            } else {\n                realvalue = __builtin_va_arg(ap, double);\n            }\n            if (precision < 0)\n                precision = 6;\n            if (precision > 100000000) {\n                precision = 100000000;\n            }\n            if (realvalue < 0.) {\n                realvalue = -realvalue;\n                prefix = '-';\n            } else {\n                prefix = flag_prefix;\n            }\n            if (xtype == 3 && precision > 0)\n                precision--;\n            ;\n            idx = precision & 4095;\n            rounder = arRound[idx % 10];\n            while (idx >= 10)\n                {\n                    rounder *= 1.0E-10;\n                    idx -= 10;\n                }\n            if (xtype == 1) {\n                double rx = (double)realvalue;\n                sqlite3_uint64 u;\n                int ex;\n                __builtin___memcpy_chk(&u, &rx, sizeof (u), __builtin_object_size(&u, 0));\n                ex = -1023 + (int)((u >> 52) & 2047);\n                if (precision + (ex / 3) < 15)\n                    rounder += realvalue * 2.9999999999999999E-16;\n                realvalue += rounder;\n            }\n            exp = 0;\n            if (sqlite3IsNaN((double)realvalue)) {\n                bufpt = \"NaN\";\n                length = 3;\n                break;\n            }\n            if (realvalue > 0.) {\n                long double scale = 1.;\n                while (realvalue >= 1.0E+100 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+100;\n                        exp += 100;\n                    }\n                while (realvalue >= 1.0E+10 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+10;\n                        exp += 10;\n                    }\n                while (realvalue >= 10. * scale && exp <= 350)\n                    {\n                        scale *= 10.;\n                        exp++;\n                    }\n                realvalue /= scale;\n                while (realvalue < 1.0E-8)\n                    {\n                        realvalue *= 1.0E+8;\n                        exp -= 8;\n                    }\n                while (realvalue < 1.)\n                    {\n                        realvalue *= 10.;\n                        exp--;\n                    }\n                if (exp > 350) {\n                    bufpt = buf;\n                    buf[0] = prefix;\n                    __builtin___memcpy_chk(buf + (prefix != 0), \"Inf\", 4, __builtin_object_size(buf + (prefix != 0), 0));\n                    length = 3 + (prefix != 0);\n                    break;\n                }\n            }\n            bufpt = buf;\n            if (xtype != 1) {\n                realvalue += rounder;\n                if (realvalue >= 10.) {\n                    realvalue *= 0.10000000000000001;\n                    exp++;\n                }\n            }\n            if (xtype == 3) {\n                flag_rtz = !flag_alternateform;\n                if (exp < -4 || exp > precision) {\n                    xtype = 2;\n                } else {\n                    precision = precision - exp;\n                    xtype = 1;\n                }\n            } else {\n                flag_rtz = flag_altform2;\n            }\n            if (xtype == 2) {\n                e2 = 0;\n            } else {\n                e2 = exp;\n            }\n            {\n                i64 szBufNeeded;\n                szBufNeeded = ((e2) > (0) ? (e2) : (0)) + (i64)precision + (i64)width + 15;\n                if (szBufNeeded > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n                    if (bufpt == 0)\n                        return;\n                }\n            }\n            zOut = bufpt;\n            nsd = 16 + flag_altform2 * 10;\n            flag_dp = (precision > 0 ? 1 : 0) | flag_alternateform | flag_altform2;\n            if (prefix) {\n                *(bufpt++) = prefix;\n            }\n            if (e2 < 0) {\n                *(bufpt++) = '0';\n            } else {\n                for (; e2 >= 0; e2--) {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            }\n            if (flag_dp) {\n                *(bufpt++) = '.';\n            }\n            for (e2++; e2 < 0; precision-- , e2++) {\n                ((void)0);\n                *(bufpt++) = '0';\n            }\n            while ((precision--) > 0)\n                {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            if (flag_rtz && flag_dp) {\n                while (bufpt[-1] == '0')\n                    *(--bufpt) = 0;\n                ((void)0);\n                if (bufpt[-1] == '.') {\n                    if (flag_altform2) {\n                        *(bufpt++) = '0';\n                    } else {\n                        *(--bufpt) = 0;\n                    }\n                }\n            }\n            if (xtype == 2) {\n                *(bufpt++) = aDigits[infop->charset];\n                if (exp < 0) {\n                    *(bufpt++) = '-';\n                    exp = -exp;\n                } else {\n                    *(bufpt++) = '+';\n                }\n                if (exp >= 100) {\n                    *(bufpt++) = (char)((exp / 100) + '0');\n                    exp %= 100;\n                }\n                *(bufpt++) = (char)(exp / 10 + '0');\n                *(bufpt++) = (char)(exp % 10 + '0');\n            }\n            *bufpt = 0;\n            length = (int)(bufpt - zOut);\n            bufpt = zOut;\n            if (flag_zeropad && !flag_leftjustify && length < width) {\n                int i;\n                int nPad = width - length;\n                for (i = width; i >= nPad; i--) {\n                    bufpt[i] = bufpt[i - nPad];\n                }\n                i = prefix != 0;\n                while (nPad--)\n                    bufpt[i++] = '0';\n                length = width;\n            }\n            break;\n          case 4:\n            if (!bArgList) {\n                *(__builtin_va_arg(ap, int *)) = pAccum->nChar;\n            }\n            length = width = 0;\n            break;\n          case 7:\n            buf[0] = '%';\n            bufpt = buf;\n            length = 1;\n            break;\n          case 8:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                length = 1;\n                if (bufpt) {\n                    buf[0] = c = *(bufpt++);\n                    if ((c & 192) == 192) {\n                        while (length < 4 && (bufpt[0] & 192) == 128)\n                            {\n                                buf[length++] = *(bufpt++);\n                            }\n                    }\n                } else {\n                    buf[0] = 0;\n                }\n            } else {\n                unsigned int ch = __builtin_va_arg(ap, unsigned int);\n                if (ch < 128) {\n                    buf[0] = ch & 255;\n                    length = 1;\n                } else if (ch < 2048) {\n                    buf[0] = 192 + (u8)((ch >> 6) & 31);\n                    buf[1] = 128 + (u8)(ch & 63);\n                    length = 2;\n                } else if (ch < 65536) {\n                    buf[0] = 224 + (u8)((ch >> 12) & 15);\n                    buf[1] = 128 + (u8)((ch >> 6) & 63);\n                    buf[2] = 128 + (u8)(ch & 63);\n                    length = 3;\n                } else {\n                    buf[0] = 240 + (u8)((ch >> 18) & 7);\n                    buf[1] = 128 + (u8)((ch >> 12) & 63);\n                    buf[2] = 128 + (u8)((ch >> 6) & 63);\n                    buf[3] = 128 + (u8)(ch & 63);\n                    length = 4;\n                }\n            }\n            if (precision > 1) {\n                i64 nPrior = 1;\n                width -= precision - 1;\n                if (width > 1 && !flag_leftjustify) {\n                    sqlite3_str_appendchar(pAccum, width - 1, ' ');\n                    width = 0;\n                }\n                sqlite3_str_append(pAccum, buf, length);\n                precision--;\n                while (precision > 1)\n                    {\n                        i64 nCopyBytes;\n                        if (nPrior > precision - 1)\n                            nPrior = precision - 1;\n                        nCopyBytes = length * nPrior;\n                        if (nCopyBytes + pAccum->nChar >= pAccum->nAlloc) {\n                            sqlite3StrAccumEnlarge(pAccum, nCopyBytes);\n                        }\n                        if (pAccum->accError)\n                            break;\n                        sqlite3_str_append(pAccum, &pAccum->zText[pAccum->nChar - nCopyBytes], nCopyBytes);\n                        precision -= nPrior;\n                        nPrior *= 2;\n                    }\n            }\n            bufpt = buf;\n            flag_altform2 = 1;\n            goto adjust_width_for_utf8;\n          case 5:\n          case 6:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                xtype = 5;\n            } else {\n                bufpt = __builtin_va_arg(ap, char *);\n            }\n            if (bufpt == 0) {\n                bufpt = \"\";\n            } else if (xtype == 6) {\n                if (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0) {\n                    ((void)0);\n                    pAccum->zText = bufpt;\n                    pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n                    pAccum->nChar = 2147483647 & (int)strlen(bufpt);\n                    pAccum->printfFlags |= 4;\n                    length = 0;\n                    break;\n                }\n                zExtra = bufpt;\n            }\n            if (precision >= 0) {\n                if (flag_altform2) {\n                    unsigned char *z = (unsigned char *)bufpt;\n                    while (precision-- > 0 && z[0])\n                        {\n                            {\n                                if ((*(z++)) >= 192) {\n                                    while ((*z & 192) == 128)\n                                        {\n                                            z++;\n                                        }\n                                }\n                            }\n                            ;\n                        }\n                    length = (int)(z - (unsigned char *)bufpt);\n                } else {\n                    for (length = 0; length < precision && bufpt[length]; length++) {\n                    }\n                }\n            } else {\n                length = 2147483647 & (int)strlen(bufpt);\n            }\n          adjust_width_for_utf8:\n            if (flag_altform2 && width > 0) {\n                int ii = length - 1;\n                while (ii >= 0)\n                    if ((bufpt[ii--] & 192) == 128)\n                        width++;\n            }\n            break;\n          case 9:\n          case 10:\n          case 14:\n            {\n                i64 i, j, k, n;\n                int needQuote, isnull;\n                char ch;\n                char q = ((xtype == 14) ? '\"' : '\\'');\n                char *escarg;\n                if (bArgList) {\n                    escarg = getTextArg(pArgList);\n                } else {\n                    escarg = __builtin_va_arg(ap, char *);\n                }\n                isnull = escarg == 0;\n                if (isnull)\n                    escarg = (xtype == 10 ? \"NULL\" : \"(NULL)\");\n                k = precision;\n                for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++ , k--) {\n                    if (ch == q)\n                        n++;\n                    if (flag_altform2 && (ch & 192) == 192) {\n                        while ((escarg[i + 1] & 192) == 128)\n                            {\n                                i++;\n                            }\n                    }\n                }\n                needQuote = !isnull && xtype == 10;\n                n += i + 3;\n                if (n > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, n);\n                    if (bufpt == 0)\n                        return;\n                } else {\n                    bufpt = buf;\n                }\n                j = 0;\n                if (needQuote)\n                    bufpt[j++] = q;\n                k = i;\n                for (i = 0; i < k; i++) {\n                    bufpt[j++] = ch = escarg[i];\n                    if (ch == q)\n                        bufpt[j++] = ch;\n                }\n                if (needQuote)\n                    bufpt[j++] = q;\n                bufpt[j] = 0;\n                length = j;\n                goto adjust_width_for_utf8;\n            }\n          case 11:\n            {\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                if (flag_alternateform) {\n                    Expr *pExpr = __builtin_va_arg(ap, Expr *);\n                    if ((pExpr) && (!(((pExpr)->flags & (2048)) != 0))) {\n                        sqlite3_str_appendall(pAccum, (const char *)pExpr->u.zToken);\n                        sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n                    }\n                } else {\n                    Token *pToken = __builtin_va_arg(ap, Token *);\n                    ((void)0);\n                    if (pToken && pToken->n) {\n                        sqlite3_str_append(pAccum, (const char *)pToken->z, pToken->n);\n                        sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          case 12:\n            {\n                SrcItem *pItem;\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                pItem = __builtin_va_arg(ap, SrcItem *);\n                ((void)0);\n                if (pItem->zAlias && !flag_altform2) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else if (pItem->zName) {\n                    if (pItem->zDatabase) {\n                        sqlite3_str_appendall(pAccum, pItem->zDatabase);\n                        sqlite3_str_append(pAccum, \".\", 1);\n                    }\n                    sqlite3_str_appendall(pAccum, pItem->zName);\n                } else if (pItem->zAlias) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else {\n                    Select *pSel = pItem->pSelect;\n                    ((void)0);\n                    if (pSel->selFlags & 2048) {\n                        sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n                    } else {\n                        sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          default:\n            {\n                ((void)0);\n                return;\n            }\n        }\n        width -= length;\n        if (width > 0) {\n            if (!flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n            sqlite3_str_append(pAccum, bufpt, length);\n            if (flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n        } else {\n            sqlite3_str_append(pAccum, bufpt, length);\n        }\n        if (zExtra) {\n            sqlite3DbFree(pAccum->db, zExtra);\n            zExtra = 0;\n        }\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#146278:1#sqlite3_get_table_cb",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    TabResult *p = (TabResult *)pArg;\n    int need;\n    int i;\n    char *z;\n    if (p->nRow == 0 && argv != 0) {\n        need = nCol * 2;\n    } else {\n        need = nCol;\n    }\n    if (p->nData + need > p->nAlloc) {\n        char **azNew;\n        p->nAlloc = p->nAlloc * 2 + need;\n        azNew = sqlite3Realloc(p->azResult, sizeof(char *) * p->nAlloc);\n        if (azNew == 0)\n            goto malloc_failed;\n        p->azResult = azNew;\n    }\n    if (p->nRow == 0) {\n        p->nColumn = nCol;\n        for (i = 0; i < nCol; i++) {\n            z = sqlite3_mprintf(\"%s\", colv[i]);\n            if (z == 0)\n                goto malloc_failed;\n            p->azResult[p->nData++] = z;\n        }\n    } else if ((int)p->nColumn != nCol) {\n        sqlite3_free(p->zErrMsg);\n        p->zErrMsg = sqlite3_mprintf(\"sqlite3_get_table() called with two or more incompatible queries\");\n        p->rc = 1;\n        return 1;\n    }\n    if (argv != 0) {\n        for (i = 0; i < nCol; i++) {\n            if (argv[i] == 0) {\n                z = 0;\n            } else {\n                int n = sqlite3Strlen30(argv[i]) + 1;\n                z = sqlite3_malloc64(n);\n                if (z == 0)\n                    goto malloc_failed;\n                __builtin___memcpy_chk(z, argv[i], n, __builtin_object_size(z, 0));\n            }\n            p->azResult[p->nData++] = z;\n        }\n        p->nRow++;\n    }\n    return 0;\n  malloc_failed:\n    p->rc = 7;\n    return 1;\n}\n"
  },
  {
    "id": "sqlite3.c#60908:1#getPageNormal",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    PgHdr *pPg;\n    u8 noContent;\n    sqlite3_pcache_page *pBase;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (pgno == 0)\n        return sqlite3CorruptError(60924);\n    pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);\n    if (pBase == 0) {\n        pPg = 0;\n        rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);\n        if (rc != 0)\n            goto pager_acquire_err;\n        if (pBase == 0) {\n            rc = 7;\n            goto pager_acquire_err;\n        }\n    }\n    pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    noContent = (flags & 1) != 0;\n    if (pPg->pPager && !noContent) {\n        ((void)0);\n        pPager->aStat[0]++;\n        return 0;\n    } else {\n        if (pgno == ((pPager)->lckPgno)) {\n            rc = sqlite3CorruptError(60956);\n            goto pager_acquire_err;\n        }\n        pPg->pPager = pPager;\n        ((void)0);\n        if (!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno || noContent) {\n            if (pgno > pPager->mxPgno) {\n                rc = 13;\n                goto pager_acquire_err;\n            }\n            if (noContent) {\n                sqlite3BeginBenignMalloc();\n                if (pgno <= pPager->dbOrigSize) {\n                    sqlite3BitvecSet(pPager->pInJournal, pgno);\n                    ;\n                }\n                addToSavepointBitvecs(pPager, pgno);\n                ;\n                sqlite3EndBenignMalloc();\n            }\n            __builtin___memset_chk(pPg->pData, 0, pPager->pageSize, __builtin_object_size(pPg->pData, 0));\n            ;\n        } else {\n            ((void)0);\n            pPager->aStat[1]++;\n            rc = readDbPage(pPg);\n            if (rc != 0) {\n                goto pager_acquire_err;\n            }\n        }\n        ;\n    }\n    return 0;\n  pager_acquire_err:\n    ((void)0);\n    if (pPg) {\n        sqlite3PcacheDrop(pPg);\n    }\n    pagerUnlockIfUnused(pPager);\n    *ppPage = 0;\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ParseUri",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unsigned int flags = *pFlags;\n    const char *zVfs = zDefaultVfs;\n    char *zFile;\n    char c;\n    int nUri = sqlite3Strlen30(zUri);\n    ((void)0);\n    if (((flags & 64) || sqlite3Config.bOpenUri) && nUri >= 5 && memcmp(zUri, \"file:\", 5) == 0) {\n        char *zOpt;\n        int eState;\n        int iIn;\n        int iOut = 0;\n        u64 nByte = nUri + 8;\n        flags |= 64;\n        for (iIn = 0; iIn < nUri; iIn++)\n            nByte += (zUri[iIn] == '&');\n        zFile = sqlite3_malloc64(nByte);\n        if (!zFile)\n            return 7;\n        __builtin___memset_chk(zFile, 0, 4, __builtin_object_size(zFile, 0));\n        zFile += 4;\n        iIn = 5;\n        if (zUri[5] == '/' && zUri[6] == '/') {\n            iIn = 7;\n            while (zUri[iIn] && zUri[iIn] != '/')\n                iIn++;\n            if (iIn != 7 && (iIn != 16 || memcmp(\"localhost\", &zUri[7], 9))) {\n                *pzErrMsg = sqlite3_mprintf(\"invalid uri authority: %.*s\", iIn - 7, &zUri[7]);\n                rc = 1;\n                goto parse_uri_out;\n            }\n        }\n        eState = 0;\n        while ((c = zUri[iIn]) != 0 && c != '#')\n            {\n                iIn++;\n                if (c == '%' && (sqlite3CtypeMap[(unsigned char)(zUri[iIn])] & 8) && (sqlite3CtypeMap[(unsigned char)(zUri[iIn + 1])] & 8)) {\n                    int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);\n                    octet += sqlite3HexToInt(zUri[iIn++]);\n                    ((void)0);\n                    if (octet == 0) {\n                        while ((c = zUri[iIn]) != 0 && c != '#' && (eState != 0 || c != '?') && (eState != 1 || (c != '=' && c != '&')) && (eState != 2 || c != '&'))\n                            {\n                                iIn++;\n                            }\n                        continue;\n                    }\n                    c = octet;\n                } else if (eState == 1 && (c == '&' || c == '=')) {\n                    if (zFile[iOut - 1] == 0) {\n                        while (zUri[iIn] && zUri[iIn] != '#' && zUri[iIn - 1] != '&')\n                            iIn++;\n                        continue;\n                    }\n                    if (c == '&') {\n                        zFile[iOut++] = '\\x00';\n                    } else {\n                        eState = 2;\n                    }\n                    c = 0;\n                } else if ((eState == 0 && c == '?') || (eState == 2 && c == '&')) {\n                    c = 0;\n                    eState = 1;\n                }\n                zFile[iOut++] = c;\n            }\n        if (eState == 1)\n            zFile[iOut++] = '\\x00';\n        __builtin___memset_chk(zFile + iOut, 0, 4, __builtin_object_size(zFile + iOut, 0));\n        zOpt = &zFile[sqlite3Strlen30(zFile) + 1];\n        while (zOpt[0])\n            {\n                int nOpt = sqlite3Strlen30(zOpt);\n                char *zVal = &zOpt[nOpt + 1];\n                int nVal = sqlite3Strlen30(zVal);\n                if (nOpt == 3 && memcmp(\"vfs\", zOpt, 3) == 0) {\n                    zVfs = zVal;\n                } else {\n                    struct OpenMode {\n                        const char *z;\n                        int mode;\n                    } *aMode = 0;\n                    char *zModeType = 0;\n                    int mask = 0;\n                    int limit = 0;\n                    if (nOpt == 5 && memcmp(\"cache\", zOpt, 5) == 0) {\n                        static struct OpenMode aCacheMode[] = {{\"shared\", 131072}, {\"private\", 262144}, {0, 0}};\n                        mask = 131072 | 262144;\n                        aMode = aCacheMode;\n                        limit = mask;\n                        zModeType = \"cache\";\n                    }\n                    if (nOpt == 4 && memcmp(\"mode\", zOpt, 4) == 0) {\n                        static struct OpenMode aOpenMode[] = {{\"ro\", 1}, {\"rw\", 2}, {\"rwc\", 2 | 4}, {\"memory\", 128}, {0, 0}};\n                        mask = 1 | 2 | 4 | 128;\n                        aMode = aOpenMode;\n                        limit = mask & flags;\n                        zModeType = \"access\";\n                    }\n                    if (aMode) {\n                        int i;\n                        int mode = 0;\n                        for (i = 0; aMode[i].z; i++) {\n                            const char *z = aMode[i].z;\n                            if (nVal == sqlite3Strlen30(z) && 0 == memcmp(zVal, z, nVal)) {\n                                mode = aMode[i].mode;\n                                break;\n                            }\n                        }\n                        if (mode == 0) {\n                            *pzErrMsg = sqlite3_mprintf(\"no such %s mode: %s\", zModeType, zVal);\n                            rc = 1;\n                            goto parse_uri_out;\n                        }\n                        if ((mode & ~128) > limit) {\n                            *pzErrMsg = sqlite3_mprintf(\"%s mode not allowed: %s\", zModeType, zVal);\n                            rc = 3;\n                            goto parse_uri_out;\n                        }\n                        flags = (flags & ~mask) | mode;\n                    }\n                }\n                zOpt = &zVal[nVal + 1];\n            }\n    } else {\n        zFile = sqlite3_malloc64(nUri + 8);\n        if (!zFile)\n            return 7;\n        __builtin___memset_chk(zFile, 0, 4, __builtin_object_size(zFile, 0));\n        zFile += 4;\n        if (nUri) {\n            __builtin___memcpy_chk(zFile, zUri, nUri, __builtin_object_size(zFile, 0));\n        }\n        __builtin___memset_chk(zFile + nUri, 0, 4, __builtin_object_size(zFile + nUri, 0));\n        flags &= ~64;\n    }\n    *ppVfs = sqlite3_vfs_find(zVfs);\n    if (*ppVfs == 0) {\n        *pzErrMsg = sqlite3_mprintf(\"no such vfs: %s\", zVfs);\n        rc = 1;\n    }\n  parse_uri_out:\n    if (rc != 0) {\n        sqlite3_free_filename(zFile);\n        zFile = 0;\n    }\n    *pFlags = flags;\n    *pzFile = zFile;\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#133056:1#sqlite3LoadExtension",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = db->pVfs;\n    void *handle;\n    sqlite3_loadext_entry xInit;\n    char *zErrmsg = 0;\n    const char *zEntry;\n    char *zAltEntry = 0;\n    void **aHandle;\n    u64 nMsg = strlen(zFile);\n    int ii;\n    int rc;\n    static const char *azEndings[] = {\"dylib\"};\n    if (pzErrMsg)\n        *pzErrMsg = 0;\n    if ((db->flags & 65536) == 0) {\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"not authorized\");\n        }\n        return 1;\n    }\n    zEntry = zProc ? zProc : \"sqlite3_extension_init\";\n    if (nMsg > 1024)\n        goto extension_not_found;\n    handle = sqlite3OsDlOpen(pVfs, zFile);\n    for (ii = 0; ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0; ii++) {\n        char *zAltFile = sqlite3_mprintf(\"%s.%s\", zFile, azEndings[ii]);\n        if (zAltFile == 0)\n            return 7;\n        handle = sqlite3OsDlOpen(pVfs, zAltFile);\n        sqlite3_free(zAltFile);\n    }\n    if (handle == 0)\n        goto extension_not_found;\n    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    if (xInit == 0 && zProc == 0) {\n        int iFile, iEntry, c;\n        int ncFile = sqlite3Strlen30(zFile);\n        zAltEntry = sqlite3_malloc64(ncFile + 30);\n        if (zAltEntry == 0) {\n            sqlite3OsDlClose(pVfs, handle);\n            return 7;\n        }\n        __builtin___memcpy_chk(zAltEntry, \"sqlite3_\", 8, __builtin_object_size(zAltEntry, 0));\n        for (iFile = ncFile - 1; iFile >= 0 && !((zFile[iFile]) == '/'); iFile--) {\n        }\n        iFile++;\n        if (sqlite3_strnicmp(zFile + iFile, \"lib\", 3) == 0)\n            iFile += 3;\n        for (iEntry = 8; (c = zFile[iFile]) != 0 && c != '.'; iFile++) {\n            if ((sqlite3CtypeMap[(unsigned char)(c)] & 2)) {\n                zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned int)c];\n            }\n        }\n        __builtin___memcpy_chk(zAltEntry + iEntry, \"_init\", 6, __builtin_object_size(zAltEntry + iEntry, 0));\n        zEntry = zAltEntry;\n        xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    }\n    if (xInit == 0) {\n        if (pzErrMsg) {\n            nMsg += strlen(zEntry) + 300;\n            *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n            if (zErrmsg) {\n                ((void)0);\n                sqlite3_snprintf((int)nMsg, zErrmsg, \"no entry point [%s] in shared library [%s]\", zEntry, zFile);\n                sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n            }\n        }\n        sqlite3OsDlClose(pVfs, handle);\n        sqlite3_free(zAltEntry);\n        return 1;\n    }\n    sqlite3_free(zAltEntry);\n    rc = xInit(db, &zErrmsg, &sqlite3Apis);\n    if (rc) {\n        if (rc == (0 | (1 << 8)))\n            return 0;\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"error during initialization: %s\", zErrmsg);\n        }\n        sqlite3_free(zErrmsg);\n        sqlite3OsDlClose(pVfs, handle);\n        return 1;\n    }\n    aHandle = sqlite3DbMallocZero(db, sizeof (handle) * (db->nExtension + 1));\n    if (aHandle == 0) {\n        return 7;\n    }\n    if (db->nExtension > 0) {\n        __builtin___memcpy_chk(aHandle, db->aExtension, sizeof (handle) * db->nExtension, __builtin_object_size(aHandle, 0));\n    }\n    sqlite3DbFree(db, db->aExtension);\n    db->aExtension = aHandle;\n    db->aExtension[db->nExtension++] = handle;\n    return 0;\n  extension_not_found:\n    if (pzErrMsg) {\n        nMsg += 300;\n        *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n        if (zErrmsg) {\n            ((void)0);\n            sqlite3_snprintf((int)nMsg, zErrmsg, \"unable to open shared library [%.*s]\", 1024, zFile);\n            sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n        }\n    }\n    return 1;\n}\n"
  },
  {
    "id": "sqlite3.c#41490:1#unixOpenSharedMemory",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    struct unixShm *p = 0;\n    struct unixShmNode *pShmNode;\n    int rc = 0;\n    unixInodeInfo *pInode;\n    char *zShm;\n    int nShmFilename;\n    p = sqlite3_malloc64(sizeof (*p));\n    if (p == 0)\n        return 7;\n    __builtin___memset_chk(p, 0, sizeof (*p), __builtin_object_size(p, 0));\n    ((void)0);\n    ((void)0);\n    unixEnterMutex();\n    pInode = pDbFd->pInode;\n    pShmNode = pInode->pShmNode;\n    if (pShmNode == 0) {\n        struct stat sStat;\n        const char *zBasePath = pDbFd->zPath;\n        if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pDbFd->h, &sStat)) {\n            rc = (10 | (7 << 8));\n            goto shm_open_err;\n        }\n        nShmFilename = 6 + (int)strlen(zBasePath);\n        pShmNode = sqlite3_malloc64(sizeof (*pShmNode) + nShmFilename);\n        if (pShmNode == 0) {\n            rc = 7;\n            goto shm_open_err;\n        }\n        __builtin___memset_chk(pShmNode, 0, sizeof (*pShmNode) + nShmFilename, __builtin_object_size(pShmNode, 0));\n        zShm = pShmNode->zFilename = (char *)&pShmNode[1];\n        sqlite3_snprintf(nShmFilename, zShm, \"%s-shm\", zBasePath);\n        ;\n        pShmNode->hShm = -1;\n        pDbFd->pInode->pShmNode = pShmNode;\n        pShmNode->pInode = pDbFd->pInode;\n        if (sqlite3Config.bCoreMutex) {\n            pShmNode->pShmMutex = sqlite3_mutex_alloc(0);\n            if (pShmNode->pShmMutex == 0) {\n                rc = 7;\n                goto shm_open_err;\n            }\n        }\n        if (pInode->bProcessLock == 0) {\n            if (0 == sqlite3_uri_boolean(pDbFd->zPath, \"readonly_shm\", 0)) {\n                pShmNode->hShm = robust_open(zShm, 2 | 512 | 256, (sStat.st_mode & 511));\n            }\n            if (pShmNode->hShm < 0) {\n                pShmNode->hShm = robust_open(zShm, 0 | 256, (sStat.st_mode & 511));\n                if (pShmNode->hShm < 0) {\n                    rc = unixLogErrorAtLine(sqlite3CantopenError(41566), \"open\", zShm, 41566);\n                    goto shm_open_err;\n                }\n                pShmNode->isReadonly = 1;\n            }\n            robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);\n            rc = unixLockSharedMemory(pDbFd, pShmNode);\n            if (rc != 0 && rc != (8 | (5 << 8)))\n                goto shm_open_err;\n        }\n    }\n    p->pShmNode = pShmNode;\n    pShmNode->nRef++;\n    pDbFd->pShm = p;\n    unixLeaveMutex();\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    p->pNext = pShmNode->pFirst;\n    pShmNode->pFirst = p;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n  shm_open_err:\n    unixShmPurge(pDbFd);\n    sqlite3_free(p);\n    unixLeaveMutex();\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#44075:1#proxyBreakConchLock",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *conchFile = pCtx->conchFile;\n    char tPath[1024];\n    char buf[1041];\n    char *cPath = pCtx->conchFilePath;\n    size_t readLen = 0;\n    size_t pathLen = 0;\n    char errmsg[64] = \"\";\n    int fd = -1;\n    int rc = -1;\n    (void)(myHostID);\n    pathLen = __builtin___strlcpy_chk(tPath, cPath, 1024, __builtin_object_size(tPath, 2 > 1 ? 1 : 0));\n    if (pathLen > 1024 || pathLen < 6 || (__builtin___strlcpy_chk(&tPath[pathLen - 5], \"break\", 6, __builtin_object_size(&tPath[pathLen - 5], 2 > 1 ? 1 : 0)) != 5)) {\n        sqlite3_snprintf(sizeof (errmsg), errmsg, \"path error (len %d)\", (int)pathLen);\n        goto end_breaklock;\n    }\n    readLen = ((ssize_t (*)(int, void *, size_t, off_t))aSyscall[9].pCurrent)(conchFile->h, buf, (1 + 16 + 1024), 0);\n    if (readLen < (1 + 16)) {\n        sqlite3_snprintf(sizeof (errmsg), errmsg, \"read error (len %d)\", (int)readLen);\n        goto end_breaklock;\n    }\n    fd = robust_open(tPath, (2 | 512 | 2048 | 256), 0);\n    if (fd < 0) {\n        sqlite3_snprintf(sizeof (errmsg), errmsg, \"create failed (%d)\", (*__error()));\n        goto end_breaklock;\n    }\n    if (((ssize_t (*)(int, const void *, size_t, off_t))aSyscall[12].pCurrent)(fd, buf, readLen, 0) != (ssize_t)readLen) {\n        sqlite3_snprintf(sizeof (errmsg), errmsg, \"write failed (%d)\", (*__error()));\n        goto end_breaklock;\n    }\n    if (rename(tPath, cPath)) {\n        sqlite3_snprintf(sizeof (errmsg), errmsg, \"rename failed (%d)\", (*__error()));\n        goto end_breaklock;\n    }\n    rc = 0;\n    fprintf(__stderrp, \"broke stale lock on %s\\n\", cPath);\n    robust_close(pFile, conchFile->h, 44117);\n    conchFile->h = fd;\n    conchFile->openFlags = 2 | 512;\n  end_breaklock:\n    if (rc) {\n        if (fd >= 0) {\n            ((int (*)(const char *))aSyscall[16].pCurrent)(tPath);\n            robust_close(pFile, fd, 44125);\n        }\n        fprintf(__stderrp, \"failed to break stale lock on %s, %s\\n\", cPath, errmsg);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#114316:1#dropColumnFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int iSchema = sqlite3_value_int(argv[0]);\n    const char *zSql = (const char *)sqlite3_value_text(argv[1]);\n    int iCol = sqlite3_value_int(argv[2]);\n    const char *zDb = db->aDb[iSchema].zDbSName;\n    int rc;\n    Parse sParse;\n    RenameToken *pCol;\n    Table *pTab;\n    const char *zEnd;\n    char *zNew = 0;\n    sqlite3_xauth xAuth = db->xAuth;\n    db->xAuth = 0;\n    (void)(NotUsed);\n    rc = renameParseSql(&sParse, zDb, db, zSql, iSchema == 1);\n    if (rc != 0)\n        goto drop_column_done;\n    pTab = sParse.pNewTable;\n    if (pTab == 0 || pTab->nCol == 1 || iCol >= pTab->nCol) {\n        rc = sqlite3CorruptError(114344);\n        goto drop_column_done;\n    }\n    pCol = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol].zCnName);\n    if (iCol < pTab->nCol - 1) {\n        RenameToken *pEnd;\n        pEnd = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol + 1].zCnName);\n        zEnd = (const char *)pEnd->t.z;\n    } else {\n        ((void)0);\n        zEnd = (const char *)&zSql[pTab->u.tab.addColOffset];\n        while ((pCol->t.z[0] != 0) && pCol->t.z[0] != ',')\n            pCol->t.z--;\n    }\n    zNew = sqlite3MPrintf(db, \"%.*s%s\", pCol->t.z - zSql, zSql, zEnd);\n    sqlite3_result_text(context, zNew, -1, ((sqlite3_destructor_type)-1));\n    sqlite3_free(zNew);\n  drop_column_done:\n    renameParseCleanup(&sParse);\n    db->xAuth = xAuth;\n    if (rc != 0) {\n        sqlite3_result_error_code(context, rc);\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#38809:1#posixUnlock",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int rc = 0;\n    ((void)0);\n    ;\n    ((void)0);\n    if (pFile->eFileLock <= eFileLock) {\n        return 0;\n    }\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    ((void)0);\n    if (pFile->eFileLock > 1) {\n        ((void)0);\n        if (eFileLock == 1) {\n            if (handleNFSUnlock) {\n                int tErrno;\n                off_t divSize = 510 - 1;\n                lock.l_type = 2;\n                lock.l_whence = 0;\n                lock.l_start = (sqlite3PendingByte + 2);\n                lock.l_len = divSize;\n                if (unixFileLock(pFile, &lock) == (-1)) {\n                    tErrno = (*__error());\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n                lock.l_type = 1;\n                lock.l_whence = 0;\n                lock.l_start = (sqlite3PendingByte + 2);\n                lock.l_len = divSize;\n                if (unixFileLock(pFile, &lock) == (-1)) {\n                    tErrno = (*__error());\n                    rc = sqliteErrorFromPosixError(tErrno, (10 | (9 << 8)));\n                    if (((rc != 0) && (rc != 5))) {\n                        storeLastErrno(pFile, tErrno);\n                    }\n                    goto end_unlock;\n                }\n                lock.l_type = 2;\n                lock.l_whence = 0;\n                lock.l_start = (sqlite3PendingByte + 2) + divSize;\n                lock.l_len = 510 - divSize;\n                if (unixFileLock(pFile, &lock) == (-1)) {\n                    tErrno = (*__error());\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n            } else {\n                lock.l_type = 1;\n                lock.l_whence = 0;\n                lock.l_start = (sqlite3PendingByte + 2);\n                lock.l_len = 510;\n                if (unixFileLock(pFile, &lock)) {\n                    rc = (10 | (9 << 8));\n                    storeLastErrno(pFile, (*__error()));\n                    goto end_unlock;\n                }\n            }\n        }\n        lock.l_type = 2;\n        lock.l_whence = 0;\n        lock.l_start = sqlite3PendingByte;\n        lock.l_len = 2L;\n        ((void)0);\n        if (unixFileLock(pFile, &lock) == 0) {\n            pInode->eFileLock = 1;\n        } else {\n            rc = (10 | (8 << 8));\n            storeLastErrno(pFile, (*__error()));\n            goto end_unlock;\n        }\n    }\n    if (eFileLock == 0) {\n        pInode->nShared--;\n        if (pInode->nShared == 0) {\n            lock.l_type = 2;\n            lock.l_whence = 0;\n            lock.l_start = lock.l_len = 0L;\n            if (unixFileLock(pFile, &lock) == 0) {\n                pInode->eFileLock = 0;\n            } else {\n                rc = (10 | (8 << 8));\n                storeLastErrno(pFile, (*__error()));\n                pInode->eFileLock = 0;\n                pFile->eFileLock = 0;\n            }\n        }\n        pInode->nLock--;\n        ((void)0);\n        if (pInode->nLock == 0)\n            closePendingFds(pFile);\n    }\n  end_unlock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#113717:1#renameColumnFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    RenameCtx sCtx;\n    const char *zSql = (const char *)sqlite3_value_text(argv[0]);\n    const char *zDb = (const char *)sqlite3_value_text(argv[3]);\n    const char *zTable = (const char *)sqlite3_value_text(argv[4]);\n    int iCol = sqlite3_value_int(argv[5]);\n    const char *zNew = (const char *)sqlite3_value_text(argv[6]);\n    int bQuote = sqlite3_value_int(argv[7]);\n    int bTemp = sqlite3_value_int(argv[8]);\n    const char *zOld;\n    int rc;\n    Parse sParse;\n    Walker sWalker;\n    Index *pIdx;\n    int i;\n    Table *pTab;\n    sqlite3_xauth xAuth = db->xAuth;\n    (void)(NotUsed);\n    if (zSql == 0)\n        return;\n    if (zTable == 0)\n        return;\n    if (zNew == 0)\n        return;\n    if (iCol < 0)\n        return;\n    sqlite3BtreeEnterAll(db);\n    pTab = sqlite3FindTable(db, zTable, zDb);\n    if (pTab == 0 || iCol >= pTab->nCol) {\n        sqlite3BtreeLeaveAll(db);\n        return;\n    }\n    zOld = pTab->aCol[iCol].zCnName;\n    __builtin___memset_chk(&sCtx, 0, sizeof (sCtx), __builtin_object_size(&sCtx, 0));\n    sCtx.iCol = ((iCol == pTab->iPKey) ? -1 : iCol);\n    db->xAuth = 0;\n    rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);\n    __builtin___memset_chk(&sWalker, 0, sizeof(Walker), __builtin_object_size(&sWalker, 0));\n    sWalker.pParse = &sParse;\n    sWalker.xExprCallback = renameColumnExprCb;\n    sWalker.xSelectCallback = renameColumnSelectCb;\n    sWalker.u.pRename = &sCtx;\n    sCtx.pTab = pTab;\n    if (rc != 0)\n        goto renameColumnFunc_done;\n    if (sParse.pNewTable) {\n        if (((sParse.pNewTable)->eTabType == 2)) {\n            Select *pSelect = sParse.pNewTable->u.view.pSelect;\n            pSelect->selFlags &= ~2097152;\n            sParse.rc = 0;\n            sqlite3SelectPrep(&sParse, pSelect, 0);\n            rc = (db->mallocFailed ? 7 : sParse.rc);\n            if (rc == 0) {\n                sqlite3WalkSelect(&sWalker, pSelect);\n            }\n            if (rc != 0)\n                goto renameColumnFunc_done;\n        } else if (((sParse.pNewTable)->eTabType == 0)) {\n            int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n            FKey *pFKey;\n            sCtx.pTab = sParse.pNewTable;\n            if (bFKOnly == 0) {\n                if (iCol < sParse.pNewTable->nCol) {\n                    renameTokenFind(&sParse, &sCtx, (void *)sParse.pNewTable->aCol[iCol].zCnName);\n                }\n                if (sCtx.iCol < 0) {\n                    renameTokenFind(&sParse, &sCtx, (void *)&sParse.pNewTable->iPKey);\n                }\n                sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n                for (pIdx = sParse.pNewTable->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (i = 0; i < sParse.pNewTable->nCol; i++) {\n                    Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable->aCol[i]);\n                    sqlite3WalkExpr(&sWalker, pExpr);\n                }\n            }\n            ((void)0);\n            for (pFKey = sParse.pNewTable->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                for (i = 0; i < pFKey->nCol; i++) {\n                    if (bFKOnly == 0 && pFKey->aCol[i].iFrom == iCol) {\n                        renameTokenFind(&sParse, &sCtx, (void *)&pFKey->aCol[i]);\n                    }\n                    if (0 == sqlite3_stricmp(pFKey->zTo, zTable) && 0 == sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)) {\n                        renameTokenFind(&sParse, &sCtx, (void *)pFKey->aCol[i].zCol);\n                    }\n                }\n            }\n        }\n    } else if (sParse.pNewIndex) {\n        sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n        sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n    } else {\n        TriggerStep *pStep;\n        rc = renameResolveTrigger(&sParse);\n        if (rc != 0)\n            goto renameColumnFunc_done;\n        for (pStep = sParse.pNewTrigger->step_list; pStep; pStep = pStep->pNext) {\n            if (pStep->zTarget) {\n                Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n                if (pTarget == pTab) {\n                    if (pStep->pUpsert) {\n                        ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n                        renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n                    }\n                    renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n                    renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n                }\n            }\n        }\n        if (sParse.pTriggerTab == pTab) {\n            renameColumnIdlistNames(&sParse, &sCtx, sParse.pNewTrigger->pColumns, zOld);\n        }\n        renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n    }\n    ((void)0);\n    rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n  renameColumnFunc_done:\n    if (rc != 0) {\n        if (rc == 1 && sqlite3WritableSchema(db)) {\n            sqlite3_result_value(context, argv[0]);\n        } else if (sParse.zErrMsg) {\n            renameColumnParseError(context, \"\", argv[1], argv[2], &sParse);\n        } else {\n            sqlite3_result_error_code(context, rc);\n        }\n    }\n    renameParseCleanup(&sParse);\n    renameTokenFree(db, sCtx.pList);\n    db->xAuth = xAuth;\n    sqlite3BtreeLeaveAll(db);\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateView",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Table *p;\n    int n;\n    const char *z;\n    Token sEnd;\n    DbFixer sFix;\n    Token *pName = 0;\n    int iDb;\n    sqlite3 *db = pParse->db;\n    if (pParse->nVar > 0) {\n        sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n        goto create_view_fail;\n    }\n    sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n    p = pParse->pNewTable;\n    if (p == 0 || pParse->nErr)\n        goto create_view_fail;\n    p->tabFlags |= 512;\n    sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    iDb = sqlite3SchemaToIndex(db, p->pSchema);\n    sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);\n    if (sqlite3FixSelect(&sFix, pSelect))\n        goto create_view_fail;\n    pSelect->selFlags |= 2097152;\n    if ((pParse->eParseMode >= 2)) {\n        p->u.view.pSelect = pSelect;\n        pSelect = 0;\n    } else {\n        p->u.view.pSelect = sqlite3SelectDup(db, pSelect, 1);\n    }\n    p->pCheck = sqlite3ExprListDup(db, pCNames, 1);\n    p->eTabType = 2;\n    if (db->mallocFailed)\n        goto create_view_fail;\n    sEnd = pParse->sLastToken;\n    ((void)0);\n    if (sEnd.z[0] != ';') {\n        sEnd.z += sEnd.n;\n    }\n    sEnd.n = 0;\n    n = (int)(sEnd.z - pBegin->z);\n    ((void)0);\n    z = pBegin->z;\n    while ((sqlite3CtypeMap[(unsigned char)(z[n - 1])] & 1))\n        {\n            n--;\n        }\n    sEnd.z = &z[n - 1];\n    sEnd.n = 1;\n    sqlite3EndTable(pParse, 0, &sEnd, 0, 0);\n  create_view_fail:\n    sqlite3SelectDelete(db, pSelect);\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameExprlistUnmap(pParse, pCNames);\n    }\n    sqlite3ExprListDelete(db, pCNames);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfFalse",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    ((void)0);\n    if ((v == 0))\n        return;\n    if (pExpr == 0)\n        return;\n    ((void)0);\n    op = ((pExpr->op + (50 & 1)) ^ 1) - (50 & 1);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    switch (pExpr->op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n            } else if (pExpr->op == 44) {\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n            } else {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            } else {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (pExpr->op == 45) ? 52 : 53;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            if (jumpIfNull) {\n                sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n            } else {\n                int destIfNull = sqlite3VdbeMakeLabel(pParse);\n                sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n                sqlite3VdbeResolveLabel(v, destIfNull);\n            }\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "#23:25#sqlite3FinishTrigger",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Trigger *pTrig = pParse->pNewTrigger;\n    char *zName;\n    sqlite3 *db = pParse->db;\n    DbFixer sFix;\n    int iDb;\n    Token nameToken;\n    pParse->pNewTrigger = 0;\n    if ((pParse->nErr) || !pTrig)\n        goto triggerfinish_cleanup;\n    zName = pTrig->zName;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);\n    pTrig->step_list = pStepList;\n    while (pStepList)\n        {\n            pStepList->pTrig = pTrig;\n            pStepList = pStepList->pNext;\n        }\n    sqlite3TokenInit(&nameToken, pTrig->zName);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", &nameToken);\n    if (sqlite3FixTriggerStep(&sFix, pTrig->step_list) || sqlite3FixExpr(&sFix, pTrig->pWhen)) {\n        goto triggerfinish_cleanup;\n    }\n    if ((pParse->eParseMode >= 2)) {\n        ((void)0);\n        pParse->pNewTrigger = pTrig;\n        pTrig = 0;\n    } else if (!db->init.busy) {\n        Vdbe *v;\n        char *z;\n        if (sqlite3ReadOnlyShadowTables(db)) {\n            TriggerStep *pStep;\n            for (pStep = pTrig->step_list; pStep; pStep = pStep->pNext) {\n                if (pStep->zTarget != 0 && sqlite3ShadowTableName(db, pStep->zTarget)) {\n                    sqlite3ErrorMsg(pParse, \"trigger \\\"%s\\\" may not write to shadow table \\\"%s\\\"\", pTrig->zName, pStep->zTarget);\n                    goto triggerfinish_cleanup;\n                }\n            }\n        }\n        v = sqlite3GetVdbe(pParse);\n        if (v == 0)\n            goto triggerfinish_cleanup;\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        z = sqlite3DbStrNDup(db, (char *)pAll->z, pAll->n);\n        ;\n        sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\", db->aDb[iDb].zDbSName, zName, pTrig->table, z);\n        sqlite3DbFree(db, z);\n        sqlite3ChangeCookie(pParse, iDb);\n        sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"type='trigger' AND name='%q'\", zName), 0);\n    }\n    if (db->init.busy) {\n        Trigger *pLink = pTrig;\n        Hash *pHash = &db->aDb[iDb].pSchema->trigHash;\n        ((void)0);\n        ((void)0);\n        pTrig = sqlite3HashInsert(pHash, zName, pTrig);\n        if (pTrig) {\n            sqlite3OomFault(db);\n        } else if (pLink->pSchema == pLink->pTabSchema) {\n            Table *pTab;\n            pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);\n            ((void)0);\n            pLink->pNext = pTab->pTrigger;\n            pTab->pTrigger = pLink;\n        }\n    }\n  triggerfinish_cleanup:\n    sqlite3DeleteTrigger(db, pTrig);\n    ((void)0);\n    sqlite3DeleteTriggerStep(db, pStepList);\n}\n"
  },
  {
    "id": "sqlite3.c#88744:12#sqlite3_set_auxdata",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    AuxData *pAuxData;\n    Vdbe *pVdbe = pCtx->pVdbe;\n    ((void)0);\n    ((void)0);\n    for (pAuxData = pVdbe->pAuxData; pAuxData; pAuxData = pAuxData->pNextAux) {\n        if (pAuxData->iAuxArg == iArg && (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)) {\n            break;\n        }\n    }\n    if (pAuxData == 0) {\n        pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));\n        if (!pAuxData)\n            goto failed;\n        pAuxData->iAuxOp = pCtx->iOp;\n        pAuxData->iAuxArg = iArg;\n        pAuxData->pNextAux = pVdbe->pAuxData;\n        pVdbe->pAuxData = pAuxData;\n        if (pCtx->isError == 0)\n            pCtx->isError = -1;\n    } else if (pAuxData->xDeleteAux) {\n        pAuxData->xDeleteAux(pAuxData->pAux);\n    }\n    pAuxData->pAux = pAux;\n    pAuxData->xDeleteAux = xDelete;\n    return;\n  failed:\n    if (xDelete) {\n        xDelete(pAux);\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#177463:12#sqlite3_table_column_metadata",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc;\n    char *zErrMsg = 0;\n    Table *pTab = 0;\n    Column *pCol = 0;\n    int iCol = 0;\n    const char *zDataType = 0;\n    const char *zCollSeq = 0;\n    int notnull = 0;\n    int primarykey = 0;\n    int autoinc = 0;\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3BtreeEnterAll(db);\n    rc = sqlite3Init(db, &zErrMsg);\n    if (0 != rc) {\n        goto error_out;\n    }\n    pTab = sqlite3FindTable(db, zTableName, zDbName);\n    if (!pTab || ((pTab)->eTabType == 2)) {\n        pTab = 0;\n        goto error_out;\n    }\n    if (zColumnName == 0) {\n    } else {\n        for (iCol = 0; iCol < pTab->nCol; iCol++) {\n            pCol = &pTab->aCol[iCol];\n            if (0 == sqlite3StrICmp(pCol->zCnName, zColumnName)) {\n                break;\n            }\n        }\n        if (iCol == pTab->nCol) {\n            if ((((pTab)->tabFlags & 128) == 0) && sqlite3IsRowid(zColumnName)) {\n                iCol = pTab->iPKey;\n                pCol = iCol >= 0 ? &pTab->aCol[iCol] : 0;\n            } else {\n                pTab = 0;\n                goto error_out;\n            }\n        }\n    }\n    if (pCol) {\n        zDataType = sqlite3ColumnType(pCol, 0);\n        zCollSeq = sqlite3ColumnColl(pCol);\n        notnull = pCol->notNull != 0;\n        primarykey = (pCol->colFlags & 1) != 0;\n        autoinc = pTab->iPKey == iCol && (pTab->tabFlags & 8) != 0;\n    } else {\n        zDataType = \"INTEGER\";\n        primarykey = 1;\n    }\n    if (!zCollSeq) {\n        zCollSeq = sqlite3StrBINARY;\n    }\n  error_out:\n    sqlite3BtreeLeaveAll(db);\n    if (pzDataType)\n        *pzDataType = zDataType;\n    if (pzCollSeq)\n        *pzCollSeq = zCollSeq;\n    if (pNotNull)\n        *pNotNull = notnull;\n    if (pPrimaryKey)\n        *pPrimaryKey = primarykey;\n    if (pAutoinc)\n        *pAutoinc = autoinc;\n    if (0 == rc && !pTab) {\n        sqlite3DbFree(db, zErrMsg);\n        zErrMsg = sqlite3MPrintf(db, \"no such table column: %s.%s\", zTableName, zColumnName);\n        rc = 1;\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErrMsg ? \"%s\" : 0), zErrMsg);\n    sqlite3DbFree(db, zErrMsg);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#69872:1#defragmentPage",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int i;\n    int pc;\n    int hdr;\n    int size;\n    int usableSize;\n    int cellOffset;\n    int cbrk;\n    int nCell;\n    unsigned char *data;\n    unsigned char *temp;\n    unsigned char *src;\n    int iCellFirst;\n    int iCellLast;\n    int iCellStart;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    cellOffset = pPage->cellOffset;\n    nCell = pPage->nCell;\n    ((void)0);\n    iCellFirst = cellOffset + 2 * nCell;\n    usableSize = pPage->pBt->usableSize;\n    if ((int)data[hdr + 7] <= nMaxFrag) {\n        int iFree = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        if (iFree > usableSize - 4)\n            return sqlite3CorruptError(69908);\n        if (iFree) {\n            int iFree2 = ((&data[iFree])[0] << 8 | (&data[iFree])[1]);\n            if (iFree2 > usableSize - 4)\n                return sqlite3CorruptError(69911);\n            if (0 == iFree2 || (data[iFree2] == 0 && data[iFree2 + 1] == 0)) {\n                u8 *pEnd = &data[cellOffset + nCell * 2];\n                u8 *pAddr;\n                int sz2 = 0;\n                int sz = ((&data[iFree + 2])[0] << 8 | (&data[iFree + 2])[1]);\n                int top = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n                if (top >= iFree) {\n                    return sqlite3CorruptError(69919);\n                }\n                if (iFree2) {\n                    if (iFree + sz > iFree2)\n                        return sqlite3CorruptError(69922);\n                    sz2 = ((&data[iFree2 + 2])[0] << 8 | (&data[iFree2 + 2])[1]);\n                    if (iFree2 + sz2 > usableSize)\n                        return sqlite3CorruptError(69924);\n                    __builtin___memmove_chk(&data[iFree + sz + sz2], &data[iFree + sz], iFree2 - (iFree + sz), __builtin_object_size(&data[iFree + sz + sz2], 0));\n                    sz += sz2;\n                } else if (iFree + sz > usableSize) {\n                    return sqlite3CorruptError(69928);\n                }\n                cbrk = top + sz;\n                ((void)0);\n                __builtin___memmove_chk(&data[cbrk], &data[top], iFree - top, __builtin_object_size(&data[cbrk], 0));\n                for (pAddr = &data[cellOffset]; pAddr < pEnd; pAddr += 2) {\n                    pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n                    if (pc < iFree) {\n                        ((pAddr)[0] = (u8)((pc + sz) >> 8) , (pAddr)[1] = (u8)(pc + sz));\n                    } else if (pc < iFree2) {\n                        ((pAddr)[0] = (u8)((pc + sz2) >> 8) , (pAddr)[1] = (u8)(pc + sz2));\n                    }\n                }\n                goto defragment_out;\n            }\n        }\n    }\n    cbrk = usableSize;\n    iCellLast = usableSize - 4;\n    iCellStart = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n    if (nCell > 0) {\n        temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n        __builtin___memcpy_chk(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart, __builtin_object_size(&temp[iCellStart], 0));\n        src = temp;\n        for (i = 0; i < nCell; i++) {\n            u8 *pAddr;\n            pAddr = &data[cellOffset + i * 2];\n            pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n            ;\n            ;\n            if (pc < iCellStart || pc > iCellLast) {\n                return sqlite3CorruptError(69961);\n            }\n            ((void)0);\n            size = pPage->xCellSize(pPage, &src[pc]);\n            cbrk -= size;\n            if (cbrk < iCellStart || pc + size > usableSize) {\n                return sqlite3CorruptError(69967);\n            }\n            ((void)0);\n            ;\n            ;\n            ((pAddr)[0] = (u8)((cbrk) >> 8) , (pAddr)[1] = (u8)(cbrk));\n            __builtin___memcpy_chk(&data[cbrk], &src[pc], size, __builtin_object_size(&data[cbrk], 0));\n        }\n    }\n    data[hdr + 7] = 0;\n  defragment_out:\n    ((void)0);\n    if (data[hdr + 7] + cbrk - iCellFirst != pPage->nFree) {\n        return sqlite3CorruptError(69981);\n    }\n    ((void)0);\n    ((&data[hdr + 5])[0] = (u8)((cbrk) >> 8) , (&data[hdr + 5])[1] = (u8)(cbrk));\n    data[hdr + 1] = 0;\n    data[hdr + 2] = 0;\n    __builtin___memset_chk(&data[iCellFirst], 0, cbrk - iCellFirst, __builtin_object_size(&data[iCellFirst], 0));\n    ((void)0);\n    return 0;\n}\n"
  },
  {
    "id": "sqlite3.c#41632:1#unixShmMap",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    unixFile *pDbFd = (unixFile *)fd;\n    unixShm *p;\n    unixShmNode *pShmNode;\n    int rc = 0;\n    int nShmPerMap = unixShmRegionPerMap();\n    int nReqRegion;\n    if (pDbFd->pShm == 0) {\n        rc = unixOpenSharedMemory(pDbFd);\n        if (rc != 0)\n            return rc;\n    }\n    p = pDbFd->pShm;\n    pShmNode = p->pShmNode;\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    if (pShmNode->isUnlocked) {\n        rc = unixLockSharedMemory(pDbFd, pShmNode);\n        if (rc != 0)\n            goto shmpage_out;\n        pShmNode->isUnlocked = 0;\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    nReqRegion = ((iRegion + nShmPerMap) / nShmPerMap) * nShmPerMap;\n    if (pShmNode->nRegion < nReqRegion) {\n        char **apNew;\n        int nByte = nReqRegion * szRegion;\n        struct stat sStat;\n        pShmNode->szRegion = szRegion;\n        if (pShmNode->hShm >= 0) {\n            if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pShmNode->hShm, &sStat)) {\n                rc = (10 | (19 << 8));\n                goto shmpage_out;\n            }\n            if (sStat.st_size < nByte) {\n                if (!bExtend) {\n                    goto shmpage_out;\n                } else {\n                    static const int pgsz = 4096;\n                    int iPg;\n                    ((void)0);\n                    for (iPg = (sStat.st_size / pgsz); iPg < (nByte / pgsz); iPg++) {\n                        int x = 0;\n                        if (seekAndWriteFd(pShmNode->hShm, iPg * pgsz + pgsz - 1, \"\", 1, &x) != 1) {\n                            const char *zFile = pShmNode->zFilename;\n                            rc = unixLogErrorAtLine((10 | (19 << 8)), \"write\", zFile, 41710);\n                            goto shmpage_out;\n                        }\n                    }\n                }\n            }\n        }\n        apNew = (char **)sqlite3_realloc(pShmNode->apRegion, nReqRegion * sizeof(char *));\n        if (!apNew) {\n            rc = (10 | (12 << 8));\n            goto shmpage_out;\n        }\n        pShmNode->apRegion = apNew;\n        while (pShmNode->nRegion < nReqRegion)\n            {\n                int nMap = szRegion * nShmPerMap;\n                int i;\n                void *pMem;\n                if (pShmNode->hShm >= 0) {\n                    pMem = ((void *(*)(void *, size_t, int, int, int, off_t))aSyscall[22].pCurrent)(0, nMap, pShmNode->isReadonly ? 1 : 1 | 2, 1, pShmNode->hShm, szRegion * (i64)pShmNode->nRegion);\n                    if (pMem == ((void *)-1)) {\n                        rc = unixLogErrorAtLine((10 | (21 << 8)), \"mmap\", pShmNode->zFilename, 41737);\n                        goto shmpage_out;\n                    }\n                } else {\n                    pMem = sqlite3_malloc64(nMap);\n                    if (pMem == 0) {\n                        rc = 7;\n                        goto shmpage_out;\n                    }\n                    __builtin___memset_chk(pMem, 0, nMap, __builtin_object_size(pMem, 0));\n                }\n                for (i = 0; i < nShmPerMap; i++) {\n                    pShmNode->apRegion[pShmNode->nRegion + i] = &((char *)pMem)[szRegion * i];\n                }\n                pShmNode->nRegion += nShmPerMap;\n            }\n    }\n  shmpage_out:\n    if (pShmNode->nRegion > iRegion) {\n        *pp = pShmNode->apRegion[iRegion];\n    } else {\n        *pp = 0;\n    }\n    if (pShmNode->isReadonly && rc == 0)\n        rc = 8;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Pragma",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    char *zLeft = 0;\n    char *zRight = 0;\n    const char *zDb = 0;\n    Token *pId;\n    char *aFcntl[4];\n    int iDb;\n    int rc;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    const PragmaName *pPragma;\n    if (v == 0)\n        return;\n    sqlite3VdbeRunOnlyOnce(v);\n    pParse->nMem = 2;\n    iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n    if (iDb < 0)\n        return;\n    pDb = &db->aDb[iDb];\n    if (iDb == 1 && sqlite3OpenTempDatabase(pParse)) {\n        return;\n    }\n    zLeft = sqlite3NameFromToken(db, pId);\n    if (!zLeft)\n        return;\n    if (minusFlag) {\n        zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n    } else {\n        zRight = sqlite3NameFromToken(db, pValue);\n    }\n    ((void)0);\n    zDb = pId2->n > 0 ? pDb->zDbSName : 0;\n    if (sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb)) {\n        goto pragma_out;\n    }\n    aFcntl[0] = 0;\n    aFcntl[1] = zLeft;\n    aFcntl[2] = zRight;\n    aFcntl[3] = 0;\n    db->busyHandler.nBusy = 0;\n    rc = sqlite3_file_control(db, zDb, 14, (void *)aFcntl);\n    if (rc == 0) {\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, 0, aFcntl[0], ((sqlite3_destructor_type)-1));\n        returnSingleText(v, aFcntl[0]);\n        sqlite3_free(aFcntl[0]);\n        goto pragma_out;\n    }\n    if (rc != 12) {\n        if (aFcntl[0]) {\n            sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n            sqlite3_free(aFcntl[0]);\n        }\n        pParse->nErr++;\n        pParse->rc = rc;\n        goto pragma_out;\n    }\n    pPragma = pragmaLocate(zLeft);\n    if (pPragma == 0) {\n        goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 1) != 0) {\n        if (sqlite3ReadSchema(pParse))\n            goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 2) == 0 && ((pPragma->mPragFlg & 4) == 0 || zRight == 0)) {\n        setPragmaResultColumnNames(v, pPragma);\n    }\n    switch (pPragma->ePragTyp) {\n      case 13:\n        {\n            static const int iLn = 0;\n            static const VdbeOpList getCacheSize[] = {{2, 0, 0, 0}, {99, 0, 1, 3}, {59, 1, 8, 0}, {71, 0, 2, 0}, {107, 1, 2, 1}, {59, 1, 8, 0}, {71, 0, 1, 0}, {184, 0, 0, 0}, {84, 1, 1, 0}};\n            VdbeOp *aOp;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (!zRight) {\n                pParse->nMem += 2;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (getCacheSize) / sizeof (getCacheSize[0]))), getCacheSize, iLn);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[6].p1 = -2000;\n            } else {\n                int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n                sqlite3BeginWriteOperation(pParse, 0, iDb);\n                sqlite3VdbeAddOp3(v, 100, iDb, 3, size);\n                ((void)0);\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 31:\n        {\n            Btree *pBt = pDb->pBt;\n            ((void)0);\n            if (!zRight) {\n                int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n                returnSingleInt(v, size);\n            } else {\n                db->nextPagesize = sqlite3Atoi(zRight);\n                if (7 == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, 0, 0)) {\n                    sqlite3OomFault(db);\n                }\n            }\n            break;\n        }\n      case 33:\n        {\n            Btree *pBt = pDb->pBt;\n            int b = -1;\n            ((void)0);\n            if (zRight) {\n                if (sqlite3_stricmp(zRight, \"fast\") == 0) {\n                    b = 2;\n                } else {\n                    b = sqlite3GetBoolean(zRight, 0);\n                }\n            }\n            if (pId2->n == 0 && b >= 0) {\n                int ii;\n                for (ii = 0; ii < db->nDb; ii++) {\n                    sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n                }\n            }\n            b = sqlite3BtreeSecureDelete(pBt, b);\n            returnSingleInt(v, b);\n            break;\n        }\n      case 27:\n        {\n            int iReg;\n            i64 x = 0;\n            sqlite3CodeVerifySchema(pParse, iDb);\n            iReg = ++pParse->nMem;\n            if ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'p') {\n                sqlite3VdbeAddOp2(v, 177, iDb, iReg);\n            } else {\n                if (zRight && sqlite3DecOrHexToI64(zRight, &x) == 0) {\n                    if (x < 0)\n                        x = 0;\n                    else if (x > 4294967294U)\n                        x = 4294967294U;\n                } else {\n                    x = 0;\n                }\n                sqlite3VdbeAddOp3(v, 178, iDb, iReg, (int)x);\n            }\n            sqlite3VdbeAddOp2(v, 84, iReg, 1);\n            break;\n        }\n      case 26:\n        {\n            const char *zRet = \"normal\";\n            int eMode = getLockingMode(zRight);\n            if (pId2->n == 0 && eMode == -1) {\n                eMode = db->dfltLockMode;\n            } else {\n                Pager *pPager;\n                if (pId2->n == 0) {\n                    int ii;\n                    ((void)0);\n                    for (ii = 2; ii < db->nDb; ii++) {\n                        pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n                        sqlite3PagerLockingMode(pPager, eMode);\n                    }\n                    db->dfltLockMode = (u8)eMode;\n                }\n                pPager = sqlite3BtreePager(pDb->pBt);\n                eMode = sqlite3PagerLockingMode(pPager, eMode);\n            }\n            ((void)0);\n            if (eMode == 1) {\n                zRet = \"exclusive\";\n            }\n            returnSingleText(v, zRet);\n            break;\n        }\n      case 23:\n        {\n            int eMode;\n            int ii;\n            if (zRight == 0) {\n                eMode = (-1);\n            } else {\n                const char *zMode;\n                int n = sqlite3Strlen30(zRight);\n                for (eMode = 0; (zMode = sqlite3JournalModename(eMode)) != 0; eMode++) {\n                    if (sqlite3_strnicmp(zRight, zMode, n) == 0)\n                        break;\n                }\n                if (!zMode) {\n                    eMode = (-1);\n                }\n                if (eMode == 2 && (db->flags & 268435456) != 0) {\n                    eMode = (-1);\n                }\n            }\n            if (eMode == (-1) && pId2->n == 0) {\n                iDb = 0;\n                pId2->n = 1;\n            }\n            for (ii = db->nDb - 1; ii >= 0; ii--) {\n                if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                    sqlite3VdbeUsesBtree(v, ii);\n                    sqlite3VdbeAddOp3(v, 4, ii, 1, eMode);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 84, 1, 1);\n            break;\n        }\n      case 24:\n        {\n            Pager *pPager = sqlite3BtreePager(pDb->pBt);\n            i64 iLimit = -2;\n            if (zRight) {\n                sqlite3DecOrHexToI64(zRight, &iLimit);\n                if (iLimit < -1)\n                    iLimit = -1;\n            }\n            iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n            returnSingleInt(v, iLimit);\n            break;\n        }\n      case 3:\n        {\n            Btree *pBt = pDb->pBt;\n            ((void)0);\n            if (!zRight) {\n                returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n            } else {\n                int eAuto = getAutoVacuum(zRight);\n                ((void)0);\n                db->nextAutovac = (u8)eAuto;\n                rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n                if (rc == 0 && (eAuto == 1 || eAuto == 2)) {\n                    static const int iLn = 0;\n                    static const VdbeOpList setMeta6[] = {{2, 0, 1, 0}, {99, 0, 1, 4}, {16, 1, 0, 0}, {70, 0, 2, 0}, {100, 0, 7, 0}};\n                    VdbeOp *aOp;\n                    int iAddr = sqlite3VdbeCurrentAddr(v);\n                    ;\n                    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setMeta6) / sizeof (setMeta6[0]))), setMeta6, iLn);\n                    if ((0))\n                        break;\n                    aOp[0].p1 = iDb;\n                    aOp[1].p1 = iDb;\n                    aOp[2].p2 = iAddr + 4;\n                    aOp[4].p1 = iDb;\n                    aOp[4].p3 = eAuto - 1;\n                    sqlite3VdbeUsesBtree(v, iDb);\n                }\n            }\n            break;\n        }\n      case 19:\n        {\n            int iLimit = 0, addr;\n            if (zRight == 0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit <= 0) {\n                iLimit = 2147483647;\n            }\n            sqlite3BeginWriteOperation(pParse, 0, iDb);\n            sqlite3VdbeAddOp2(v, 71, iLimit, 1);\n            addr = sqlite3VdbeAddOp1(v, 62, iDb);\n            ;\n            sqlite3VdbeAddOp1(v, 84, 1);\n            sqlite3VdbeAddOp2(v, 86, 1, -1);\n            sqlite3VdbeAddOp2(v, 59, 1, addr);\n            ;\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 6:\n        {\n            ((void)0);\n            if (!zRight) {\n                returnSingleInt(v, pDb->pSchema->cache_size);\n            } else {\n                int size = sqlite3Atoi(zRight);\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 7:\n        {\n            ((void)0);\n            if (!zRight) {\n                returnSingleInt(v, (db->flags & 32) == 0 ? 0 : sqlite3BtreeSetSpillSize(pDb->pBt, 0));\n            } else {\n                int size = 1;\n                if (sqlite3GetInt32(zRight, &size)) {\n                    sqlite3BtreeSetSpillSize(pDb->pBt, size);\n                }\n                if (sqlite3GetBoolean(zRight, size != 0)) {\n                    db->flags |= 32;\n                } else {\n                    db->flags &= ~(u64)32;\n                }\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 28:\n        {\n            sqlite3_int64 sz;\n            ((void)0);\n            if (zRight) {\n                int ii;\n                sqlite3DecOrHexToI64(zRight, &sz);\n                if (sz < 0)\n                    sz = sqlite3Config.szMmap;\n                if (pId2->n == 0)\n                    db->szMmap = sz;\n                for (ii = db->nDb - 1; ii >= 0; ii--) {\n                    if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                        sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n                    }\n                }\n            }\n            sz = -1;\n            rc = sqlite3_file_control(db, zDb, 18, &sz);\n            if (rc == 0) {\n                returnSingleInt(v, sz);\n            } else if (rc != 12) {\n                pParse->nErr++;\n                pParse->rc = rc;\n            }\n            break;\n        }\n      case 39:\n        {\n            if (!zRight) {\n                returnSingleInt(v, db->temp_store);\n            } else {\n                changeTempStorage(pParse, zRight);\n            }\n            break;\n        }\n      case 40:\n        {\n            sqlite3_mutex_enter(sqlite3MutexAlloc(11));\n            if (!zRight) {\n                returnSingleText(v, sqlite3_temp_directory);\n            } else {\n                if (zRight[0]) {\n                    int res;\n                    rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);\n                    if (rc != 0 || res == 0) {\n                        sqlite3ErrorMsg(pParse, \"not a writable directory\");\n                        sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n                        goto pragma_out;\n                    }\n                }\n                if (1 == 0 || (1 == 1 && db->temp_store <= 1) || (1 == 2 && db->temp_store == 1)) {\n                    invalidateTempStorage(pParse);\n                }\n                sqlite3_free(sqlite3_temp_directory);\n                if (zRight[0]) {\n                    sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n                } else {\n                    sqlite3_temp_directory = 0;\n                }\n            }\n            sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n            break;\n        }\n      case 25:\n        {\n            if (!zRight) {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                char *proxy_file_path = ((void *)0);\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                sqlite3OsFileControlHint(pFile, 2, &proxy_file_path);\n                returnSingleText(v, proxy_file_path);\n            } else {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                int res;\n                if (zRight[0]) {\n                    res = sqlite3OsFileControl(pFile, 3, zRight);\n                } else {\n                    res = sqlite3OsFileControl(pFile, 3, ((void *)0));\n                }\n                if (res != 0) {\n                    sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n                    goto pragma_out;\n                }\n            }\n            break;\n        }\n      case 36:\n        {\n            if (!zRight) {\n                returnSingleInt(v, pDb->safety_level - 1);\n            } else {\n                if (!db->autoCommit) {\n                    sqlite3ErrorMsg(pParse, \"Safety level may not be changed inside a transaction\");\n                } else if (iDb != 1) {\n                    int iLevel = (getSafetyLevel(zRight, 0, 1) + 1) & 7;\n                    if (iLevel == 0)\n                        iLevel = 1;\n                    pDb->safety_level = iLevel;\n                    pDb->bSyncSet = 1;\n                    setAllPagerFlags(db);\n                }\n            }\n            break;\n        }\n      case 4:\n        {\n            if (zRight == 0) {\n                setPragmaResultColumnNames(v, pPragma);\n                returnSingleInt(v, (db->flags & pPragma->iArg) != 0);\n            } else {\n                u64 mask = pPragma->iArg;\n                if (db->autoCommit == 0) {\n                    mask &= ~(16384);\n                }\n                if (sqlite3GetBoolean(zRight, 0)) {\n                    db->flags |= mask;\n                } else {\n                    db->flags &= ~mask;\n                    if (mask == 524288)\n                        db->nDeferredImmCons = 0;\n                    if ((mask & 1) != 0 && sqlite3_stricmp(zRight, \"reset\") == 0) {\n                        sqlite3ResetAllSchemasOfConnection(db);\n                    }\n                }\n                sqlite3VdbeAddOp0(v, 166);\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 37:\n        if (zRight) {\n            Table *pTab;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n            if (pTab) {\n                int i, k;\n                int nHidden = 0;\n                Column *pCol;\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                pParse->nMem = 7;\n                sqlite3ViewGetColumnNames(pParse, pTab);\n                for (i = 0 , pCol = pTab->aCol; i < pTab->nCol; i++ , pCol++) {\n                    int isHidden = 0;\n                    const Expr *pColExpr;\n                    if (pCol->colFlags & 98) {\n                        if (pPragma->iArg == 0) {\n                            nHidden++;\n                            continue;\n                        }\n                        if (pCol->colFlags & 32) {\n                            isHidden = 2;\n                        } else if (pCol->colFlags & 64) {\n                            isHidden = 3;\n                        } else {\n                            ((void)0);\n                            isHidden = 1;\n                        }\n                    }\n                    if ((pCol->colFlags & 1) == 0) {\n                        k = 0;\n                    } else if (pPk == 0) {\n                        k = 1;\n                    } else {\n                        for (k = 1; k <= pTab->nCol && pPk->aiColumn[k - 1] != i; k++) {\n                        }\n                    }\n                    pColExpr = sqlite3ColumnExpr(pTab, pCol);\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\", i - nHidden, pCol->zCnName, sqlite3ColumnType(pCol, \"\"), pCol->notNull ? 1 : 0, (isHidden >= 2 || pColExpr == 0) ? 0 : pColExpr->u.zToken, k, isHidden);\n                }\n            }\n        }\n        break;\n      case 38:\n        {\n            int ii;\n            pParse->nMem = 6;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            for (ii = 0; ii < db->nDb; ii++) {\n                HashElem *k;\n                Hash *pHash;\n                int initNCol;\n                if (zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName) != 0)\n                    continue;\n                pHash = &db->aDb[ii].pSchema->tblHash;\n                initNCol = ((pHash)->count);\n                while (initNCol--)\n                    {\n                        for (k = ((pHash)->first); 1; k = ((k)->next)) {\n                            Table *pTab;\n                            if (k == 0) {\n                                initNCol = 0;\n                                break;\n                            }\n                            pTab = ((k)->data);\n                            if (pTab->nCol == 0) {\n                                char *zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\"\", pTab->zName);\n                                if (zSql) {\n                                    sqlite3_stmt *pDummy = 0;\n                                    (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);\n                                    (void)sqlite3_finalize(pDummy);\n                                    sqlite3DbFree(db, zSql);\n                                }\n                                if (db->mallocFailed) {\n                                    sqlite3ErrorMsg(db->pParse, \"out of memory\");\n                                    db->pParse->rc = 7;\n                                }\n                                pHash = &db->aDb[ii].pSchema->tblHash;\n                                break;\n                            }\n                        }\n                    }\n                for (k = ((pHash)->first); k; k = ((k)->next)) {\n                    Table *pTab = ((k)->data);\n                    const char *zType;\n                    if (zRight && sqlite3_stricmp(zRight, pTab->zName) != 0)\n                        continue;\n                    if (((pTab)->eTabType == 2)) {\n                        zType = \"view\";\n                    } else if (((pTab)->eTabType == 1)) {\n                        zType = \"virtual\";\n                    } else if (pTab->tabFlags & 4096) {\n                        zType = \"shadow\";\n                    } else {\n                        zType = \"table\";\n                    }\n                    sqlite3VdbeMultiLoad(v, 1, \"sssiii\", db->aDb[ii].zDbSName, sqlite3PreferredTableName(pTab->zName), zType, pTab->nCol, (pTab->tabFlags & 128) != 0, (pTab->tabFlags & 65536) != 0);\n                }\n            }\n        }\n        break;\n      case 20:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            pIdx = sqlite3FindIndex(db, zRight, zDb);\n            if (pIdx == 0) {\n                pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n                if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                    pIdx = sqlite3PrimaryKeyIndex(pTab);\n                }\n            }\n            if (pIdx) {\n                int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n                int i;\n                int mx;\n                if (pPragma->iArg) {\n                    mx = pIdx->nColumn;\n                    pParse->nMem = 6;\n                } else {\n                    mx = pIdx->nKeyCol;\n                    pParse->nMem = 3;\n                }\n                pTab = pIdx->pTable;\n                sqlite3CodeVerifySchema(pParse, iIdxDb);\n                ((void)0);\n                for (i = 0; i < mx; i++) {\n                    i16 cnum = pIdx->aiColumn[i];\n                    sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum, cnum < 0 ? 0 : pTab->aCol[cnum].zCnName);\n                    if (pPragma->iArg) {\n                        sqlite3VdbeMultiLoad(v, 4, \"isiX\", pIdx->aSortOrder[i], pIdx->azColl[i], i < pIdx->nKeyCol);\n                    }\n                    sqlite3VdbeAddOp2(v, 84, 1, pParse->nMem);\n                }\n            }\n        }\n        break;\n      case 21:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            int i;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab) {\n                int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                pParse->nMem = 5;\n                sqlite3CodeVerifySchema(pParse, iTabDb);\n                for (pIdx = pTab->pIndex , i = 0; pIdx; pIdx = pIdx->pNext , i++) {\n                    const char *azOrigin[] = {\"c\", \"u\", \"pk\"};\n                    sqlite3VdbeMultiLoad(v, 1, \"isisi\", i, pIdx->zName, ((pIdx)->onError != 0), azOrigin[pIdx->idxType], pIdx->pPartIdxWhere != 0);\n                }\n            }\n        }\n        break;\n      case 12:\n        {\n            int i;\n            pParse->nMem = 3;\n            for (i = 0; i < db->nDb; i++) {\n                if (db->aDb[i].pBt == 0)\n                    continue;\n                ((void)0);\n                sqlite3VdbeMultiLoad(v, 1, \"iss\", i, db->aDb[i].zDbSName, sqlite3BtreeGetFilename(db->aDb[i].pBt));\n            }\n        }\n        break;\n      case 9:\n        {\n            int i = 0;\n            HashElem *p;\n            pParse->nMem = 2;\n            for (p = ((&db->aCollSeq)->first); p; p = ((p)->next)) {\n                CollSeq *pColl = (CollSeq *)((p)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n            }\n        }\n        break;\n      case 17:\n        {\n            int i;\n            HashElem *j;\n            FuncDef *p;\n            int showInternFunc = (db->mDbFlags & 32) != 0;\n            pParse->nMem = 6;\n            for (i = 0; i < 23; i++) {\n                for (p = sqlite3BuiltinFunctions.a[i]; p; p = p->u.pHash) {\n                    ((void)0);\n                    pragmaFunclistLine(v, p, 1, showInternFunc);\n                }\n            }\n            for (j = ((&db->aFunc)->first); j; j = ((j)->next)) {\n                p = (FuncDef *)((j)->data);\n                ((void)0);\n                pragmaFunclistLine(v, p, 0, showInternFunc);\n            }\n        }\n        break;\n      case 29:\n        {\n            HashElem *j;\n            pParse->nMem = 1;\n            for (j = ((&db->aModule)->first); j; j = ((j)->next)) {\n                Module *pMod = (Module *)((j)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n            }\n        }\n        break;\n      case 32:\n        {\n            int i;\n            for (i = 0; i < ((int)(sizeof (aPragmaName) / sizeof (aPragmaName[0]))); i++) {\n                sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n            }\n        }\n        break;\n      case 16:\n        if (zRight) {\n            FKey *pFK;\n            Table *pTab;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab && ((pTab)->eTabType == 0)) {\n                pFK = pTab->u.tab.pFKey;\n                if (pFK) {\n                    int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    int i = 0;\n                    pParse->nMem = 8;\n                    sqlite3CodeVerifySchema(pParse, iTabDb);\n                    while (pFK)\n                        {\n                            int j;\n                            for (j = 0; j < pFK->nCol; j++) {\n                                sqlite3VdbeMultiLoad(v, 1, \"iissssss\", i, j, pFK->zTo, pTab->aCol[pFK->aCol[j].iFrom].zCnName, pFK->aCol[j].zCol, actionName(pFK->aAction[1]), actionName(pFK->aAction[0]), \"NONE\");\n                            }\n                            ++i;\n                            pFK = pFK->pNextFrom;\n                        }\n                }\n            }\n        }\n        break;\n      case 15:\n        {\n            FKey *pFK;\n            Table *pTab;\n            Table *pParent;\n            Index *pIdx;\n            int i;\n            int j;\n            HashElem *k;\n            int x;\n            int regResult;\n            int regRow;\n            int addrTop;\n            int addrOk;\n            int *aiCols;\n            regResult = pParse->nMem + 1;\n            pParse->nMem += 4;\n            regRow = ++pParse->nMem;\n            k = ((&db->aDb[iDb].pSchema->tblHash)->first);\n            while (k)\n                {\n                    if (zRight) {\n                        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n                        k = 0;\n                    } else {\n                        pTab = (Table *)((k)->data);\n                        k = ((k)->next);\n                    }\n                    if (pTab == 0 || !((pTab)->eTabType == 0) || pTab->u.tab.pFKey == 0)\n                        continue;\n                    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    zDb = db->aDb[iDb].zDbSName;\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                    if (pTab->nCol + regRow > pParse->nMem)\n                        pParse->nMem = pTab->nCol + regRow;\n                    sqlite3OpenTable(pParse, 0, iDb, pTab, 112);\n                    sqlite3VdbeLoadString(v, regResult, pTab->zName);\n                    ((void)0);\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        if (pParent == 0)\n                            continue;\n                        pIdx = 0;\n                        sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);\n                        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n                        if (x == 0) {\n                            if (pIdx == 0) {\n                                sqlite3OpenTable(pParse, i, iDb, pParent, 112);\n                            } else {\n                                sqlite3VdbeAddOp3(v, 112, i, pIdx->tnum, iDb);\n                                sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n                            }\n                        } else {\n                            k = 0;\n                            break;\n                        }\n                    }\n                    ((void)0);\n                    if (pFK)\n                        break;\n                    if (pParse->nTab < i)\n                        pParse->nTab = i;\n                    addrTop = sqlite3VdbeAddOp1(v, 36, 0);\n                    ;\n                    ((void)0);\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        pIdx = 0;\n                        aiCols = 0;\n                        if (pParent) {\n                            x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n                            ((void)0);\n                        }\n                        addrOk = sqlite3VdbeMakeLabel(pParse);\n                        if (regRow + pFK->nCol > pParse->nMem)\n                            pParse->nMem = regRow + pFK->nCol;\n                        for (j = 0; j < pFK->nCol; j++) {\n                            int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow + j);\n                            sqlite3VdbeAddOp2(v, 50, regRow + j, addrOk);\n                            ;\n                        }\n                        if (pIdx) {\n                            sqlite3VdbeAddOp4(v, 96, regRow, pFK->nCol, 0, sqlite3IndexAffinityStr(db, pIdx), pFK->nCol);\n                            sqlite3VdbeAddOp4Int(v, 29, i, addrOk, regRow, pFK->nCol);\n                            ;\n                        } else if (pParent) {\n                            int jmp = sqlite3VdbeCurrentAddr(v) + 2;\n                            sqlite3VdbeAddOp3(v, 30, i, jmp, regRow);\n                            ;\n                            sqlite3VdbeGoto(v, addrOk);\n                            ((void)0);\n                        }\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3VdbeAddOp2(v, 135, 0, regResult + 1);\n                        } else {\n                            sqlite3VdbeAddOp2(v, 75, 0, regResult + 1);\n                        }\n                        sqlite3VdbeMultiLoad(v, regResult + 2, \"siX\", pFK->zTo, i - 1);\n                        sqlite3VdbeAddOp2(v, 84, regResult, 4);\n                        sqlite3VdbeResolveLabel(v, addrOk);\n                        sqlite3DbFree(db, aiCols);\n                    }\n                    sqlite3VdbeAddOp2(v, 39, 0, addrTop + 1);\n                    ;\n                    sqlite3VdbeJumpHere(v, addrTop);\n                }\n        }\n        break;\n      case 8:\n        {\n            if (zRight) {\n                sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n            }\n        }\n        break;\n      case 22:\n        {\n            int i, j, addr, mxErr;\n            Table *pObjTab = 0;\n            int isQuick = ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'q');\n            ((void)0);\n            ((void)0);\n            if (pId2->z == 0)\n                iDb = -1;\n            pParse->nMem = 6;\n            mxErr = 100;\n            if (zRight) {\n                if (sqlite3GetInt32(zRight, &mxErr)) {\n                    if (mxErr <= 0) {\n                        mxErr = 100;\n                    }\n                } else {\n                    pObjTab = sqlite3LocateTable(pParse, 0, zRight, iDb >= 0 ? db->aDb[iDb].zDbSName : 0);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 71, mxErr - 1, 1);\n            for (i = 0; i < db->nDb; i++) {\n                HashElem *x;\n                Hash *pTbls;\n                int *aRoot;\n                int cnt = 0;\n                int mxIdx = 0;\n                if (0 && i == 1)\n                    continue;\n                if (iDb >= 0 && i != iDb)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, i);\n                ((void)0);\n                pTbls = &db->aDb[i].pSchema->tblHash;\n                for (cnt = 0 , x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    int nIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        cnt++;\n                    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n                        cnt++;\n                    }\n                    if (nIdx > mxIdx)\n                        mxIdx = nIdx;\n                }\n                if (cnt == 0)\n                    continue;\n                if (pObjTab)\n                    cnt++;\n                aRoot = sqlite3DbMallocRawNN(db, sizeof(int) * (cnt + 1));\n                if (aRoot == 0)\n                    break;\n                cnt = 0;\n                if (pObjTab)\n                    aRoot[++cnt] = 0;\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        aRoot[++cnt] = pTab->tnum;\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        aRoot[++cnt] = pIdx->tnum;\n                    }\n                }\n                aRoot[0] = cnt;\n                pParse->nMem = ((pParse->nMem) > (8 + mxIdx) ? (pParse->nMem) : (8 + mxIdx));\n                sqlite3ClearTempRegCache(pParse);\n                sqlite3VdbeAddOp4(v, 155, 2, cnt, 1, (char *)aRoot, (-14));\n                sqlite3VdbeChangeP5(v, (u8)i);\n                addr = sqlite3VdbeAddOp1(v, 50, 2);\n                ;\n                sqlite3VdbeAddOp4(v, 117, 0, 3, 0, sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName), (-6));\n                sqlite3VdbeAddOp3(v, 111, 2, 3, 3);\n                integrityCheckResultRow(v);\n                sqlite3VdbeJumpHere(v, addr);\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx, *pPk;\n                    Index *pPrior = 0;\n                    int loopTop;\n                    int iDataCur, iIdxCur;\n                    int r1 = -1;\n                    int bStrict;\n                    int r2;\n                    int mxCol;\n                    if (!((pTab)->eTabType == 0))\n                        continue;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if (isQuick || (((pTab)->tabFlags & 128) == 0)) {\n                        pPk = 0;\n                        r2 = 0;\n                    } else {\n                        pPk = sqlite3PrimaryKeyIndex(pTab);\n                        r2 = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n                        sqlite3VdbeAddOp3(v, 75, 1, r2, r2 + pPk->nKeyCol - 1);\n                    }\n                    sqlite3OpenTableAndIndices(pParse, pTab, 112, 0, 1, 0, &iDataCur, &iIdxCur);\n                    sqlite3VdbeAddOp2(v, 71, 0, 7);\n                    for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                        sqlite3VdbeAddOp2(v, 71, 0, 8 + j);\n                    }\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeAddOp2(v, 36, iDataCur, 0);\n                    ;\n                    loopTop = sqlite3VdbeAddOp2(v, 86, 7, 1);\n                    mxCol = pTab->nCol - 1;\n                    while (mxCol >= 0 && ((pTab->aCol[mxCol].colFlags & 32) != 0 || pTab->iPKey == mxCol))\n                        mxCol--;\n                    if (mxCol >= 0) {\n                        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, mxCol, 3);\n                        sqlite3VdbeTypeofColumn(v, 3);\n                    }\n                    if (!isQuick) {\n                        if (pPk) {\n                            int a1;\n                            char *zErr;\n                            a1 = sqlite3VdbeAddOp4Int(v, 41, iDataCur, 0, r2, pPk->nKeyCol);\n                            ;\n                            sqlite3VdbeAddOp1(v, 50, r2);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"row not in PRIMARY KEY order for %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, a1);\n                            sqlite3VdbeJumpHere(v, a1 + 1);\n                            for (j = 0; j < pPk->nKeyCol; j++) {\n                                sqlite3ExprCodeLoadIndexColumn(pParse, pPk, iDataCur, j, r2 + j);\n                            }\n                        }\n                    }\n                    bStrict = (pTab->tabFlags & 65536) != 0;\n                    for (j = 0; j < pTab->nCol; j++) {\n                        char *zErr;\n                        Column *pCol = pTab->aCol + j;\n                        int labelError;\n                        int labelOk;\n                        int p1, p3, p4;\n                        int doTypeCheck;\n                        if (j == pTab->iPKey)\n                            continue;\n                        if (bStrict) {\n                            doTypeCheck = pCol->eCType > 1;\n                        } else {\n                            doTypeCheck = pCol->affinity > 65;\n                        }\n                        if (pCol->notNull == 0 && !doTypeCheck)\n                            continue;\n                        p4 = 5;\n                        if (pCol->colFlags & 32) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            p1 = -1;\n                            p3 = 3;\n                        } else {\n                            if (pCol->iDflt) {\n                                sqlite3_value *pDfltValue = 0;\n                                sqlite3ValueFromExpr(db, sqlite3ColumnExpr(pTab, pCol), ((db)->enc), pCol->affinity, &pDfltValue);\n                                if (pDfltValue) {\n                                    p4 = sqlite3_value_type(pDfltValue);\n                                    sqlite3ValueFree(pDfltValue);\n                                }\n                            }\n                            p1 = iDataCur;\n                            if (!(((pTab)->tabFlags & 128) == 0)) {\n                                ;\n                                p3 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), j);\n                            } else {\n                                p3 = sqlite3TableColumnToStorage(pTab, j);\n                                ;\n                            }\n                        }\n                        labelError = sqlite3VdbeMakeLabel(pParse);\n                        labelOk = sqlite3VdbeMakeLabel(pParse);\n                        if (pCol->notNull) {\n                            int jmp2 = sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 15);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName, pCol->zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            if (doTypeCheck) {\n                                sqlite3VdbeGoto(v, labelError);\n                                sqlite3VdbeJumpHere(v, jmp2);\n                            } else {\n                            }\n                        }\n                        if (bStrict && doTypeCheck) {\n                            static unsigned char aStdTypeMask[] = {31, 24, 17, 17, 19, 20};\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            ((void)0);\n                            sqlite3VdbeChangeP5(v, aStdTypeMask[pCol->eCType - 1]);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"non-%s value in %s.%s\", sqlite3StdType[pCol->eCType - 1], pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity == 66) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NUMERIC value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity >= 67) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 27);\n                            ;\n                            if (p1 >= 0) {\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            }\n                            sqlite3VdbeAddOp4(v, 96, 3, 1, 0, \"C\", (-1));\n                            sqlite3VdbeAddOp4Int(v, 18, -1, labelOk, 3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"TEXT value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        }\n                        sqlite3VdbeResolveLabel(v, labelError);\n                        integrityCheckResultRow(v);\n                        sqlite3VdbeResolveLabel(v, labelOk);\n                    }\n                    if (pTab->pCheck && (db->flags & 512) == 0) {\n                        ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n                        if (db->mallocFailed == 0) {\n                            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n                            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n                            char *zErr;\n                            int k;\n                            pParse->iSelfTab = iDataCur + 1;\n                            for (k = pCheck->nExpr - 1; k > 0; k--) {\n                                sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n                            }\n                            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 16);\n                            sqlite3VdbeResolveLabel(v, addrCkFault);\n                            pParse->iSelfTab = 0;\n                            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeResolveLabel(v, addrCkOk);\n                        }\n                        sqlite3ExprListDelete(db, pCheck);\n                    }\n                    if (!isQuick) {\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            int jmp2, jmp3, jmp4, jmp5, label6;\n                            int kk;\n                            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n                            if (pPk == pIdx)\n                                continue;\n                            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3, pPrior, r1);\n                            pPrior = pIdx;\n                            sqlite3VdbeAddOp2(v, 86, 8 + j, 1);\n                            jmp2 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur + j, ckUniq, r1, pIdx->nColumn);\n                            ;\n                            sqlite3VdbeLoadString(v, 3, \"row \");\n                            sqlite3VdbeAddOp3(v, 111, 7, 3, 3);\n                            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp4 = integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, jmp2);\n                            label6 = 0;\n                            for (kk = 0; kk < pIdx->nKeyCol; kk++) {\n                                if (pIdx->azColl[kk] == sqlite3StrBINARY)\n                                    continue;\n                                if (label6 == 0)\n                                    label6 = sqlite3VdbeMakeLabel(pParse);\n                                sqlite3VdbeAddOp3(v, 94, iIdxCur + j, kk, 3);\n                                sqlite3VdbeAddOp3(v, 52, 3, label6, r1 + kk);\n                                ;\n                            }\n                            if (label6) {\n                                int jmp6 = sqlite3VdbeAddOp0(v, 9);\n                                sqlite3VdbeResolveLabel(v, label6);\n                                sqlite3VdbeLoadString(v, 3, \"row \");\n                                sqlite3VdbeAddOp3(v, 111, 7, 3, 3);\n                                sqlite3VdbeLoadString(v, 4, \" values differ from index \");\n                                sqlite3VdbeGoto(v, jmp5 - 1);\n                                sqlite3VdbeJumpHere(v, jmp6);\n                            }\n                            if (((pIdx)->onError != 0)) {\n                                int uniqOk = sqlite3VdbeMakeLabel(pParse);\n                                int jmp6;\n                                for (kk = 0; kk < pIdx->nKeyCol; kk++) {\n                                    int iCol = pIdx->aiColumn[kk];\n                                    ((void)0);\n                                    if (iCol >= 0 && pTab->aCol[iCol].notNull)\n                                        continue;\n                                    sqlite3VdbeAddOp2(v, 50, r1 + kk, uniqOk);\n                                    ;\n                                }\n                                jmp6 = sqlite3VdbeAddOp1(v, 39, iIdxCur + j);\n                                ;\n                                sqlite3VdbeGoto(v, uniqOk);\n                                sqlite3VdbeJumpHere(v, jmp6);\n                                sqlite3VdbeAddOp4Int(v, 41, iIdxCur + j, uniqOk, r1, pIdx->nKeyCol);\n                                ;\n                                sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n                                sqlite3VdbeGoto(v, jmp5);\n                                sqlite3VdbeResolveLabel(v, uniqOk);\n                            }\n                            sqlite3VdbeJumpHere(v, jmp4);\n                            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 39, iDataCur, loopTop);\n                    ;\n                    sqlite3VdbeJumpHere(v, loopTop - 1);\n                    if (!isQuick) {\n                        sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            if (pPk == pIdx)\n                                continue;\n                            sqlite3VdbeAddOp2(v, 98, iIdxCur + j, 3);\n                            addr = sqlite3VdbeAddOp3(v, 53, 8 + j, 0, 3);\n                            ;\n                            sqlite3VdbeChangeP5(v, 144);\n                            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 2, 3);\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, addr);\n                        }\n                        if (pPk) {\n                            sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n                        }\n                    }\n                }\n            }\n            {\n                static const int iLn = 0;\n                static const VdbeOpList endCode[] = {{86, 1, 0, 0}, {60, 1, 4, 0}, {117, 0, 3, 0}, {84, 3, 1, 0}, {70, 0, 0, 0}, {117, 0, 3, 0}, {9, 0, 3, 0}};\n                VdbeOp *aOp;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (endCode) / sizeof (endCode[0]))), endCode, iLn);\n                if (aOp) {\n                    aOp[0].p2 = 1 - mxErr;\n                    aOp[2].p4type = (-1);\n                    aOp[2].p4.z = \"ok\";\n                    aOp[5].p4type = (-1);\n                    aOp[5].p4.z = (char *)sqlite3ErrStr(11);\n                }\n                sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v) - 2);\n            }\n        }\n        break;\n      case 14:\n        {\n            static const struct EncName {\n                char *zName;\n                u8 enc;\n            } encnames[] = {{\"UTF8\", 1}, {\"UTF-8\", 1}, {\"UTF-16le\", 2}, {\"UTF-16be\", 3}, {\"UTF16le\", 2}, {\"UTF16be\", 3}, {\"UTF-16\", 0}, {\"UTF16\", 0}, {0, 0}};\n            const struct EncName *pEnc;\n            if (!zRight) {\n                if (sqlite3ReadSchema(pParse))\n                    goto pragma_out;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                returnSingleText(v, encnames[((pParse->db)->enc)].zName);\n            } else {\n                if ((db->mDbFlags & 64) == 0) {\n                    for (pEnc = &encnames[0]; pEnc->zName; pEnc++) {\n                        if (0 == sqlite3StrICmp(zRight, pEnc->zName)) {\n                            u8 enc = pEnc->enc ? pEnc->enc : 2;\n                            ((db)->aDb[0].pSchema->enc) = enc;\n                            sqlite3SetTextEncoding(db, enc);\n                            break;\n                        }\n                    }\n                    if (!pEnc->zName) {\n                        sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n                    }\n                }\n            }\n        }\n        break;\n      case 2:\n        {\n            int iCookie = pPragma->iArg;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (zRight && (pPragma->mPragFlg & 8) == 0) {\n                static const VdbeOpList setCookie[] = {{2, 0, 1, 0}, {100, 0, 0, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setCookie) / sizeof (setCookie[0]))), setCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p2 = iCookie;\n                aOp[1].p3 = sqlite3Atoi(zRight);\n                aOp[1].p5 = 1;\n                if (iCookie == 1 && (db->flags & 268435456) != 0) {\n                    aOp[1].opcode = 184;\n                }\n            } else {\n                static const VdbeOpList readCookie[] = {{2, 0, 0, 0}, {99, 0, 1, 0}, {84, 1, 1, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (readCookie) / sizeof (readCookie[0]))), readCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p3 = iCookie;\n                sqlite3VdbeReusable(v);\n            }\n        }\n        break;\n      case 10:\n        {\n            int i = 0;\n            const char *zOpt;\n            pParse->nMem = 1;\n            while ((zOpt = sqlite3_compileoption_get(i++)) != 0)\n                {\n                    sqlite3VdbeLoadString(v, 1, zOpt);\n                    sqlite3VdbeAddOp2(v, 84, 1, 1);\n                }\n            sqlite3VdbeReusable(v);\n        }\n        break;\n      case 43:\n        {\n            int iBt = (pId2->z ? iDb : (10 + 2));\n            int eMode = 0;\n            if (zRight) {\n                if (sqlite3StrICmp(zRight, \"full\") == 0) {\n                    eMode = 1;\n                } else if (sqlite3StrICmp(zRight, \"restart\") == 0) {\n                    eMode = 2;\n                } else if (sqlite3StrICmp(zRight, \"truncate\") == 0) {\n                    eMode = 3;\n                }\n            }\n            pParse->nMem = 3;\n            sqlite3VdbeAddOp3(v, 3, iBt, eMode, 1);\n            sqlite3VdbeAddOp2(v, 84, 1, 3);\n        }\n        break;\n      case 42:\n        {\n            if (zRight) {\n                sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->xWalCallback == sqlite3WalDefaultHook ? ((int)(intptr_t)(db->pWalArg)) : 0);\n        }\n        break;\n      case 34:\n        {\n            sqlite3_db_release_memory(db);\n            break;\n        }\n      case 30:\n        {\n            int iDbLast;\n            int iTabCur;\n            HashElem *k;\n            Schema *pSchema;\n            Table *pTab;\n            Index *pIdx;\n            LogEst szThreshold;\n            char *zSubSql;\n            u32 opMask;\n            if (zRight) {\n                opMask = (u32)sqlite3Atoi(zRight);\n                if ((opMask & 2) == 0)\n                    break;\n            } else {\n                opMask = 65534;\n            }\n            iTabCur = pParse->nTab++;\n            for (iDbLast = zDb ? iDb : db->nDb - 1; iDb <= iDbLast; iDb++) {\n                if (iDb == 1)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                pSchema = db->aDb[iDb].pSchema;\n                for (k = ((&pSchema->tblHash)->first); k; k = ((k)->next)) {\n                    pTab = (Table *)((k)->data);\n                    if ((pTab->tabFlags & 256) == 0)\n                        continue;\n                    szThreshold = pTab->nRowLogEst + 46;\n                    ((void)0);\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (!pIdx->hasStat1) {\n                            szThreshold = 0;\n                            break;\n                        }\n                    }\n                    if (szThreshold) {\n                        sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 112);\n                        sqlite3VdbeAddOp3(v, 33, iTabCur, sqlite3VdbeCurrentAddr(v) + 2 + (opMask & 1), szThreshold);\n                        ;\n                    }\n                    zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\", db->aDb[iDb].zDbSName, pTab->zName);\n                    if (opMask & 1) {\n                        int r1 = sqlite3GetTempReg(pParse);\n                        sqlite3VdbeAddOp4(v, 117, 0, r1, 0, zSubSql, (-6));\n                        sqlite3VdbeAddOp2(v, 84, r1, 1);\n                    } else {\n                        sqlite3VdbeAddOp4(v, 148, 0, 0, 0, zSubSql, (-6));\n                    }\n                }\n            }\n            sqlite3VdbeAddOp0(v, 166);\n            break;\n        }\n      default:\n        {\n            ((void)0);\n            if (zRight) {\n                sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->busyTimeout);\n            break;\n        }\n      case 35:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_soft_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n            break;\n        }\n      case 18:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n                if (N > 0 && (iPrior == 0 || iPrior > N))\n                    sqlite3_hard_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n            break;\n        }\n      case 41:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                sqlite3_limit(db, 11, (int)(N & 2147483647));\n            }\n            returnSingleInt(v, sqlite3_limit(db, 11, -1));\n            break;\n        }\n      case 1:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                db->nAnalysisLimit = (int)(N & 2147483647);\n            }\n            returnSingleInt(v, db->nAnalysisLimit);\n            break;\n        }\n    }\n    if ((pPragma->mPragFlg & 4) && zRight) {\n        ;\n    }\n  pragma_out:\n    sqlite3DbFree(db, zLeft);\n    sqlite3DbFree(db, zRight);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeCopyFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc;\n    sqlite3_file *pFd;\n    sqlite3_backup b;\n    sqlite3BtreeEnter(pTo);\n    sqlite3BtreeEnter(pFrom);\n    ((void)0);\n    pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));\n    if (pFd->pMethods) {\n        i64 nByte = sqlite3BtreeGetPageSize(pFrom) * (i64)sqlite3BtreeLastPage(pFrom);\n        rc = sqlite3OsFileControl(pFd, 11, &nByte);\n        if (rc == 12)\n            rc = 0;\n        if (rc)\n            goto copy_finished;\n    }\n    __builtin___memset_chk(&b, 0, sizeof (b), __builtin_object_size(&b, 0));\n    b.pSrcDb = pFrom->db;\n    b.pSrc = pFrom;\n    b.pDest = pTo;\n    b.iNext = 1;\n    sqlite3_backup_step(&b, 2147483647);\n    ((void)0);\n    rc = sqlite3_backup_finish(&b);\n    if (rc == 0) {\n        pTo->pBt->btsFlags &= ~2;\n    } else {\n        sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));\n    }\n    ((void)0);\n  copy_finished:\n    sqlite3BtreeLeave(pFrom);\n    sqlite3BtreeLeave(pTo);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#176855:1#openDatabase",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db;\n    int rc;\n    int isThreadsafe;\n    char *zOpen = 0;\n    char *zErrMsg = 0;\n    int i;\n    *ppDb = 0;\n    rc = sqlite3_initialize();\n    if (rc)\n        return rc;\n    if (sqlite3Config.bCoreMutex == 0) {\n        isThreadsafe = 0;\n    } else if (flags & 32768) {\n        isThreadsafe = 0;\n    } else if (flags & 65536) {\n        isThreadsafe = 1;\n    } else {\n        isThreadsafe = sqlite3Config.bFullMutex;\n    }\n    if (flags & 262144) {\n        flags &= ~131072;\n    } else if (sqlite3Config.sharedCacheEnabled) {\n        flags |= 131072;\n    }\n    flags &= ~(8 | 16 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 | 524288);\n    db = sqlite3MallocZero(sizeof(sqlite3));\n    if (db == 0)\n        goto opendb_out;\n    if (isThreadsafe) {\n        db->mutex = sqlite3MutexAlloc(1);\n        if (db->mutex == 0) {\n            sqlite3_free(db);\n            db = 0;\n            goto opendb_out;\n        }\n        if (isThreadsafe == 0) {\n            ;\n        }\n    }\n    sqlite3_mutex_enter(db->mutex);\n    db->errMask = (flags & 33554432) != 0 ? 4294967295U : 255;\n    db->nDb = 2;\n    db->eOpenState = 109;\n    db->aDb = db->aDbStatic;\n    db->lookaside.bDisable = 1;\n    db->lookaside.sz = 0;\n    ((void)0);\n    __builtin___memcpy_chk(db->aLimit, aHardLimit, sizeof (db->aLimit), __builtin_object_size(db->aLimit, 0));\n    db->aLimit[11] = 0;\n    db->autoCommit = 1;\n    db->nextAutovac = -1;\n    db->szMmap = sqlite3Config.szMmap;\n    db->nextPagesize = 0;\n    db->init.azInit = sqlite3StdType;\n    db->flags |= 64 | 262144 | 2147483648U | 32 | 128 | 1073741824 | 536870912 | 32768;\n    sqlite3HashInit(&db->aCollSeq);\n    sqlite3HashInit(&db->aModule);\n    createCollation(db, sqlite3StrBINARY, 1, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 3, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 2, 0, binCollFunc, 0);\n    createCollation(db, \"NOCASE\", 1, 0, nocaseCollatingFunc, 0);\n    createCollation(db, \"RTRIM\", 1, 0, rtrimCollFunc, 0);\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    db->openFlags = flags;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ;\n    ;\n    ;\n    if (((1 << (flags & 7)) & 70) == 0) {\n        rc = sqlite3MisuseError(177081);\n    } else {\n        rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);\n    }\n    if (rc != 0) {\n        if (rc == 7)\n            sqlite3OomFault(db);\n        sqlite3ErrorWithMsg(db, rc, zErrMsg ? \"%s\" : 0, zErrMsg);\n        sqlite3_free(zErrMsg);\n        goto opendb_out;\n    }\n    ((void)0);\n    rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0, flags | 256);\n    if (rc != 0) {\n        if (rc == (10 | (12 << 8))) {\n            rc = 7;\n        }\n        sqlite3Error(db, rc);\n        goto opendb_out;\n    }\n    sqlite3BtreeEnter(db->aDb[0].pBt);\n    db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);\n    if (!db->mallocFailed) {\n        sqlite3SetTextEncoding(db, ((db)->aDb[0].pSchema->enc));\n    }\n    sqlite3BtreeLeave(db->aDb[0].pBt);\n    db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);\n    db->aDb[0].zDbSName = \"main\";\n    db->aDb[0].safety_level = 2 + 1;\n    db->aDb[1].zDbSName = \"temp\";\n    db->aDb[1].safety_level = 1;\n    db->eOpenState = 118;\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    sqlite3Error(db, 0);\n    sqlite3RegisterPerConnectionBuiltinFunctions(db);\n    rc = sqlite3_errcode(db);\n    for (i = 0; rc == 0 && i < ((int)(sizeof (sqlite3BuiltinExtensions) / sizeof (sqlite3BuiltinExtensions[0]))); i++) {\n        rc = sqlite3BuiltinExtensions[i](db);\n    }\n    if (rc == 0) {\n        sqlite3AutoLoadExtensions(db);\n        rc = sqlite3_errcode(db);\n        if (rc != 0) {\n            goto opendb_out;\n        }\n    }\n    if (rc)\n        sqlite3Error(db, rc);\n    setupLookaside(db, 0, sqlite3Config.szLookaside, sqlite3Config.nLookaside);\n    sqlite3_wal_autocheckpoint(db, 1000);\n  opendb_out:\n    if (db) {\n        ((void)0);\n        sqlite3_mutex_leave(db->mutex);\n    }\n    rc = sqlite3_errcode(db);\n    ((void)0);\n    if ((rc & 255) == 7) {\n        sqlite3_close(db);\n        db = 0;\n    } else if (rc != 0) {\n        db->eOpenState = 186;\n    }\n    *ppDb = db;\n    sqlite3_free_filename(zOpen);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#23590:1#getDigits",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    static const u16 aMx[] = {12, 14, 24, 31, 59, 9999};\n    va_list ap;\n    int cnt = 0;\n    char nextC;\n    __builtin_va_start(ap, zFormat);\n    do {\n        char N = zFormat[0] - '0';\n        char min = zFormat[1] - '0';\n        int val = 0;\n        u16 max;\n        ((void)0);\n        max = aMx[zFormat[2] - 'a'];\n        nextC = zFormat[3];\n        val = 0;\n        while (N--)\n            {\n                if (!(sqlite3CtypeMap[(unsigned char)(*zDate)] & 4)) {\n                    goto end_getDigits;\n                }\n                val = val * 10 + *zDate - '0';\n                zDate++;\n            }\n        if (val < (int)min || val > (int)max || (nextC != 0 && nextC != *zDate)) {\n            goto end_getDigits;\n        }\n        *__builtin_va_arg(ap, int *) = val;\n        zDate++;\n        cnt++;\n        zFormat += 4;\n    } while (nextC);\n  end_getDigits:\n    __builtin_va_end(ap);\n    return cnt;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AtoF",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int incr;\n    const char *zEnd;\n    int sign = 1;\n    i64 s = 0;\n    int d = 0;\n    int esign = 1;\n    int e = 0;\n    int eValid = 1;\n    double result;\n    int nDigit = 0;\n    int eType = 1;\n    ((void)0);\n    *pResult = 0.;\n    if (length == 0)\n        return 0;\n    if (enc == 1) {\n        incr = 1;\n        zEnd = z + length;\n    } else {\n        int i;\n        incr = 2;\n        length &= ~1;\n        ((void)0);\n        ;\n        ;\n        for (i = 3 - enc; i < length && z[i] == 0; i += 2) {\n        }\n        if (i < length)\n            eType = -100;\n        zEnd = &z[i ^ 1];\n        z += (enc & 1);\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n    if (z >= zEnd)\n        return 0;\n    if (*z == '-') {\n        sign = -1;\n        z += incr;\n    } else if (*z == '+') {\n        z += incr;\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n        {\n            s = s * 10 + (*z - '0');\n            z += incr;\n            nDigit++;\n            if (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n                    {\n                        z += incr;\n                        d++;\n                    }\n            }\n        }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == '.') {\n        z += incr;\n        eType++;\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                if (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                    s = s * 10 + (*z - '0');\n                    d--;\n                    nDigit++;\n                }\n                z += incr;\n            }\n    }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == 'e' || *z == 'E') {\n        z += incr;\n        eValid = 0;\n        eType++;\n        if (z >= zEnd)\n            goto do_atof_calc;\n        if (*z == '-') {\n            esign = -1;\n            z += incr;\n        } else if (*z == '+') {\n            z += incr;\n        }\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                e = e < 10000 ? (e * 10 + (*z - '0')) : 10000;\n                z += incr;\n                eValid = 1;\n            }\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n  do_atof_calc:\n    e = (e * esign) + d;\n    if (e < 0) {\n        esign = -1;\n        e *= -1;\n    } else {\n        esign = 1;\n    }\n    if (s == 0) {\n        result = sign < 0 ? -(double)0 : (double)0;\n    } else {\n        while (e > 0)\n            {\n                if (esign > 0) {\n                    if (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10))\n                        break;\n                    s *= 10;\n                } else {\n                    if (s % 10 != 0)\n                        break;\n                    s /= 10;\n                }\n                e--;\n            }\n        s = sign < 0 ? -s : s;\n        if (e == 0) {\n            result = (double)s;\n        } else {\n            if (e > 307) {\n                if (e < 342) {\n                    long double scale = sqlite3Pow10(e - 308);\n                    if (esign < 0) {\n                        result = s / scale;\n                        result /= 1.0E+308;\n                    } else {\n                        result = s * scale;\n                        result *= 1.0E+308;\n                    }\n                } else {\n                    ((void)0);\n                    if (esign < 0) {\n                        result = 0. * s;\n                    } else {\n                        result = __builtin_huge_valf() * s;\n                    }\n                }\n            } else {\n                long double scale = sqlite3Pow10(e);\n                if (esign < 0) {\n                    result = s / scale;\n                } else {\n                    result = s * scale;\n                }\n            }\n        }\n    }\n    *pResult = result;\n    if (z == zEnd && nDigit > 0 && eValid && eType > 0) {\n        return eType;\n    } else if (eType >= 2 && (eType == 3 || eValid) && nDigit > 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#38559:1#unixLock",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int tErrno = 0;\n    ((void)0);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto end_lock;\n    }\n    lock.l_len = 1L;\n    lock.l_whence = 0;\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        lock.l_type = (eFileLock == 1 ? 1 : 3);\n        lock.l_start = sqlite3PendingByte;\n        if (unixFileLock(pFile, &lock)) {\n            tErrno = (*__error());\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        lock.l_start = (sqlite3PendingByte + 2);\n        lock.l_len = 510;\n        if (unixFileLock(pFile, &lock)) {\n            tErrno = (*__error());\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n        }\n        lock.l_start = sqlite3PendingByte;\n        lock.l_len = 1L;\n        lock.l_type = 2;\n        if (unixFileLock(pFile, &lock) && rc == 0) {\n            tErrno = (*__error());\n            rc = (10 | (8 << 8));\n        }\n        if (rc) {\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        ((void)0);\n        lock.l_type = 3;\n        ((void)0);\n        if (eFileLock == 2) {\n            lock.l_start = (sqlite3PendingByte + 1);\n            lock.l_len = 1L;\n        } else {\n            lock.l_start = (sqlite3PendingByte + 2);\n            lock.l_len = 510;\n        }\n        if (unixFileLock(pFile, &lock)) {\n            tErrno = (*__error());\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3WhereCodeOneLoopStart",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int j, k;\n    int iCur;\n    int addrNxt;\n    int bRev;\n    WhereLoop *pLoop;\n    WhereClause *pWC;\n    WhereTerm *pTerm;\n    sqlite3 *db;\n    SrcItem *pTabItem;\n    int addrBrk;\n    int addrHalt;\n    int addrCont;\n    int iRowidReg = 0;\n    int iReleaseReg = 0;\n    Index *pIdx = 0;\n    int iLoop;\n    pWC = &pWInfo->sWC;\n    db = pParse->db;\n    pLoop = pLevel->pWLoop;\n    pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];\n    iCur = pTabItem->iCursor;\n    pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);\n    bRev = (pWInfo->revMask >> iLevel) & 1;\n    ;\n    addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n    addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);\n    ((void)0);\n    if (pLevel->iFrom > 0 && (pTabItem[0].fg.jointype & 8) != 0) {\n        pLevel->iLeftJoin = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, pLevel->iLeftJoin);\n        ;\n    }\n    for (j = iLevel; j > 0; j--) {\n        if (pWInfo->a[j].iLeftJoin)\n            break;\n        if (pWInfo->a[j].pRJ)\n            break;\n    }\n    addrHalt = pWInfo->a[j].addrBrk;\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        pLevel->p2 = sqlite3VdbeAddOp2(v, 12, regYield, addrBrk);\n        ;\n        ;\n        pLevel->op = 9;\n    } else if ((pLoop->wsFlags & 1024) != 0) {\n        int iReg;\n        int addrNotFound;\n        int nConstraint = pLoop->nLTerm;\n        iReg = sqlite3GetTempRange(pParse, nConstraint + 2);\n        addrNotFound = pLevel->addrBrk;\n        for (j = 0; j < nConstraint; j++) {\n            int iTarget = iReg + j + 2;\n            pTerm = pLoop->aLTerm[j];\n            if ((pTerm == 0))\n                continue;\n            if (pTerm->eOperator & 1) {\n                if (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) {\n                    int iTab = pParse->nTab++;\n                    int iCache = ++pParse->nMem;\n                    sqlite3CodeRhsOfIN(pParse, pTerm->pExpr, iTab);\n                    sqlite3VdbeAddOp3(v, 174, iTab, iTarget, iCache);\n                } else {\n                    codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);\n                    addrNotFound = pLevel->addrNxt;\n                }\n            } else {\n                Expr *pRight = pTerm->pExpr->pRight;\n                codeExprOrVector(pParse, pRight, iTarget, 1);\n                if (pTerm->eMatchOp == 74 && pLoop->u.vtab.bOmitOffset) {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeAddOp2(v, 71, 0, pWInfo->pSelect->iOffset);\n                    ;\n                }\n            }\n        }\n        sqlite3VdbeAddOp2(v, 71, pLoop->u.vtab.idxNum, iReg);\n        sqlite3VdbeAddOp2(v, 71, nConstraint, iReg + 1);\n        sqlite3VdbeAddOp4(v, 6, iCur, addrNotFound, iReg, pLoop->u.vtab.idxStr, pLoop->u.vtab.needFree ? (-6) : (-1));\n        ;\n        pLoop->u.vtab.needFree = 0;\n        if (db->mallocFailed)\n            pLoop->u.vtab.idxStr = 0;\n        pLevel->p1 = iCur;\n        pLevel->op = pWInfo->eOnePass ? 184 : 63;\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        ((void)0);\n        for (j = 0; j < nConstraint; j++) {\n            pTerm = pLoop->aLTerm[j];\n            if (j < 16 && (pLoop->u.vtab.omitMask >> j) & 1) {\n                disableTerm(pLevel, pTerm);\n                continue;\n            }\n            if ((pTerm->eOperator & 1) != 0 && (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) == 0 && !db->mallocFailed) {\n                Expr *pCompare;\n                Expr *pRight;\n                VdbeOp *pOp;\n                int iIn;\n                for (iIn = 0; (iIn < pLevel->u.in.nIn); iIn++) {\n                    pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);\n                    if ((pOp->opcode == 94 && pOp->p3 == iReg + j + 2) || (pOp->opcode == 135 && pOp->p2 == iReg + j + 2)) {\n                        ;\n                        sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);\n                        break;\n                    }\n                }\n                pCompare = sqlite3PExpr(pParse, 53, 0, 0);\n                if (!db->mallocFailed) {\n                    int iFld = pTerm->u.x.iField;\n                    Expr *pLeft = pTerm->pExpr->pLeft;\n                    ((void)0);\n                    if (iFld > 0) {\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        pCompare->pLeft = pLeft->x.pList->a[iFld - 1].pExpr;\n                    } else {\n                        pCompare->pLeft = pLeft;\n                    }\n                    pCompare->pRight = pRight = sqlite3Expr(db, 176, 0);\n                    if (pRight) {\n                        pRight->iTable = iReg + j + 2;\n                        sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 16);\n                    }\n                    pCompare->pLeft = 0;\n                }\n                sqlite3ExprDelete(db, pCompare);\n            }\n        }\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & (4 | 1)) != 0) {\n        ((void)0);\n        pTerm = pLoop->aLTerm[0];\n        ((void)0);\n        ((void)0);\n        ;\n        iReleaseReg = ++pParse->nMem;\n        iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);\n        if (iRowidReg != iReleaseReg)\n            sqlite3ReleaseTempReg(pParse, iReleaseReg);\n        addrNxt = pLevel->addrNxt;\n        if (pLevel->regFilter) {\n            sqlite3VdbeAddOp2(v, 13, iRowidReg, addrNxt);\n            ;\n            sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, iRowidReg, 1);\n            ;\n            filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n        }\n        sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);\n        ;\n        pLevel->op = 184;\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & 2) != 0) {\n        int testOp = 184;\n        int start;\n        int memEndValue = 0;\n        WhereTerm *pStart, *pEnd;\n        j = 0;\n        pStart = pEnd = 0;\n        if (pLoop->wsFlags & 32)\n            pStart = pLoop->aLTerm[j++];\n        if (pLoop->wsFlags & 16)\n            pEnd = pLoop->aLTerm[j++];\n        ((void)0);\n        if (bRev) {\n            pTerm = pStart;\n            pStart = pEnd;\n            pEnd = pTerm;\n        }\n        ;\n        if (pStart) {\n            Expr *pX;\n            int r1, rTemp;\n            int op;\n            const u8 aMoveOp[] = {24, 22, 21, 23};\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ;\n            pX = pStart->pExpr;\n            ((void)0);\n            ;\n            if (sqlite3ExprIsVector(pX->pRight)) {\n                r1 = rTemp = sqlite3GetTempReg(pParse);\n                codeExprOrVector(pParse, pX->pRight, r1, 1);\n                ;\n                ;\n                ;\n                ;\n                op = aMoveOp[((pX->op - 54 - 1) & 3) | 1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);\n                disableTerm(pLevel, pStart);\n                op = aMoveOp[(pX->op - 54)];\n            }\n            sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);\n            ;\n            ;\n            ;\n            ;\n            ;\n            sqlite3ReleaseTempReg(pParse, rTemp);\n        } else {\n            sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iCur, addrHalt);\n            ;\n            ;\n        }\n        if (pEnd) {\n            Expr *pX;\n            pX = pEnd->pExpr;\n            ((void)0);\n            ((void)0);\n            ;\n            ;\n            memEndValue = ++pParse->nMem;\n            codeExprOrVector(pParse, pX->pRight, memEndValue, 1);\n            if (0 == sqlite3ExprIsVector(pX->pRight) && (pX->op == 56 || pX->op == 54)) {\n                testOp = bRev ? 55 : 57;\n            } else {\n                testOp = bRev ? 56 : 54;\n            }\n            if (0 == sqlite3ExprIsVector(pX->pRight)) {\n                disableTerm(pLevel, pEnd);\n            }\n        }\n        start = sqlite3VdbeCurrentAddr(v);\n        pLevel->op = bRev ? 38 : 39;\n        pLevel->p1 = iCur;\n        pLevel->p2 = start;\n        ((void)0);\n        if (testOp != 184) {\n            iRowidReg = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 135, iCur, iRowidReg);\n            sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);\n            ;\n            ;\n            ;\n            ;\n            sqlite3VdbeChangeP5(v, 67 | 16);\n        }\n    } else if (pLoop->wsFlags & 512) {\n        static const u8 aStartOp[] = {0, 0, 36, 32, 24, 21, 23, 22};\n        static const u8 aEndOp[] = {45, 41, 40, 42};\n        u16 nEq = pLoop->u.btree.nEq;\n        u16 nBtm = pLoop->u.btree.nBtm;\n        u16 nTop = pLoop->u.btree.nTop;\n        int regBase;\n        WhereTerm *pRangeStart = 0;\n        WhereTerm *pRangeEnd = 0;\n        int startEq;\n        int endEq;\n        int start_constraints;\n        int nConstraint;\n        int iIdxCur;\n        int nExtraReg = 0;\n        int op;\n        char *zStartAff;\n        char *zEndAff = 0;\n        u8 bSeekPastNull = 0;\n        u8 bStopAtNull = 0;\n        int omitTable;\n        int regBignull = 0;\n        int addrSeekScan = 0;\n        pIdx = pLoop->u.btree.pIndex;\n        iIdxCur = pLevel->iIdxCur;\n        ((void)0);\n        j = nEq;\n        if (pLoop->wsFlags & 32) {\n            pRangeStart = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nBtm) ? (nExtraReg) : (pLoop->u.btree.nBtm));\n            ((void)0);\n        }\n        if (pLoop->wsFlags & 16) {\n            pRangeEnd = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nTop) ? (nExtraReg) : (pLoop->u.btree.nTop));\n            if ((pRangeEnd->wtFlags & 256) != 0) {\n                ((void)0);\n                ((void)0);\n                pLevel->iLikeRepCntr = (u32)++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 71, 1, (int)pLevel->iLikeRepCntr);\n                ;\n                pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);\n                ;\n                ;\n                ((void)0);\n                pLevel->iLikeRepCntr <<= 1;\n                pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq] == 1);\n            }\n            if (pRangeStart == 0) {\n                j = pIdx->aiColumn[nEq];\n                if ((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) || j == (-2)) {\n                    bSeekPastNull = 1;\n                }\n            }\n        }\n        ((void)0);\n        if ((pLoop->wsFlags & (16 | 32)) == 0 && (pLoop->wsFlags & 524288) != 0) {\n            ((void)0);\n            ((void)0);\n            ;\n            nExtraReg = 1;\n            bSeekPastNull = 1;\n            pLevel->regBignull = regBignull = ++pParse->nMem;\n            if (pLevel->iLeftJoin) {\n                sqlite3VdbeAddOp2(v, 71, 0, regBignull);\n            }\n            pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);\n        }\n        if ((nEq < pIdx->nColumn && bRev == (pIdx->aSortOrder[nEq] == 0))) {\n            {\n                WhereTerm *t = pRangeEnd;\n                pRangeEnd = pRangeStart;\n                pRangeStart = t;\n            }\n            ;\n            {\n                u8 t = bSeekPastNull;\n                bSeekPastNull = bStopAtNull;\n                bStopAtNull = t;\n            }\n            ;\n            {\n                u8 t = nBtm;\n                nBtm = nTop;\n                nTop = t;\n            }\n            ;\n        }\n        if (iLevel > 0 && (pLoop->wsFlags & 1048576) != 0) {\n            sqlite3VdbeAddOp1(v, 136, iIdxCur);\n        }\n        ;\n        regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, &zStartAff);\n        ((void)0);\n        if (zStartAff && nTop) {\n            zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);\n        }\n        addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);\n        ;\n        ;\n        ;\n        ;\n        startEq = !pRangeStart || pRangeStart->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        endEq = !pRangeEnd || pRangeEnd->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        start_constraints = pRangeStart || nEq > 0;\n        nConstraint = nEq;\n        if (pRangeStart) {\n            Expr *pRight = pRangeStart->pExpr->pRight;\n            codeExprOrVector(pParse, pRight, regBase + nEq, nBtm);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);\n            if ((pRangeStart->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zStartAff) {\n                updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);\n            }\n            nConstraint += nBtm;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeStart);\n            } else {\n                startEq = 1;\n            }\n            bSeekPastNull = 0;\n        } else if (bSeekPastNull) {\n            startEq = 0;\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        } else if (regBignull) {\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        }\n        codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);\n        if (pLoop->nSkip > 0 && nConstraint == pLoop->nSkip) {\n        } else {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 71, 1, regBignull);\n                ;\n            }\n            if (pLevel->regFilter) {\n                sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, regBase, nEq);\n                ;\n                filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n            }\n            op = aStartOp[(start_constraints << 2) + (startEq << 1) + bRev];\n            ((void)0);\n            if ((pLoop->wsFlags & 1048576) != 0 && op == 23) {\n                ((void)0);\n                addrSeekScan = sqlite3VdbeAddOp1(v, 124, (pIdx->aiRowLogEst[0] + 9) / 10);\n                if (pRangeStart) {\n                    sqlite3VdbeChangeP5(v, 1);\n                    sqlite3VdbeChangeP2(v, addrSeekScan, sqlite3VdbeCurrentAddr(v) + 1);\n                    addrSeekScan = 0;\n                }\n                ;\n            }\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ((void)0);\n            if (regBignull) {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v) + 2);\n                op = aStartOp[(nConstraint > 1) * 4 + 2 + bRev];\n                sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint - startEq);\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ((void)0);\n            }\n        }\n        nConstraint = nEq;\n        ((void)0);\n        if (pRangeEnd) {\n            Expr *pRight = pRangeEnd->pExpr->pRight;\n            if (addrSeekScan) {\n                pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n            }\n            codeExprOrVector(pParse, pRight, regBase + nEq, nTop);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);\n            if ((pRangeEnd->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zEndAff) {\n                updateRangeAffinityStr(pRight, nTop, zEndAff);\n                codeApplyAffinity(pParse, regBase + nEq, nTop, zEndAff);\n            } else {\n                ((void)0);\n            }\n            nConstraint += nTop;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeEnd);\n            } else {\n                endEq = 1;\n            }\n        } else if (bStopAtNull) {\n            if (regBignull == 0) {\n                sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n                endEq = 0;\n            }\n            nConstraint++;\n        }\n        if (zStartAff)\n            sqlite3DbNNFreeNN(db, zStartAff);\n        if (zEndAff)\n            sqlite3DbNNFreeNN(db, zEndAff);\n        if (pLevel->p2 == 0)\n            pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (nConstraint) {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 17, regBignull, sqlite3VdbeCurrentAddr(v) + 3);\n                ;\n                ;\n            }\n            op = aEndOp[bRev * 2 + endEq];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            if (addrSeekScan)\n                sqlite3VdbeJumpHere(v, addrSeekScan);\n        }\n        if (regBignull) {\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 16, regBignull, sqlite3VdbeCurrentAddr(v) + 2);\n            ;\n            ;\n            op = aEndOp[bRev * 2 + bSeekPastNull];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint + bSeekPastNull);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n        }\n        if ((pLoop->wsFlags & 262144) != 0) {\n            sqlite3VdbeAddOp3(v, 125, iIdxCur, nEq, nEq);\n        }\n        omitTable = (pLoop->wsFlags & 64) != 0 && (pWInfo->wctrlFlags & (32 | 4096)) == 0;\n        if (omitTable) {\n        } else if ((((pIdx->pTable)->tabFlags & 128) == 0)) {\n            codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);\n        } else if (iCur != iIdxCur) {\n            Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);\n            iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n            for (j = 0; j < pPk->nKeyCol; j++) {\n                k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);\n                sqlite3VdbeAddOp3(v, 94, iIdxCur, k, iRowidReg + j);\n            }\n            sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont, iRowidReg, pPk->nKeyCol);\n            ;\n        }\n        if (pLevel->iLeftJoin == 0) {\n            if (pIdx->pPartIdxWhere) {\n                whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);\n            }\n        } else {\n            ;\n            ((void)0);\n        }\n        if (pLoop->wsFlags & 4096) {\n            pLevel->op = 184;\n        } else if (bRev) {\n            pLevel->op = 38;\n        } else {\n            pLevel->op = 39;\n        }\n        pLevel->p1 = iIdxCur;\n        pLevel->p3 = (pLoop->wsFlags & 65536) != 0 ? 1 : 0;\n        if ((pLoop->wsFlags & 15) == 0) {\n            pLevel->p5 = 1;\n        } else {\n            ((void)0);\n        }\n        if (omitTable)\n            pIdx = 0;\n    } else if (pLoop->wsFlags & 8192) {\n        WhereClause *pOrWc;\n        SrcList *pOrTab;\n        Index *pCov = 0;\n        int iCovCur = pParse->nTab++;\n        int regReturn = ++pParse->nMem;\n        int regRowset = 0;\n        int regRowid = 0;\n        int iLoopBody = sqlite3VdbeMakeLabel(pParse);\n        int iRetInit;\n        int untestedTerms = 0;\n        int ii;\n        Expr *pAndExpr = 0;\n        Table *pTab = pTabItem->pTab;\n        pTerm = pLoop->aLTerm[0];\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pOrWc = &pTerm->u.pOrInfo->wc;\n        pLevel->op = 67;\n        pLevel->p1 = regReturn;\n        if (pWInfo->nLevel > 1) {\n            int nNotReady;\n            SrcItem *origSrc;\n            nNotReady = pWInfo->nLevel - iLevel - 1;\n            pOrTab = sqlite3DbMallocRawNN(db, sizeof (*pOrTab) + nNotReady * sizeof (pOrTab->a[0]));\n            if (pOrTab == 0)\n                return notReady;\n            pOrTab->nAlloc = (u8)(nNotReady + 1);\n            pOrTab->nSrc = pOrTab->nAlloc;\n            __builtin___memcpy_chk(pOrTab->a, pTabItem, sizeof (*pTabItem), __builtin_object_size(pOrTab->a, 0));\n            origSrc = pWInfo->pTabList->a;\n            for (k = 1; k <= nNotReady; k++) {\n                __builtin___memcpy_chk(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof (pOrTab->a[k]), __builtin_object_size(&pOrTab->a[k], 0));\n            }\n        } else {\n            pOrTab = pWInfo->pTabList;\n        }\n        if ((pWInfo->wctrlFlags & 16) == 0) {\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                regRowset = ++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 75, 0, regRowset);\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                regRowset = pParse->nTab++;\n                sqlite3VdbeAddOp2(v, 118, regRowset, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            regRowid = ++pParse->nMem;\n        }\n        iRetInit = sqlite3VdbeAddOp2(v, 71, 0, regReturn);\n        if (pWC->nTerm > 1) {\n            int iTerm;\n            for (iTerm = 0; iTerm < pWC->nTerm; iTerm++) {\n                Expr *pExpr = pWC->a[iTerm].pExpr;\n                if (&pWC->a[iTerm] == pTerm)\n                    continue;\n                ;\n                ;\n                ;\n                if ((pWC->a[iTerm].wtFlags & (2 | 4 | 32768)) != 0) {\n                    continue;\n                }\n                if ((pWC->a[iTerm].eOperator & 16383) == 0)\n                    continue;\n                if ((((pExpr)->flags & (4194304)) != 0))\n                    continue;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);\n            }\n            if (pAndExpr) {\n                pAndExpr = sqlite3PExpr(pParse, 44 | 65536, 0, pAndExpr);\n            }\n        }\n        sqlite3VdbeExplain(pParse, 1, \"MULTI-INDEX OR\");\n        for (ii = 0; ii < pOrWc->nTerm; ii++) {\n            WhereTerm *pOrTerm = &pOrWc->a[ii];\n            if (pOrTerm->leftCursor == iCur || (pOrTerm->eOperator & 1024) != 0) {\n                WhereInfo *pSubWInfo;\n                Expr *pOrExpr = pOrTerm->pExpr;\n                Expr *pDelete;\n                int jmp1 = 0;\n                ;\n                pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDelete);\n                    continue;\n                }\n                if (pAndExpr) {\n                    pAndExpr->pLeft = pOrExpr;\n                    pOrExpr = pAndExpr;\n                }\n                sqlite3VdbeExplain(pParse, 1, \"INDEX %d\", ii + 1);\n                ;\n                pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0, 0, 32, iCovCur);\n                ((void)0);\n                if (pSubWInfo) {\n                    WhereLoop *pSubLoop;\n                    int addrExplain = sqlite3WhereExplainOneScan(pParse, pOrTab, &pSubWInfo->a[0], 0);\n                    ((void)addrExplain);\n                    if ((pWInfo->wctrlFlags & 16) == 0) {\n                        int iSet = ((ii == pOrWc->nTerm - 1) ? -1 : ii);\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);\n                            jmp1 = sqlite3VdbeAddOp4Int(v, 47, regRowset, 0, regRowid, iSet);\n                            ;\n                        } else {\n                            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                            int nPk = pPk->nKeyCol;\n                            int iPk;\n                            int r;\n                            r = sqlite3GetTempRange(pParse, nPk);\n                            for (iPk = 0; iPk < nPk; iPk++) {\n                                int iCol = pPk->aiColumn[iPk];\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + iPk);\n                            }\n                            if (iSet) {\n                                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);\n                                ;\n                            }\n                            if (iSet >= 0) {\n                                sqlite3VdbeAddOp3(v, 97, r, nPk, regRowid);\n                                sqlite3VdbeAddOp4Int(v, 138, regRowset, regRowid, r, nPk);\n                                if (iSet)\n                                    sqlite3VdbeChangeP5(v, 16);\n                            }\n                            sqlite3ReleaseTempRange(pParse, r, nPk);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 10, regReturn, iLoopBody);\n                    if (jmp1)\n                        sqlite3VdbeJumpHere(v, jmp1);\n                    if (pSubWInfo->untestedTerms)\n                        untestedTerms = 1;\n                    pSubLoop = pSubWInfo->a[0].pWLoop;\n                    ((void)0);\n                    if ((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov) && ((((pTab)->tabFlags & 128) == 0) || !((pSubLoop->u.btree.pIndex)->idxType == 2))) {\n                        ((void)0);\n                        pCov = pSubLoop->u.btree.pIndex;\n                    } else {\n                        pCov = 0;\n                    }\n                    if (sqlite3WhereUsesDeferredSeek(pSubWInfo)) {\n                        pWInfo->bDeferredSeek = 1;\n                    }\n                    sqlite3WhereEnd(pSubWInfo);\n                    sqlite3VdbeExplainPop(pParse);\n                }\n                sqlite3ExprDelete(db, pDelete);\n            }\n        }\n        sqlite3VdbeExplainPop(pParse);\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pLevel->u.pCoveringIdx = pCov;\n        if (pCov)\n            pLevel->iIdxCur = iCovCur;\n        if (pAndExpr) {\n            pAndExpr->pLeft = 0;\n            sqlite3ExprDelete(db, pAndExpr);\n        }\n        sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));\n        sqlite3VdbeGoto(v, pLevel->addrBrk);\n        sqlite3VdbeResolveLabel(v, iLoopBody);\n        ((void)0);\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (pWInfo->nLevel > 1) {\n            sqlite3DbFreeNN(db, pOrTab);\n        }\n        if (!untestedTerms)\n            disableTerm(pLevel, pTerm);\n    } else {\n        static const u8 aStep[] = {39, 38};\n        static const u8 aStart[] = {36, 32};\n        ((void)0);\n        if (pTabItem->fg.isRecursive) {\n            pLevel->op = 184;\n        } else {\n            ;\n            pLevel->op = aStep[bRev];\n            pLevel->p1 = iCur;\n            pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);\n            ;\n            ;\n            pLevel->p5 = 1;\n        }\n    }\n    iLoop = (pIdx ? 1 : 2);\n    do {\n        int iNext = 0;\n        for (pTerm = pWC->a , j = pWC->nTerm; j > 0; j-- , pTerm++) {\n            Expr *pE;\n            int skipLikeAddr = 0;\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                ;\n                pWInfo->untestedTerms = 1;\n                continue;\n            }\n            pE = pTerm->pExpr;\n            ((void)0);\n            if (pTabItem->fg.jointype & (8 | 64 | 16)) {\n                if (!(((pE)->flags & (1 | 2)) != 0)) {\n                    continue;\n                } else if ((pTabItem->fg.jointype & 8) == 8 && !(((pE)->flags & (1)) != 0)) {\n                    continue;\n                } else {\n                    Bitmask m = sqlite3WhereGetMask(&pWInfo->sMaskSet, pE->w.iJoin);\n                    if (m & pLevel->notReady) {\n                        continue;\n                    }\n                }\n            }\n            if (iLoop == 1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx)) {\n                iNext = 2;\n                continue;\n            }\n            if (iLoop < 3 && (pTerm->wtFlags & 4096)) {\n                if (iNext == 0)\n                    iNext = 3;\n                continue;\n            }\n            if ((pTerm->wtFlags & 512) != 0) {\n                u32 x = pLevel->iLikeRepCntr;\n                if (x > 0) {\n                    skipLikeAddr = sqlite3VdbeAddOp1(v, (x & 1) ? 17 : 16, (int)(x >> 1));\n                    ;\n                    ;\n                }\n            }\n            sqlite3ExprIfFalse(pParse, pE, addrCont, 16);\n            if (skipLikeAddr)\n                sqlite3VdbeJumpHere(v, skipLikeAddr);\n            pTerm->wtFlags |= 4;\n        }\n        iLoop = iNext;\n    } while (iLoop > 0);\n    for (pTerm = pWC->a , j = pWC->nBase; j > 0; j-- , pTerm++) {\n        Expr *pE, sEAlt;\n        WhereTerm *pAlt;\n        if (pTerm->wtFlags & (2 | 4))\n            continue;\n        if ((pTerm->eOperator & (2 | 128)) == 0)\n            continue;\n        if ((pTerm->eOperator & 2048) == 0)\n            continue;\n        if (pTerm->leftCursor != iCur)\n            continue;\n        if (pTabItem->fg.jointype & (8 | 64 | 16))\n            continue;\n        pE = pTerm->pExpr;\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady, 2 | 1 | 128, 0);\n        if (pAlt == 0)\n            continue;\n        if (pAlt->wtFlags & (4))\n            continue;\n        if ((pAlt->eOperator & 1) && (((pAlt->pExpr)->flags & 4096) != 0) && (pAlt->pExpr->x.pSelect->pEList->nExpr > 1)) {\n            continue;\n        }\n        ;\n        ;\n        ;\n        ;\n        sEAlt = *pAlt->pExpr;\n        sEAlt.pLeft = pE->pLeft;\n        sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 16);\n        pAlt->wtFlags |= 4;\n    }\n    if (pLevel->pRJ) {\n        Table *pTab;\n        int nPk;\n        int r;\n        int jmp1 = 0;\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        pTab = pWInfo->pTabList->a[pLevel->iFrom].pTab;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            r = sqlite3GetTempRange(pParse, 2);\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, pLevel->iTabCur, -1, r + 1);\n            nPk = 1;\n        } else {\n            int iPk;\n            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n            nPk = pPk->nKeyCol;\n            r = sqlite3GetTempRange(pParse, nPk + 1);\n            for (iPk = 0; iPk < nPk; iPk++) {\n                int iCol = pPk->aiColumn[iPk];\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + 1 + iPk);\n            }\n        }\n        jmp1 = sqlite3VdbeAddOp4Int(v, 29, pRJ->iMatch, 0, r + 1, nPk);\n        ;\n        ;\n        sqlite3VdbeAddOp3(v, 97, r + 1, nPk, r);\n        sqlite3VdbeAddOp4Int(v, 138, pRJ->iMatch, r, r + 1, nPk);\n        sqlite3VdbeAddOp4Int(v, 180, pRJ->regBloom, 0, r + 1, nPk);\n        sqlite3VdbeChangeP5(v, 16);\n        sqlite3VdbeJumpHere(v, jmp1);\n        sqlite3ReleaseTempRange(pParse, r, nPk + 1);\n    }\n    if (pLevel->iLeftJoin) {\n        pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeAddOp2(v, 71, 1, pLevel->iLeftJoin);\n        ;\n        if (pLevel->pRJ == 0) {\n            goto code_outer_join_constraints;\n        }\n    }\n    if (pLevel->pRJ) {\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        sqlite3VdbeAddOp2(v, 74, 0, pRJ->regReturn);\n        pRJ->addrSubrtn = sqlite3VdbeCurrentAddr(v);\n        ((void)0);\n        pParse->withinRJSubrtn++;\n      code_outer_join_constraints:\n        for (pTerm = pWC->a , j = 0; j < pWC->nBase; j++ , pTerm++) {\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                ((void)0);\n                continue;\n            }\n            if (pTabItem->fg.jointype & 64)\n                continue;\n            ((void)0);\n            sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 16);\n            pTerm->wtFlags |= 4;\n        }\n    }\n    return pLevel->notReady;\n}\n"
  },
  {
    "id": "sqlite3.c#103714:1#lookupName",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int i, j;\n    int cnt = 0;\n    int cntTab = 0;\n    int nSubquery = 0;\n    sqlite3 *db = pParse->db;\n    SrcItem *pItem;\n    SrcItem *pMatch = 0;\n    NameContext *pTopNC = pNC;\n    Schema *pSchema = 0;\n    int eNewExprOp = 167;\n    Table *pTab = 0;\n    Column *pCol;\n    ExprList *pFJMatch = 0;\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    pExpr->iTable = -1;\n    ;\n    if (zDb) {\n        ;\n        ;\n        if ((pNC->ncFlags & (2 | 4)) != 0) {\n            zDb = 0;\n        } else {\n            for (i = 0; i < db->nDb; i++) {\n                ((void)0);\n                if (sqlite3StrICmp(db->aDb[i].zDbSName, zDb) == 0) {\n                    pSchema = db->aDb[i].pSchema;\n                    break;\n                }\n            }\n            if (i == db->nDb && sqlite3StrICmp(\"main\", zDb) == 0) {\n                pSchema = db->aDb[0].pSchema;\n                zDb = db->aDb[0].zDbSName;\n            }\n        }\n    }\n    ((void)0);\n    do {\n        ExprList *pEList;\n        SrcList *pSrcList = pNC->pSrcList;\n        if (pSrcList) {\n            for (i = 0 , pItem = pSrcList->a; i < pSrcList->nSrc; i++ , pItem++) {\n                u8 hCol;\n                pTab = pItem->pTab;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pItem->fg.isNestedFrom) {\n                    int hit = 0;\n                    ((void)0);\n                    pEList = pItem->pSelect->pEList;\n                    ((void)0);\n                    ((void)0);\n                    for (j = 0; j < pEList->nExpr; j++) {\n                        if (!sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb)) {\n                            continue;\n                        }\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        cntTab = 2;\n                        pMatch = pItem;\n                        pExpr->iColumn = j;\n                        pEList->a[j].fg.bUsed = 1;\n                        hit = 1;\n                        if (pEList->a[j].fg.bUsingTerm)\n                            break;\n                    }\n                    if (hit || zTab == 0)\n                        continue;\n                }\n                ((void)0);\n                if (zTab) {\n                    const char *zTabName;\n                    if (zDb) {\n                        if (pTab->pSchema != pSchema)\n                            continue;\n                        if (pSchema == 0 && strcmp(zDb, \"*\") != 0)\n                            continue;\n                    }\n                    zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n                    ((void)0);\n                    if (sqlite3StrICmp(zTabName, zTab) != 0) {\n                        continue;\n                    }\n                    ((void)0);\n                    if ((pParse->eParseMode >= 2) && pItem->zAlias) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)&pExpr->y.pTab);\n                    }\n                }\n                hCol = sqlite3StrIHash(zCol);\n                for (j = 0 , pCol = pTab->aCol; j < pTab->nCol; j++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        pMatch = pItem;\n                        pExpr->iColumn = j == pTab->iPKey ? -1 : (i16)j;\n                        if (pItem->fg.isNestedFrom) {\n                            sqlite3SrcItemColumnUsed(pItem, j);\n                        }\n                        break;\n                    }\n                }\n                if (0 == cnt && (((pTab)->tabFlags & 512) == 0)) {\n                    cntTab++;\n                    pMatch = pItem;\n                }\n            }\n            if (pMatch) {\n                pExpr->iTable = pMatch->iCursor;\n                ((void)0);\n                pExpr->y.pTab = pMatch->pTab;\n                if ((pMatch->fg.jointype & (8 | 64)) != 0) {\n                    (pExpr)->flags |= (2097152);\n                }\n                pSchema = pExpr->y.pTab->pSchema;\n            }\n        }\n        if (cnt == 0 && zDb == 0) {\n            pTab = 0;\n            if (pParse->pTriggerTab != 0) {\n                int op = pParse->eTriggerOp;\n                ((void)0);\n                if (pParse->bReturning) {\n                    if ((pNC->ncFlags & 1024) != 0 && (zTab == 0 || sqlite3StrICmp(zTab, pParse->pTriggerTab->zName) == 0)) {\n                        pExpr->iTable = op != 128;\n                        pTab = pParse->pTriggerTab;\n                    }\n                } else if (op != 128 && zTab && sqlite3StrICmp(\"new\", zTab) == 0) {\n                    pExpr->iTable = 1;\n                    pTab = pParse->pTriggerTab;\n                } else if (op != 127 && zTab && sqlite3StrICmp(\"old\", zTab) == 0) {\n                    pExpr->iTable = 0;\n                    pTab = pParse->pTriggerTab;\n                }\n            }\n            if ((pNC->ncFlags & 512) != 0 && zTab != 0) {\n                Upsert *pUpsert = pNC->uNC.pUpsert;\n                if (pUpsert && sqlite3StrICmp(\"excluded\", zTab) == 0) {\n                    pTab = pUpsert->pUpsertSrc->a[0].pTab;\n                    pExpr->iTable = 2;\n                }\n            }\n            if (pTab) {\n                int iCol;\n                u8 hCol = sqlite3StrIHash(zCol);\n                pSchema = pTab->pSchema;\n                cntTab++;\n                for (iCol = 0 , pCol = pTab->aCol; iCol < pTab->nCol; iCol++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (iCol == pTab->iPKey) {\n                            iCol = -1;\n                        }\n                        break;\n                    }\n                }\n                if (iCol >= pTab->nCol && sqlite3IsRowid(zCol) && (((pTab)->tabFlags & 512) == 0)) {\n                    iCol = -1;\n                }\n                if (iCol < pTab->nCol) {\n                    cnt++;\n                    pMatch = 0;\n                    if (pExpr->iTable == 2) {\n                        ;\n                        ((void)0);\n                        if ((pParse->eParseMode >= 2)) {\n                            pExpr->iColumn = iCol;\n                            pExpr->y.pTab = pTab;\n                            eNewExprOp = 167;\n                        } else {\n                            pExpr->iTable = pNC->uNC.pUpsert->regData + sqlite3TableColumnToStorage(pTab, iCol);\n                            eNewExprOp = 176;\n                        }\n                    } else {\n                        ((void)0);\n                        pExpr->y.pTab = pTab;\n                        if (pParse->bReturning) {\n                            eNewExprOp = 176;\n                            pExpr->op2 = 167;\n                            pExpr->iColumn = iCol;\n                            pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol + 1) * pExpr->iTable + sqlite3TableColumnToStorage(pTab, iCol) + 1;\n                        } else {\n                            pExpr->iColumn = (i16)iCol;\n                            eNewExprOp = 77;\n                            if (iCol < 0) {\n                                pExpr->affExpr = 68;\n                            } else if (pExpr->iTable == 0) {\n                                ;\n                                ;\n                                pParse->oldmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            } else {\n                                ;\n                                ;\n                                pParse->newmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (cnt == 0 && cntTab == 1 && pMatch && (pNC->ncFlags & (32 | 8)) == 0 && sqlite3IsRowid(zCol) && ((((pMatch->pTab)->tabFlags & 512) == 0))) {\n            cnt = 1;\n            pExpr->iColumn = -1;\n            pExpr->affExpr = 68;\n        }\n        if (cnt == 0 && (pNC->ncFlags & 128) != 0 && zTab == 0) {\n            pEList = pNC->uNC.pEList;\n            ((void)0);\n            for (j = 0; j < pEList->nExpr; j++) {\n                char *zAs = pEList->a[j].zEName;\n                if (pEList->a[j].fg.eEName == 0 && sqlite3_stricmp(zAs, zCol) == 0) {\n                    Expr *pOrig;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    pOrig = pEList->a[j].pExpr;\n                    if ((pNC->ncFlags & 1) == 0 && (((pOrig)->flags & (16)) != 0)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n                        return 2;\n                    }\n                    if ((((pOrig)->flags & (32768)) != 0) && ((pNC->ncFlags & 16384) == 0 || pNC != pTopNC)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\", zAs);\n                        return 2;\n                    }\n                    if (sqlite3ExprVectorSize(pOrig) != 1) {\n                        sqlite3ErrorMsg(pParse, \"row value misused\");\n                        return 2;\n                    }\n                    resolveAlias(pParse, pEList, j, pExpr, nSubquery);\n                    cnt = 1;\n                    pMatch = 0;\n                    ((void)0);\n                    if ((pParse->eParseMode >= 2)) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)pExpr);\n                    }\n                    goto lookupname_end;\n                }\n            }\n        }\n        if (cnt)\n            break;\n        pNC = pNC->pNext;\n        nSubquery++;\n    } while (pNC);\n    if (cnt == 0 && zTab == 0) {\n        ((void)0);\n        if ((((pExpr)->flags & (128)) != 0) && areDoubleQuotedStringsEnabled(db, pTopNC)) {\n            sqlite3_log(28, \"double-quoted string literal: \\\"%w\\\"\", zCol);\n            pExpr->op = 117;\n            __builtin___memset_chk(&pExpr->y, 0, sizeof (pExpr->y), __builtin_object_size(&pExpr->y, 0));\n            return 1;\n        }\n        if (sqlite3ExprIdToTrueFalse(pExpr)) {\n            return 1;\n        }\n    }\n    ((void)0);\n    ((void)0);\n    if (cnt != 1) {\n        const char *zErr;\n        if (pFJMatch) {\n            if (pFJMatch->nExpr == cnt - 1) {\n                if ((((pExpr)->flags & (8388608)) != 0)) {\n                    (pExpr)->flags &= ~(8388608);\n                } else {\n                    sqlite3ExprDelete(db, pExpr->pLeft);\n                    pExpr->pLeft = 0;\n                    sqlite3ExprDelete(db, pExpr->pRight);\n                    pExpr->pRight = 0;\n                }\n                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                pExpr->op = 172;\n                pExpr->u.zToken = \"coalesce\";\n                pExpr->x.pList = pFJMatch;\n                cnt = 1;\n                goto lookupname_end;\n            } else {\n                sqlite3ExprListDelete(db, pFJMatch);\n                pFJMatch = 0;\n            }\n        }\n        zErr = cnt == 0 ? \"no such column\" : \"ambiguous column name\";\n        if (zDb) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n        } else if (zTab) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n        } else {\n            sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n        }\n        sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);\n        pParse->checkSchema = 1;\n        pTopNC->nNcErr++;\n    }\n    ((void)0);\n    if (!(((pExpr)->flags & ((65536 | 8388608))) != 0)) {\n        sqlite3ExprDelete(db, pExpr->pLeft);\n        pExpr->pLeft = 0;\n        sqlite3ExprDelete(db, pExpr->pRight);\n        pExpr->pRight = 0;\n        (pExpr)->flags |= (8388608);\n    }\n    if (pExpr->iColumn >= 0 && pMatch != 0) {\n        pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n    }\n    pExpr->op = eNewExprOp;\n  lookupname_end:\n    if (cnt == 1) {\n        ((void)0);\n        if (pParse->db->xAuth && (pExpr->op == 167 || pExpr->op == 77)) {\n            sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n        }\n        for (;;) {\n            ((void)0);\n            pTopNC->nRef++;\n            if (pTopNC == pNC)\n                break;\n            pTopNC = pTopNC->pNext;\n        }\n        return 1;\n    } else {\n        return 2;\n    }\n}\n"
  }
]
[
  {
    "id": "shell.c#26308:1#quickscan",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    char cin;\n    char cWait = (char)qss;\n    if (cWait == 0) {\n      PlainScan:\n        ((void)0);\n        while ((cin = *zLine++) != 0)\n            {\n                if (isspace((unsigned char)cin))\n                    continue;\n                switch (cin) {\n                  case '-':\n                    if (*zLine != '-')\n                        break;\n                    while ((cin = *++zLine) != 0)\n                        if (cin == '\\n')\n                            goto PlainScan;\n                    return qss;\n                  case ';':\n                    qss |= QSS_EndingSemi;\n                    continue;\n                  case '/':\n                    if (*zLine == '*') {\n                        ++zLine;\n                        cWait = '*';\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, \"/*\", 0);\n                        qss = ((cWait) | ((qss) & QSS_ScanMask));\n                        goto TermScan;\n                    }\n                    break;\n                  case '[':\n                    cin = ']';\n                    ;\n                  case '`':\n                  case '\\'':\n                  case '\"':\n                    cWait = cin;\n                    qss = QSS_HasDark | cWait;\n                    if (pst && stdin_is_interactive)\n                        setLexemeOpen(pst, 0, cin);\n                    goto TermScan;\n                  case '(':\n                    if (pst && stdin_is_interactive)\n                        (trackParenLevel(pst, 1));\n                    break;\n                  case ')':\n                    if (pst && stdin_is_interactive)\n                        (trackParenLevel(pst, -1));\n                    break;\n                  default:\n                    break;\n                }\n                qss = (qss & ~QSS_EndingSemi) | QSS_HasDark;\n            }\n    } else {\n      TermScan:\n        while ((cin = *zLine++) != 0)\n            {\n                if (cin == cWait) {\n                    switch (cWait) {\n                      case '*':\n                        if (*zLine != '/')\n                            continue;\n                        ++zLine;\n                        cWait = 0;\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, 0, 0);\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      case '`':\n                      case '\\'':\n                      case '\"':\n                        if (*zLine == cWait) {\n                            ++zLine;\n                            continue;\n                        }\n                        ;\n                      case ']':\n                        cWait = 0;\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, 0, 0);\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      default:\n                        ((void)0);\n                    }\n                }\n            }\n    }\n    return qss;\n}\n"
  },
  {
    "id": "shell.c#22965:1#do_meta_command",
    "gotos": 48,
    "labels": 3,
    "body": "{\n    int h = 1;\n    int nArg = 0;\n    int n, c;\n    int rc = 0;\n    char *azArg[52];\n    if (p->expert.pExpert) {\n        expertFinish(p, 1, 0);\n    }\n    while (zLine[h] && nArg < (int)(sizeof (azArg) / sizeof (azArg[0])) - 1)\n        {\n            while (isspace((unsigned char)zLine[h]))\n                {\n                    h++;\n                }\n            if (zLine[h] == 0)\n                break;\n            if (zLine[h] == '\\'' || zLine[h] == '\"') {\n                int delim = zLine[h++];\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && zLine[h] != delim)\n                    {\n                        if (zLine[h] == '\\\\' && delim == '\"' && zLine[h + 1] != 0)\n                            h++;\n                        h++;\n                    }\n                if (zLine[h] == delim) {\n                    zLine[h++] = 0;\n                }\n                if (delim == '\"')\n                    resolve_backslashes(azArg[nArg - 1]);\n            } else {\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && !isspace((unsigned char)zLine[h]))\n                    {\n                        h++;\n                    }\n                if (zLine[h])\n                    zLine[h++] = 0;\n                resolve_backslashes(azArg[nArg - 1]);\n            }\n        }\n    azArg[nArg] = 0;\n    if (nArg == 0)\n        return 0;\n    n = strlen30(azArg[0]);\n    c = azArg[0][0];\n    clearTempFile(p);\n    if (c == 'a' && cli_strncmp(azArg[0], \"auth\", n) == 0) {\n        if (nArg != 2) {\n            fprintf(__stderrp, \"Usage: .auth ON|OFF\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (booleanValue(azArg[1])) {\n            sqlite3_set_authorizer(p->db, shellAuth, p);\n        } else if (p->bSafeModePersist) {\n            sqlite3_set_authorizer(p->db, safeModeAuth, p);\n        } else {\n            sqlite3_set_authorizer(p->db, 0, 0);\n        }\n    } else if (c == 'a' && cli_strncmp(azArg[0], \"archive\", n) == 0) {\n        open_db(p, 0);\n        failIfSafeMode(p, \"cannot run .archive in safe mode\");\n        rc = arDotCommand(p, 0, azArg, nArg);\n    } else if ((c == 'b' && n >= 3 && cli_strncmp(azArg[0], \"backup\", n) == 0) || (c == 's' && n >= 3 && cli_strncmp(azArg[0], \"save\", n) == 0)) {\n        const char *zDestFile = 0;\n        const char *zDb = 0;\n        sqlite3 *pDest;\n        sqlite3_backup *pBackup;\n        int j;\n        int bAsync = 0;\n        const char *zVfs = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        for (j = 1; j < nArg; j++) {\n            const char *z = azArg[j];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-append\") == 0) {\n                    zVfs = \"apndvfs\";\n                } else if (cli_strcmp(z, \"-async\") == 0) {\n                    bAsync = 1;\n                } else {\n                    fprintf(__stderrp, \"unknown option: %s\\n\", azArg[j]);\n                    return 1;\n                }\n            } else if (zDestFile == 0) {\n                zDestFile = azArg[j];\n            } else if (zDb == 0) {\n                zDb = zDestFile;\n                zDestFile = azArg[j];\n            } else {\n                fprintf(__stderrp, \"Usage: .backup ?DB? ?OPTIONS? FILENAME\\n\");\n                return 1;\n            }\n        }\n        if (zDestFile == 0) {\n            fprintf(__stderrp, \"missing FILENAME argument on .backup\\n\");\n            return 1;\n        }\n        if (zDb == 0)\n            zDb = \"main\";\n        rc = sqlite3_open_v2(zDestFile, &pDest, 2 | 4, zVfs);\n        if (rc != 0) {\n            fprintf(__stderrp, \"Error: cannot open \\\"%s\\\"\\n\", zDestFile);\n            close_db(pDest);\n            return 1;\n        }\n        if (bAsync) {\n            sqlite3_exec(pDest, \"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\", 0, 0, 0);\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(pDest, \"main\", p->db, zDb);\n        if (pBackup == 0) {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(pDest));\n            close_db(pDest);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0)\n            {\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(pDest));\n            rc = 1;\n        }\n        close_db(pDest);\n    } else if (c == 'b' && n >= 3 && cli_strncmp(azArg[0], \"bail\", n) == 0) {\n        if (nArg == 2) {\n            bail_on_error = booleanValue(azArg[1]);\n        } else {\n            fprintf(__stderrp, \"Usage: .bail on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && cli_strncmp(azArg[0], \"binary\", n) == 0) {\n        if (nArg == 2) {\n            if (booleanValue(azArg[1])) {\n                ;\n            } else {\n                ;\n            }\n        } else {\n            fprintf(__stderrp, \"Usage: .binary on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && cli_strncmp(azArg[0], \"breakpoint\", n) == 0) {\n        test_breakpoint();\n    } else if (c == 'c' && cli_strcmp(azArg[0], \"cd\") == 0) {\n        failIfSafeMode(p, \"cannot run .cd in safe mode\");\n        if (nArg == 2) {\n            rc = chdir(azArg[1]);\n            if (rc) {\n                fprintf(__stderrp, \"Cannot change to directory \\\"%s\\\"\\n\", azArg[1]);\n                rc = 1;\n            }\n        } else {\n            fprintf(__stderrp, \"Usage: .cd DIRECTORY\\n\");\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && cli_strncmp(azArg[0], \"changes\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 32, azArg[1]);\n        } else {\n            fprintf(__stderrp, \"Usage: .changes on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && cli_strncmp(azArg[0], \"check\", n) == 0) {\n        char *zRes = 0;\n        output_reset(p);\n        if (nArg != 2) {\n            fprintf(__stderrp, \"Usage: .check GLOB-PATTERN\\n\");\n            rc = 2;\n        } else if ((zRes = readFile(\"testcase-out.txt\", 0)) == 0) {\n            fprintf(__stderrp, \"Error: cannot read 'testcase-out.txt'\\n\");\n            rc = 2;\n        } else if (testcase_glob(azArg[1], zRes) == 0) {\n            fprintf(__stderrp, \"testcase-%s FAILED\\n Expected: [%s]\\n      Got: [%s]\\n\", p->zTestcase, azArg[1], zRes);\n            rc = 1;\n        } else {\n            fprintf(__stdoutp, \"testcase-%s ok\\n\", p->zTestcase);\n            p->nCheck++;\n        }\n        sqlite3_free(zRes);\n    } else if (c == 'c' && cli_strncmp(azArg[0], \"clone\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .clone in safe mode\");\n        if (nArg == 2) {\n            tryToClone(p, azArg[1]);\n        } else {\n            fprintf(__stderrp, \"Usage: .clone FILENAME\\n\");\n            rc = 1;\n        }\n    } else if (c == 'c' && cli_strncmp(azArg[0], \"connection\", n) == 0) {\n        if (nArg == 1) {\n            int i;\n            for (i = 0; i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0])); i++) {\n                const char *zFile = p->aAuxDb[i].zDbFilename;\n                if (p->aAuxDb[i].db == 0 && p->pAuxDb != &p->aAuxDb[i]) {\n                    zFile = \"(not open)\";\n                } else if (zFile == 0) {\n                    zFile = \"(memory)\";\n                } else if (zFile[0] == 0) {\n                    zFile = \"(temporary-file)\";\n                }\n                if (p->pAuxDb == &p->aAuxDb[i]) {\n                    fprintf(__stdoutp, \"ACTIVE %d: %s\\n\", i, zFile);\n                } else if (p->aAuxDb[i].db != 0) {\n                    fprintf(__stdoutp, \"       %d: %s\\n\", i, zFile);\n                }\n            }\n        } else if (nArg == 2 && isdigit((unsigned char)azArg[1][0]) && azArg[1][1] == 0) {\n            int i = azArg[1][0] - '0';\n            if (p->pAuxDb != &p->aAuxDb[i] && i >= 0 && i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n                p->pAuxDb->db = p->db;\n                p->pAuxDb = &p->aAuxDb[i];\n                globalDb = p->db = p->pAuxDb->db;\n                p->pAuxDb->db = 0;\n            }\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"close\") == 0 && isdigit((unsigned char)azArg[2][0]) && azArg[2][1] == 0) {\n            int i = azArg[2][0] - '0';\n            if (i < 0 || i >= (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n            } else if (p->pAuxDb == &p->aAuxDb[i]) {\n                fprintf(__stderrp, \"cannot close the active database connection\\n\");\n                rc = 1;\n            } else if (p->aAuxDb[i].db) {\n                ;\n                close_db(p->aAuxDb[i].db);\n                p->aAuxDb[i].db = 0;\n            }\n        } else {\n            fprintf(__stderrp, \"Usage: .connection [close] [CONNECTION-NUMBER]\\n\");\n            rc = 1;\n        }\n    } else if (c == 'd' && n > 1 && cli_strncmp(azArg[0], \"databases\", n) == 0) {\n        char **azName = 0;\n        int nName = 0;\n        sqlite3_stmt *pStmt;\n        int i;\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n            rc = 1;\n        } else {\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zSchema = (const char *)sqlite3_column_text(pStmt, 1);\n                    const char *zFile = (const char *)sqlite3_column_text(pStmt, 2);\n                    if (zSchema == 0 || zFile == 0)\n                        continue;\n                    azName = sqlite3_realloc(azName, (nName + 1) * 2 * sizeof(char *));\n                    shell_check_oom(azName);\n                    azName[nName * 2] = strdup(zSchema);\n                    azName[nName * 2 + 1] = strdup(zFile);\n                    nName++;\n                }\n        }\n        sqlite3_finalize(pStmt);\n        for (i = 0; i < nName; i++) {\n            int eTxn = sqlite3_txn_state(p->db, azName[i * 2]);\n            int bRdonly = sqlite3_db_readonly(p->db, azName[i * 2]);\n            const char *z = azName[i * 2 + 1];\n            fprintf(p->out, \"%s: %s %s%s\\n\", azName[i * 2], z && z[0] ? z : \"\\\"\\\"\", bRdonly ? \"r/o\" : \"r/w\", eTxn == 0 ? \"\" : eTxn == 1 ? \" read-txn\" : \" write-txn\");\n            free(azName[i * 2]);\n            free(azName[i * 2 + 1]);\n        }\n        sqlite3_free(azName);\n    } else if (c == 'd' && n >= 3 && cli_strncmp(azArg[0], \"dbconfig\", n) == 0) {\n        static const struct DbConfigChoices {\n            const char *zName;\n            int op;\n        } aDbConfig[] = {{\"defensive\", 1010}, {\"dqs_ddl\", 1014}, {\"dqs_dml\", 1013}, {\"enable_fkey\", 1002}, {\"enable_qpsg\", 1007}, {\"enable_trigger\", 1003}, {\"enable_view\", 1015}, {\"fts3_tokenizer\", 1004}, {\"legacy_alter_table\", 1012}, {\"legacy_file_format\", 1016}, {\"load_extension\", 1005}, {\"no_ckpt_on_close\", 1006}, {\"reset_database\", 1009}, {\"trigger_eqp\", 1008}, {\"trusted_schema\", 1017}, {\"writable_schema\", 1011}};\n        int ii, v;\n        open_db(p, 0);\n        for (ii = 0; ii < (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0])); ii++) {\n            if (nArg > 1 && cli_strcmp(azArg[1], aDbConfig[ii].zName) != 0)\n                continue;\n            if (nArg >= 3) {\n                sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);\n            }\n            sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);\n            fprintf(p->out, \"%19s %s\\n\", aDbConfig[ii].zName, v ? \"on\" : \"off\");\n            if (nArg > 1)\n                break;\n        }\n        if (nArg > 1 && ii == (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0]))) {\n            fprintf(__stderrp, \"Error: unknown dbconfig \\\"%s\\\"\\n\", azArg[1]);\n            fprintf(__stderrp, \"Enter \\\".dbconfig\\\" with no arguments for a list\\n\");\n        }\n    } else if (c == 'd' && n >= 3 && cli_strncmp(azArg[0], \"dbinfo\", n) == 0) {\n        rc = shell_dbinfo_command(p, nArg, azArg);\n    } else if (c == 'r' && cli_strncmp(azArg[0], \"recover\", n) == 0) {\n        open_db(p, 0);\n        rc = recoverDatabaseCmd(p, nArg, azArg);\n    } else if (c == 'd' && cli_strncmp(azArg[0], \"dump\", n) == 0) {\n        char *zLike = 0;\n        char *zSql;\n        int i;\n        int savedShowHeader = p->showHeader;\n        int savedShellFlags = p->shellFlgs;\n        ((p)->shellFlgs &= (~(8 | 16 | 64 | 256 | 512)));\n        for (i = 1; i < nArg; i++) {\n            if (azArg[i][0] == '-') {\n                const char *z = azArg[i] + 1;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"preserve-rowids\") == 0) {\n                    ((p)->shellFlgs |= (8));\n                } else if (cli_strcmp(z, \"newlines\") == 0) {\n                    ((p)->shellFlgs |= (16));\n                } else if (cli_strcmp(z, \"data-only\") == 0) {\n                    ((p)->shellFlgs |= (256));\n                } else if (cli_strcmp(z, \"nosys\") == 0) {\n                    ((p)->shellFlgs |= (512));\n                } else {\n                    fprintf(__stderrp, \"Unknown option \\\"%s\\\" on \\\".dump\\\"\\n\", azArg[i]);\n                    rc = 1;\n                    sqlite3_free(zLike);\n                    goto meta_command_exit;\n                }\n            } else {\n                char *zExpr = sqlite3_mprintf(\"name LIKE %Q ESCAPE '\\\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\", azArg[i], azArg[i]);\n                if (zLike) {\n                    zLike = sqlite3_mprintf(\"%z OR %z\", zLike, zExpr);\n                } else {\n                    zLike = zExpr;\n                }\n            }\n        }\n        open_db(p, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(p->out, \"PRAGMA foreign_keys=OFF;\\n\");\n            fprintf(p->out, \"BEGIN TRANSACTION;\\n\");\n        }\n        p->writableSchema = 0;\n        p->showHeader = 0;\n        sqlite3_exec(p->db, \"SAVEPOINT dump; PRAGMA writable_schema=ON\", 0, 0, 0);\n        p->nErr = 0;\n        if (zLike == 0)\n            zLike = sqlite3_mprintf(\"true\");\n        zSql = sqlite3_mprintf(\"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\", zLike);\n        run_schema_dump_query(p, zSql);\n        sqlite3_free(zSql);\n        if ((p->shellFlgs & 256) == 0) {\n            zSql = sqlite3_mprintf(\"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\", zLike);\n            run_table_dump_query(p, zSql);\n            sqlite3_free(zSql);\n        }\n        sqlite3_free(zLike);\n        if (p->writableSchema) {\n            fprintf(p->out, \"PRAGMA writable_schema=OFF;\\n\");\n            p->writableSchema = 0;\n        }\n        sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);\n        sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");\n        }\n        p->showHeader = savedShowHeader;\n        p->shellFlgs = savedShellFlags;\n    } else if (c == 'e' && cli_strncmp(azArg[0], \"echo\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 64, azArg[1]);\n        } else {\n            fprintf(__stderrp, \"Usage: .echo on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 'e' && cli_strncmp(azArg[0], \"eqp\", n) == 0) {\n        if (nArg == 2) {\n            p->autoEQPtest = 0;\n            if (p->autoEQPtrace) {\n                if (p->db)\n                    sqlite3_exec(p->db, \"PRAGMA vdbe_trace=OFF;\", 0, 0, 0);\n                p->autoEQPtrace = 0;\n            }\n            if (cli_strcmp(azArg[1], \"full\") == 0) {\n                p->autoEQP = 3;\n            } else if (cli_strcmp(azArg[1], \"trigger\") == 0) {\n                p->autoEQP = 2;\n            } else {\n                p->autoEQP = (u8)booleanValue(azArg[1]);\n            }\n        } else {\n            fprintf(__stderrp, \"Usage: .eqp off|on|trace|trigger|full\\n\");\n            rc = 1;\n        }\n    } else if (c == 'e' && cli_strncmp(azArg[0], \"exit\", n) == 0) {\n        if (nArg > 1 && (rc = (int)integerValue(azArg[1])) != 0)\n            exit(rc);\n        rc = 2;\n    } else if (c == 'e' && cli_strncmp(azArg[0], \"explain\", n) == 0) {\n        int val = 1;\n        if (nArg >= 2) {\n            if (cli_strcmp(azArg[1], \"auto\") == 0) {\n                val = 99;\n            } else {\n                val = booleanValue(azArg[1]);\n            }\n        }\n        if (val == 1 && p->mode != 9) {\n            p->normalMode = p->mode;\n            p->mode = 9;\n            p->autoExplain = 0;\n        } else if (val == 0) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 0;\n        } else if (val == 99) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 1;\n        }\n    } else if (c == 'e' && cli_strncmp(azArg[0], \"expert\", n) == 0) {\n        if (p->bSafeMode) {\n            fprintf(__stderrp, \"Cannot run experimental commands such as \\\"%s\\\" in safe mode\\n\", azArg[0]);\n            rc = 1;\n        } else {\n            open_db(p, 0);\n            expertDotCommand(p, azArg, nArg);\n        }\n    } else if (c == 'f' && cli_strncmp(azArg[0], \"filectrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            const char *zUsage;\n        } aCtrl[] = {{\"chunk_size\", 6, \"SIZE\"}, {\"data_version\", 35, \"\"}, {\"has_moved\", 20, \"\"}, {\"lock_timeout\", 34, \"MILLISEC\"}, {\"persist_wal\", 10, \"[BOOLEAN]\"}, {\"psow\", 13, \"[BOOLEAN]\"}, {\"reserve_bytes\", 38, \"[N]\"}, {\"size_limit\", 36, \"[LIMIT]\"}, {\"tempfilename\", 16, \"\"}};\n        int filectrl = -1;\n        int iCtrl = -1;\n        sqlite3_int64 iRes = 0;\n        int isOk = 0;\n        int n2, i;\n        const char *zCmd = 0;\n        const char *zSchema = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && (cli_strcmp(zCmd, \"--schema\") == 0 || cli_strcmp(zCmd, \"-schema\") == 0) && nArg >= 4) {\n            zSchema = azArg[2];\n            for (i = 3; i < nArg; i++)\n                azArg[i - 2] = azArg[i];\n            nArg -= 2;\n            zCmd = azArg[1];\n        }\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(p->out, \"Available file-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(p->out, \"  .filectrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (cli_strncmp(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (filectrl < 0) {\n                    filectrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    fprintf(__stderrp, \"Error: ambiguous file-control: \\\"%s\\\"\\nUse \\\".filectrl --help\\\" for help\\n\", zCmd);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (filectrl < 0) {\n            fprintf(__stderrp, \"Error: unknown file-control: %s\\nUse \\\".filectrl --help\\\" for help\\n\", zCmd);\n        } else {\n            switch (filectrl) {\n              case 36:\n                {\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    iRes = nArg == 3 ? integerValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, 36, &iRes);\n                    isOk = 1;\n                    break;\n                }\n              case 34:\n              case 6:\n                {\n                    int x;\n                    if (nArg != 3)\n                        break;\n                    x = (int)integerValue(azArg[2]);\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    isOk = 2;\n                    break;\n                }\n              case 10:\n              case 13:\n                {\n                    int x;\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    x = nArg == 3 ? booleanValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 35:\n              case 20:\n                {\n                    int x;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 16:\n                {\n                    char *z = 0;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &z);\n                    if (z) {\n                        fprintf(p->out, \"%s\\n\", z);\n                        sqlite3_free(z);\n                    }\n                    isOk = 2;\n                    break;\n                }\n              case 38:\n                {\n                    int x;\n                    if (nArg >= 3) {\n                        x = atoi(azArg[2]);\n                        sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    }\n                    x = -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    fprintf(p->out, \"%d\\n\", x);\n                    isOk = 2;\n                    break;\n                }\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(p->out, \"Usage: .filectrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            char zBuf[100];\n            sqlite3_snprintf(sizeof (zBuf), zBuf, \"%lld\", iRes);\n            fprintf(p->out, \"%s\\n\", zBuf);\n        }\n    } else if (c == 'f' && cli_strncmp(azArg[0], \"fullschema\", n) == 0) {\n        ShellState data;\n        int doStats = 0;\n        __builtin___memcpy_chk(&data, p, sizeof (data), __builtin_object_size(&data, 0));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        if (nArg == 2 && optionMatch(azArg[1], \"indent\")) {\n            data.cMode = data.mode = 11;\n            nArg = 1;\n        }\n        if (nArg != 1) {\n            fprintf(__stderrp, \"Usage: .fullschema ?--indent?\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        rc = sqlite3_exec(p->db, \"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\", callback, &data, 0);\n        if (rc == 0) {\n            sqlite3_stmt *pStmt;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\", -1, &pStmt, 0);\n            doStats = sqlite3_step(pStmt) == 100;\n            sqlite3_finalize(pStmt);\n        }\n        if (doStats == 0) {\n            fprintf(p->out, \"/* No STAT tables available */\\n\");\n        } else {\n            fprintf(p->out, \"ANALYZE sqlite_schema;\\n\");\n            data.cMode = data.mode = 5;\n            data.zDestTable = \"sqlite_stat1\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat1\", 0);\n            data.zDestTable = \"sqlite_stat4\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat4\", 0);\n            fprintf(p->out, \"ANALYZE sqlite_schema;\\n\");\n        }\n    } else if (c == 'h' && cli_strncmp(azArg[0], \"headers\", n) == 0) {\n        if (nArg == 2) {\n            p->showHeader = booleanValue(azArg[1]);\n            p->shellFlgs |= 128;\n        } else {\n            fprintf(__stderrp, \"Usage: .headers on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 'h' && cli_strncmp(azArg[0], \"help\", n) == 0) {\n        if (nArg >= 2) {\n            n = showHelp(p->out, azArg[1]);\n            if (n == 0) {\n                fprintf(p->out, \"Nothing matches '%s'\\n\", azArg[1]);\n            }\n        } else {\n            showHelp(p->out, 0);\n        }\n    } else if (c == 'i' && cli_strncmp(azArg[0], \"import\", n) == 0) {\n        char *zTable = 0;\n        char *zSchema = 0;\n        char *zFile = 0;\n        sqlite3_stmt *pStmt = ((void *)0);\n        int nCol;\n        int nByte;\n        int i, j;\n        int needCommit;\n        int nSep;\n        char *zSql;\n        char *zFullTabName;\n        ImportCtx sCtx;\n        char *(*xRead)(ImportCtx *);\n        int eVerbose = 0;\n        int nSkip = 0;\n        int useOutputMode = 1;\n        char *zCreate = 0;\n        failIfSafeMode(p, \"cannot run .import in safe mode\");\n        __builtin___memset_chk(&sCtx, 0, sizeof (sCtx), __builtin_object_size(&sCtx, 0));\n        if (p->mode == 10) {\n            xRead = ascii_read_one_field;\n        } else {\n            xRead = csv_read_one_field;\n        }\n        rc = 1;\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (z[0] != '-') {\n                if (zFile == 0) {\n                    zFile = z;\n                } else if (zTable == 0) {\n                    zTable = z;\n                } else {\n                    fprintf(p->out, \"ERROR: extra argument: \\\"%s\\\".  Usage:\\n\", z);\n                    showHelp(p->out, \"import\");\n                    goto meta_command_exit;\n                }\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                eVerbose++;\n            } else if (cli_strcmp(z, \"-schema\") == 0 && i < nArg - 1) {\n                zSchema = azArg[++i];\n            } else if (cli_strcmp(z, \"-skip\") == 0 && i < nArg - 1) {\n                nSkip = integerValue(azArg[++i]);\n            } else if (cli_strcmp(z, \"-ascii\") == 0) {\n                sCtx.cColSep = \"\\037\"[0];\n                sCtx.cRowSep = \"\\036\"[0];\n                xRead = ascii_read_one_field;\n                useOutputMode = 0;\n            } else if (cli_strcmp(z, \"-csv\") == 0) {\n                sCtx.cColSep = ',';\n                sCtx.cRowSep = '\\n';\n                xRead = csv_read_one_field;\n                useOutputMode = 0;\n            } else {\n                fprintf(p->out, \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", z);\n                showHelp(p->out, \"import\");\n                goto meta_command_exit;\n            }\n        }\n        if (zTable == 0) {\n            fprintf(p->out, \"ERROR: missing %s argument. Usage:\\n\", zFile == 0 ? \"FILE\" : \"TABLE\");\n            showHelp(p->out, \"import\");\n            goto meta_command_exit;\n        }\n        seenInterrupt = 0;\n        open_db(p, 0);\n        if (useOutputMode) {\n            nSep = strlen30(p->colSeparator);\n            if (nSep == 0) {\n                fprintf(__stderrp, \"Error: non-null column separator required for import\\n\");\n                goto meta_command_exit;\n            }\n            if (nSep > 1) {\n                fprintf(__stderrp, \"Error: multi-character column separators not allowed for import\\n\");\n                goto meta_command_exit;\n            }\n            nSep = strlen30(p->rowSeparator);\n            if (nSep == 0) {\n                fprintf(__stderrp, \"Error: non-null row separator required for import\\n\");\n                goto meta_command_exit;\n            }\n            if (nSep == 2 && p->mode == 8 && cli_strcmp(p->rowSeparator, \"\\r\\n\") == 0) {\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n                nSep = strlen30(p->rowSeparator);\n            }\n            if (nSep > 1) {\n                fprintf(__stderrp, \"Error: multi-character row separators not allowed for import\\n\");\n                goto meta_command_exit;\n            }\n            sCtx.cColSep = p->colSeparator[0];\n            sCtx.cRowSep = p->rowSeparator[0];\n        }\n        sCtx.zFile = zFile;\n        sCtx.nLine = 1;\n        if (sCtx.zFile[0] == '|') {\n            sCtx.in = popen(sCtx.zFile + 1, \"r\");\n            sCtx.zFile = \"<pipe>\";\n            sCtx.xCloser = pclose;\n        } else {\n            sCtx.in = fopen(sCtx.zFile, \"rb\");\n            sCtx.xCloser = fclose;\n        }\n        if (sCtx.in == 0) {\n            fprintf(__stderrp, \"Error: cannot open \\\"%s\\\"\\n\", zFile);\n            goto meta_command_exit;\n        }\n        if (eVerbose >= 2 || (eVerbose >= 1 && useOutputMode)) {\n            char zSep[2];\n            zSep[1] = 0;\n            zSep[0] = sCtx.cColSep;\n            fprintf(p->out, \"Column separator \");\n            output_c_string(p->out, zSep);\n            fprintf(p->out, \", row separator \");\n            zSep[0] = sCtx.cRowSep;\n            output_c_string(p->out, zSep);\n            fprintf(p->out, \"\\n\");\n        }\n        sCtx.z = sqlite3_malloc64(120);\n        if (sCtx.z == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        while ((nSkip--) > 0)\n            {\n                while (xRead(&sCtx) && sCtx.cTerm == sCtx.cColSep)\n                    {\n                    }\n            }\n        if (zSchema != 0) {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\".\\\"%w\\\"\", zSchema, zTable);\n        } else {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\"\", zTable);\n        }\n        zSql = sqlite3_mprintf(\"SELECT * FROM %s\", zFullTabName);\n        if (zSql == 0 || zFullTabName == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        nByte = strlen30(zSql);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        import_append_char(&sCtx, 0);\n        if (rc && sqlite3_strglob(\"no such table: *\", sqlite3_errmsg(p->db)) == 0) {\n            sqlite3 *dbCols = 0;\n            char *zRenames = 0;\n            char *zColDefs;\n            zCreate = sqlite3_mprintf(\"CREATE TABLE %s\", zFullTabName);\n            while (xRead(&sCtx))\n                {\n                    zAutoColumn(sCtx.z, &dbCols, 0);\n                    if (sCtx.cTerm != sCtx.cColSep)\n                        break;\n                }\n            zColDefs = zAutoColumn(0, &dbCols, &zRenames);\n            if (zRenames != 0) {\n                fprintf((stdin_is_interactive && p->in == __stdinp) ? p->out : __stderrp, \"Columns renamed during .import %s due to duplicates:\\n%s\\n\", sCtx.zFile, zRenames);\n                sqlite3_free(zRenames);\n            }\n            ((void)0);\n            if (zColDefs == 0) {\n                fprintf(__stderrp, \"%s: empty file\\n\", sCtx.zFile);\n              import_fail:\n                sqlite3_free(zCreate);\n                sqlite3_free(zSql);\n                sqlite3_free(zFullTabName);\n                import_cleanup(&sCtx);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            zCreate = sqlite3_mprintf(\"%z%z\\n\", zCreate, zColDefs);\n            if (eVerbose >= 1) {\n                fprintf(p->out, \"%s\\n\", zCreate);\n            }\n            rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);\n            if (rc) {\n                fprintf(__stderrp, \"%s failed:\\n%s\\n\", zCreate, sqlite3_errmsg(p->db));\n                goto import_fail;\n            }\n            sqlite3_free(zCreate);\n            zCreate = 0;\n            rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        }\n        if (rc) {\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        nCol = sqlite3_column_count(pStmt);\n        sqlite3_finalize(pStmt);\n        pStmt = 0;\n        if (nCol == 0)\n            return 0;\n        zSql = sqlite3_malloc64(nByte * 2 + 20 + nCol * 2);\n        if (zSql == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        sqlite3_snprintf(nByte + 20, zSql, \"INSERT INTO %s VALUES(?\", zFullTabName);\n        j = strlen30(zSql);\n        for (i = 1; i < nCol; i++) {\n            zSql[j++] = ',';\n            zSql[j++] = '?';\n        }\n        zSql[j++] = ')';\n        zSql[j] = 0;\n        if (eVerbose >= 2) {\n            fprintf(p->out, \"Insert using: %s\\n\", zSql);\n        }\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        if (rc) {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        sqlite3_free(zFullTabName);\n        needCommit = sqlite3_get_autocommit(p->db);\n        if (needCommit)\n            sqlite3_exec(p->db, \"BEGIN\", 0, 0, 0);\n        do {\n            int startLine = sCtx.nLine;\n            for (i = 0; i < nCol; i++) {\n                char *z = xRead(&sCtx);\n                if (z == 0 && i == 0)\n                    break;\n                if (p->mode == 10 && (z == 0 || z[0] == 0) && i == 0)\n                    break;\n                sqlite3_bind_text(pStmt, i + 1, z, -1, ((sqlite3_destructor_type)-1));\n                if (i < nCol - 1 && sCtx.cTerm != sCtx.cColSep) {\n                    fprintf(__stderrp, \"%s:%d: expected %d columns but found %d - filling the rest with NULL\\n\", sCtx.zFile, startLine, nCol, i + 1);\n                    i += 2;\n                    while (i <= nCol)\n                        {\n                            sqlite3_bind_null(pStmt, i);\n                            i++;\n                        }\n                }\n            }\n            if (sCtx.cTerm == sCtx.cColSep) {\n                do {\n                    xRead(&sCtx);\n                    i++;\n                } while (sCtx.cTerm == sCtx.cColSep);\n                fprintf(__stderrp, \"%s:%d: expected %d columns but found %d - extras ignored\\n\", sCtx.zFile, startLine, nCol, i);\n            }\n            if (i >= nCol) {\n                sqlite3_step(pStmt);\n                rc = sqlite3_reset(pStmt);\n                if (rc != 0) {\n                    fprintf(__stderrp, \"%s:%d: INSERT failed: %s\\n\", sCtx.zFile, startLine, sqlite3_errmsg(p->db));\n                    sCtx.nErr++;\n                } else {\n                    sCtx.nRow++;\n                }\n            }\n        } while (sCtx.cTerm != (-1));\n        import_cleanup(&sCtx);\n        sqlite3_finalize(pStmt);\n        if (needCommit)\n            sqlite3_exec(p->db, \"COMMIT\", 0, 0, 0);\n        if (eVerbose > 0) {\n            fprintf(p->out, \"Added %d rows with %d errors using %d lines of input\\n\", sCtx.nRow, sCtx.nErr, sCtx.nLine - 1);\n        }\n    } else if (c == 'i' && cli_strncmp(azArg[0], \"imposter\", n) == 0) {\n        char *zSql;\n        char *zCollist = 0;\n        sqlite3_stmt *pStmt;\n        int tnum = 0;\n        int isWO = 0;\n        int lenPK = 0;\n        int i;\n        if (!(nArg == 3 || (nArg == 2 && sqlite3_stricmp(azArg[1], \"off\") == 0))) {\n            fprintf(__stderrp, \"Usage: .imposter INDEX IMPOSTER\\n       .imposter off\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (nArg == 2) {\n            sqlite3_test_control(25, p->db, \"main\", 0, 1);\n            goto meta_command_exit;\n        }\n        zSql = sqlite3_mprintf(\"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\", azArg[1], azArg[1]);\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        if (sqlite3_step(pStmt) == 100) {\n            tnum = sqlite3_column_int(pStmt, 0);\n            isWO = sqlite3_column_int(pStmt, 1);\n        }\n        sqlite3_finalize(pStmt);\n        zSql = sqlite3_mprintf(\"PRAGMA index_xinfo='%q'\", azArg[1]);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        i = 0;\n        while (rc == 0 && sqlite3_step(pStmt) == 100)\n            {\n                char zLabel[20];\n                const char *zCol = (const char *)sqlite3_column_text(pStmt, 2);\n                i++;\n                if (zCol == 0) {\n                    if (sqlite3_column_int(pStmt, 1) == -1) {\n                        zCol = \"_ROWID_\";\n                    } else {\n                        sqlite3_snprintf(sizeof (zLabel), zLabel, \"expr%d\", i);\n                        zCol = zLabel;\n                    }\n                }\n                if (isWO && lenPK == 0 && sqlite3_column_int(pStmt, 5) == 0 && zCollist) {\n                    lenPK = (int)strlen(zCollist);\n                }\n                if (zCollist == 0) {\n                    zCollist = sqlite3_mprintf(\"\\\"%w\\\"\", zCol);\n                } else {\n                    zCollist = sqlite3_mprintf(\"%z,\\\"%w\\\"\", zCollist, zCol);\n                }\n            }\n        sqlite3_finalize(pStmt);\n        if (i == 0 || tnum == 0) {\n            fprintf(__stderrp, \"no such index: \\\"%s\\\"\\n\", azArg[1]);\n            rc = 1;\n            sqlite3_free(zCollist);\n            goto meta_command_exit;\n        }\n        if (lenPK == 0)\n            lenPK = 100000;\n        zSql = sqlite3_mprintf(\"CREATE TABLE \\\"%w\\\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\", azArg[2], zCollist, lenPK, zCollist);\n        sqlite3_free(zCollist);\n        rc = sqlite3_test_control(25, p->db, \"main\", 1, tnum);\n        if (rc == 0) {\n            rc = sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_test_control(25, p->db, \"main\", 0, 0);\n            if (rc) {\n                fprintf(__stderrp, \"Error in [%s]: %s\\n\", zSql, sqlite3_errmsg(p->db));\n            } else {\n                fprintf(__stdoutp, \"%s;\\n\", zSql);\n                fprintf(__stdoutp, \"WARNING: writing to an imposter table will corrupt the \\\"%s\\\" %s!\\n\", azArg[1], isWO ? \"table\" : \"index\");\n            }\n        } else {\n            fprintf(__stderrp, \"SQLITE_TESTCTRL_IMPOSTER returns %d\\n\", rc);\n            rc = 1;\n        }\n        sqlite3_free(zSql);\n    } else if (c == 'l' && n >= 5 && cli_strncmp(azArg[0], \"limits\", n) == 0) {\n        static const struct {\n            const char *zLimitName;\n            int limitCode;\n        } aLimit[] = {{\"length\", 0}, {\"sql_length\", 1}, {\"column\", 2}, {\"expr_depth\", 3}, {\"compound_select\", 4}, {\"vdbe_op\", 5}, {\"function_arg\", 6}, {\"attached\", 7}, {\"like_pattern_length\", 8}, {\"variable_number\", 9}, {\"trigger_depth\", 10}, {\"worker_threads\", 11}};\n        int i, n2;\n        open_db(p, 0);\n        if (nArg == 1) {\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                printf(\"%20s %d\\n\", aLimit[i].zLimitName, sqlite3_limit(p->db, aLimit[i].limitCode, -1));\n            }\n        } else if (nArg > 3) {\n            fprintf(__stderrp, \"Usage: .limit NAME ?NEW-VALUE?\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        } else {\n            int iLimit = -1;\n            n2 = strlen30(azArg[1]);\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                if (sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2) == 0) {\n                    if (iLimit < 0) {\n                        iLimit = i;\n                    } else {\n                        fprintf(__stderrp, \"ambiguous limit: \\\"%s\\\"\\n\", azArg[1]);\n                        rc = 1;\n                        goto meta_command_exit;\n                    }\n                }\n            }\n            if (iLimit < 0) {\n                fprintf(__stderrp, \"unknown limit: \\\"%s\\\"\\nenter \\\".limits\\\" with no arguments for a list.\\n\", azArg[1]);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            if (nArg == 3) {\n                sqlite3_limit(p->db, aLimit[iLimit].limitCode, (int)integerValue(azArg[2]));\n            }\n            printf(\"%20s %d\\n\", aLimit[iLimit].zLimitName, sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));\n        }\n    } else if (c == 'l' && n > 2 && cli_strncmp(azArg[0], \"lint\", n) == 0) {\n        open_db(p, 0);\n        lintDotCommand(p, azArg, nArg);\n    } else if (c == 'l' && cli_strncmp(azArg[0], \"load\", n) == 0) {\n        const char *zFile, *zProc;\n        char *zErrMsg = 0;\n        failIfSafeMode(p, \"cannot run .load in safe mode\");\n        if (nArg < 2) {\n            fprintf(__stderrp, \"Usage: .load FILE ?ENTRYPOINT?\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zFile = azArg[1];\n        zProc = nArg >= 3 ? azArg[2] : 0;\n        open_db(p, 0);\n        rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);\n        if (rc != 0) {\n            fprintf(__stderrp, \"Error: %s\\n\", zErrMsg);\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        }\n    } else if (c == 'l' && cli_strncmp(azArg[0], \"log\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .log in safe mode\");\n        if (nArg != 2) {\n            fprintf(__stderrp, \"Usage: .log FILENAME\\n\");\n            rc = 1;\n        } else {\n            const char *zFile = azArg[1];\n            output_file_close(p->pLog);\n            p->pLog = output_file_open(zFile, 0);\n        }\n    } else if (c == 'm' && cli_strncmp(azArg[0], \"mode\", n) == 0) {\n        const char *zMode = 0;\n        const char *zTabname = 0;\n        int i, n2;\n        ColModeOpts cmOpts = {60, 0, 0};\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (optionMatch(z, \"wrap\") && i + 1 < nArg) {\n                cmOpts.iWrap = integerValue(azArg[++i]);\n            } else if (optionMatch(z, \"ww\")) {\n                cmOpts.bWordWrap = 1;\n            } else if (optionMatch(z, \"wordwrap\") && i + 1 < nArg) {\n                cmOpts.bWordWrap = (u8)booleanValue(azArg[++i]);\n            } else if (optionMatch(z, \"quote\")) {\n                cmOpts.bQuote = 1;\n            } else if (optionMatch(z, \"noquote\")) {\n                cmOpts.bQuote = 0;\n            } else if (zMode == 0) {\n                zMode = z;\n                if (cli_strcmp(z, \"qbox\") == 0) {\n                    ColModeOpts cmo = {60, 1, 0};\n                    zMode = \"box\";\n                    cmOpts = cmo;\n                }\n            } else if (zTabname == 0) {\n                zTabname = z;\n            } else if (z[0] == '-') {\n                fprintf(__stderrp, \"unknown option: %s\\n\", z);\n                fprintf(__stderrp, \"options:\\n  --noquote\\n  --quote\\n  --wordwrap on/off\\n  --wrap N\\n  --ww\\n\");\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                fprintf(__stderrp, \"extra argument: \\\"%s\\\"\\n\", z);\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zMode == 0) {\n            if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n                fprintf(p->out, \"current output mode: %s --wrap %d --wordwrap %s --%squote\\n\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n            } else {\n                fprintf(p->out, \"current output mode: %s\\n\", modeDescr[p->mode]);\n            }\n            zMode = modeDescr[p->mode];\n        }\n        n2 = strlen30(zMode);\n        if (cli_strncmp(zMode, \"lines\", n2) == 0) {\n            p->mode = 0;\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (cli_strncmp(zMode, \"columns\", n2) == 0) {\n            p->mode = 1;\n            if ((p->shellFlgs & 128) == 0) {\n                p->showHeader = 1;\n            }\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n            p->cmOpts = cmOpts;\n        } else if (cli_strncmp(zMode, \"list\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"|\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (cli_strncmp(zMode, \"html\", n2) == 0) {\n            p->mode = 4;\n        } else if (cli_strncmp(zMode, \"tcl\", n2) == 0) {\n            p->mode = 7;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \" \");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (cli_strncmp(zMode, \"csv\", n2) == 0) {\n            p->mode = 8;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n        } else if (cli_strncmp(zMode, \"tabs\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\t\");\n        } else if (cli_strncmp(zMode, \"insert\", n2) == 0) {\n            p->mode = 5;\n            set_table_name(p, zTabname ? zTabname : \"table\");\n        } else if (cli_strncmp(zMode, \"quote\", n2) == 0) {\n            p->mode = 6;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (cli_strncmp(zMode, \"ascii\", n2) == 0) {\n            p->mode = 10;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\037\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\036\");\n        } else if (cli_strncmp(zMode, \"markdown\", n2) == 0) {\n            p->mode = 14;\n            p->cmOpts = cmOpts;\n        } else if (cli_strncmp(zMode, \"table\", n2) == 0) {\n            p->mode = 15;\n            p->cmOpts = cmOpts;\n        } else if (cli_strncmp(zMode, \"box\", n2) == 0) {\n            p->mode = 16;\n            p->cmOpts = cmOpts;\n        } else if (cli_strncmp(zMode, \"count\", n2) == 0) {\n            p->mode = 17;\n        } else if (cli_strncmp(zMode, \"off\", n2) == 0) {\n            p->mode = 18;\n        } else if (cli_strncmp(zMode, \"json\", n2) == 0) {\n            p->mode = 13;\n        } else {\n            fprintf(__stderrp, \"Error: mode should be one of: ascii box column csv html insert json line list markdown qbox quote table tabs tcl\\n\");\n            rc = 1;\n        }\n        p->cMode = p->mode;\n    } else if (c == 'n' && cli_strcmp(azArg[0], \"nonce\") == 0) {\n        if (nArg != 2) {\n            fprintf(__stderrp, \"Usage: .nonce NONCE\\n\");\n            rc = 1;\n        } else if (p->zNonce == 0 || cli_strcmp(azArg[1], p->zNonce) != 0) {\n            fprintf(__stderrp, \"line %d: incorrect nonce: \\\"%s\\\"\\n\", p->lineno, azArg[1]);\n            exit(1);\n        } else {\n            p->bSafeMode = 0;\n            return 0;\n        }\n    } else if (c == 'n' && cli_strncmp(azArg[0], \"nullvalue\", n) == 0) {\n        if (nArg == 2) {\n            sqlite3_snprintf(sizeof (p->nullValue), p->nullValue, \"%.*s\", (int)(int)(sizeof (p->nullValue) / sizeof (p->nullValue[0])) - 1, azArg[1]);\n        } else {\n            fprintf(__stderrp, \"Usage: .nullvalue STRING\\n\");\n            rc = 1;\n        }\n    } else if (c == 'o' && cli_strncmp(azArg[0], \"open\", n) == 0 && n >= 2) {\n        const char *zFN = 0;\n        char *zNewFilename = 0;\n        int iName = 1;\n        int newFlag = 0;\n        int openMode = 0;\n        for (iName = 1; iName < nArg; iName++) {\n            const char *z = azArg[iName];\n            if (optionMatch(z, \"new\")) {\n                newFlag = 1;\n            } else if (optionMatch(z, \"zip\")) {\n                openMode = 3;\n            } else if (optionMatch(z, \"append\")) {\n                openMode = 2;\n            } else if (optionMatch(z, \"readonly\")) {\n                openMode = 4;\n            } else if (optionMatch(z, \"nofollow\")) {\n                p->openFlags |= 16777216;\n            } else if (optionMatch(z, \"deserialize\")) {\n                openMode = 5;\n            } else if (optionMatch(z, \"hexdb\")) {\n                openMode = 6;\n            } else if (optionMatch(z, \"maxsize\") && iName + 1 < nArg) {\n                p->szMax = integerValue(azArg[++iName]);\n            } else if (z[0] == '-') {\n                fprintf(__stderrp, \"unknown option: %s\\n\", z);\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zFN) {\n                fprintf(__stderrp, \"extra argument: \\\"%s\\\"\\n\", z);\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zFN = z;\n            }\n        }\n        ;\n        close_db(p->db);\n        p->db = 0;\n        p->pAuxDb->zDbFilename = 0;\n        sqlite3_free(p->pAuxDb->zFreeOnClose);\n        p->pAuxDb->zFreeOnClose = 0;\n        p->openMode = openMode;\n        p->openFlags = 0;\n        p->szMax = 0;\n        if (zFN || p->openMode == 6) {\n            if (newFlag && zFN && !p->bSafeMode)\n                shellDeleteFile(zFN);\n            if (p->bSafeMode && p->openMode != 6 && zFN && cli_strcmp(zFN, \":memory:\") != 0) {\n                failIfSafeMode(p, \"cannot open disk-based database files in safe mode\");\n            }\n            if (zFN) {\n                zNewFilename = sqlite3_mprintf(\"%s\", zFN);\n                shell_check_oom(zNewFilename);\n            } else {\n                zNewFilename = 0;\n            }\n            p->pAuxDb->zDbFilename = zNewFilename;\n            open_db(p, 1);\n            if (p->db == 0) {\n                fprintf(__stderrp, \"Error: cannot open '%s'\\n\", zNewFilename);\n                sqlite3_free(zNewFilename);\n            } else {\n                p->pAuxDb->zFreeOnClose = zNewFilename;\n            }\n        }\n        if (p->db == 0) {\n            p->pAuxDb->zDbFilename = 0;\n            open_db(p, 0);\n        }\n    } else if ((c == 'o' && (cli_strncmp(azArg[0], \"output\", n) == 0 || cli_strncmp(azArg[0], \"once\", n) == 0)) || (c == 'e' && n == 5 && cli_strcmp(azArg[0], \"excel\") == 0)) {\n        char *zFile = 0;\n        int bTxtMode = 0;\n        int i;\n        int eMode = 0;\n        int bOnce = 0;\n        unsigned char zBOM[4];\n        zBOM[0] = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (c == 'e') {\n            eMode = 'x';\n            bOnce = 2;\n        } else if (cli_strncmp(azArg[0], \"once\", n) == 0) {\n            bOnce = 1;\n        }\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-bom\") == 0) {\n                    zBOM[0] = 239;\n                    zBOM[1] = 187;\n                    zBOM[2] = 191;\n                    zBOM[3] = 0;\n                } else if (c != 'e' && cli_strcmp(z, \"-x\") == 0) {\n                    eMode = 'x';\n                } else if (c != 'e' && cli_strcmp(z, \"-e\") == 0) {\n                    eMode = 'e';\n                } else {\n                    fprintf(p->out, \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                    showHelp(p->out, azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zFile == 0 && eMode != 'e' && eMode != 'x') {\n                zFile = sqlite3_mprintf(\"%s\", z);\n                if (zFile && zFile[0] == '|') {\n                    while (i + 1 < nArg)\n                        zFile = sqlite3_mprintf(\"%z %s\", zFile, azArg[++i]);\n                    break;\n                }\n            } else {\n                fprintf(p->out, \"ERROR: extra parameter: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                showHelp(p->out, azArg[0]);\n                rc = 1;\n                sqlite3_free(zFile);\n                goto meta_command_exit;\n            }\n        }\n        if (zFile == 0) {\n            zFile = sqlite3_mprintf(\"stdout\");\n        }\n        if (bOnce) {\n            p->outCount = 2;\n        } else {\n            p->outCount = 0;\n        }\n        output_reset(p);\n        if (eMode == 'e' || eMode == 'x') {\n            p->doXdgOpen = 1;\n            outputModePush(p);\n            if (eMode == 'x') {\n                newTempFile(p, \"csv\");\n                ((p)->shellFlgs &= (~(64)));\n                p->mode = 8;\n                sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n            } else {\n                newTempFile(p, \"txt\");\n                bTxtMode = 1;\n            }\n            sqlite3_free(zFile);\n            zFile = sqlite3_mprintf(\"%s\", p->zTempFile);\n        }\n        shell_check_oom(zFile);\n        if (zFile[0] == '|') {\n            p->out = popen(zFile + 1, \"w\");\n            if (p->out == 0) {\n                fprintf(__stderrp, \"Error: cannot open pipe \\\"%s\\\"\\n\", zFile + 1);\n                p->out = __stdoutp;\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, p->out);\n                sqlite3_snprintf(sizeof (p->outfile), p->outfile, \"%s\", zFile);\n            }\n        } else {\n            p->out = output_file_open(zFile, bTxtMode);\n            if (p->out == 0) {\n                if (cli_strcmp(zFile, \"off\") != 0) {\n                    fprintf(__stderrp, \"Error: cannot write to \\\"%s\\\"\\n\", zFile);\n                }\n                p->out = __stdoutp;\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, p->out);\n                sqlite3_snprintf(sizeof (p->outfile), p->outfile, \"%s\", zFile);\n            }\n        }\n        sqlite3_free(zFile);\n    } else if (c == 'p' && n >= 3 && cli_strncmp(azArg[0], \"parameter\", n) == 0) {\n        open_db(p, 0);\n        if (nArg <= 1)\n            goto parameter_syntax_error;\n        if (nArg == 2 && cli_strcmp(azArg[1], \"clear\") == 0) {\n            sqlite3_exec(p->db, \"DROP TABLE IF EXISTS temp.sqlite_parameters;\", 0, 0, 0);\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"list\") == 0) {\n            sqlite3_stmt *pStmt = 0;\n            int rx;\n            int len = 0;\n            rx = sqlite3_prepare_v2(p->db, \"SELECT max(length(key)) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n            if (rx == 0 && sqlite3_step(pStmt) == 100) {\n                len = sqlite3_column_int(pStmt, 0);\n                if (len > 40)\n                    len = 40;\n            }\n            sqlite3_finalize(pStmt);\n            pStmt = 0;\n            if (len) {\n                rx = sqlite3_prepare_v2(p->db, \"SELECT key, quote(value) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n                while (rx == 0 && sqlite3_step(pStmt) == 100)\n                    {\n                        fprintf(p->out, \"%-*s %s\\n\", len, sqlite3_column_text(pStmt, 0), sqlite3_column_text(pStmt, 1));\n                    }\n                sqlite3_finalize(pStmt);\n            }\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"init\") == 0) {\n            bind_table_init(p);\n        } else if (nArg == 4 && cli_strcmp(azArg[1], \"set\") == 0) {\n            int rx;\n            char *zSql;\n            sqlite3_stmt *pStmt;\n            const char *zKey = azArg[2];\n            const char *zValue = azArg[3];\n            bind_table_init(p);\n            zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\", zKey, zValue);\n            shell_check_oom(zSql);\n            pStmt = 0;\n            rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n            sqlite3_free(zSql);\n            if (rx != 0) {\n                sqlite3_finalize(pStmt);\n                pStmt = 0;\n                zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\", zKey, zValue);\n                shell_check_oom(zSql);\n                rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n                sqlite3_free(zSql);\n                if (rx != 0) {\n                    fprintf(p->out, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n                    sqlite3_finalize(pStmt);\n                    pStmt = 0;\n                    rc = 1;\n                }\n            }\n            sqlite3_step(pStmt);\n            sqlite3_finalize(pStmt);\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"unset\") == 0) {\n            char *zSql = sqlite3_mprintf(\"DELETE FROM temp.sqlite_parameters WHERE key=%Q\", azArg[2]);\n            shell_check_oom(zSql);\n            sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_free(zSql);\n        } else\n          parameter_syntax_error:\n            showHelp(p->out, \"parameter\");\n    } else if (c == 'p' && n >= 3 && cli_strncmp(azArg[0], \"print\", n) == 0) {\n        int i;\n        for (i = 1; i < nArg; i++) {\n            if (i > 1)\n                fprintf(p->out, \" \");\n            fprintf(p->out, \"%s\", azArg[i]);\n        }\n        fprintf(p->out, \"\\n\");\n    } else if (c == 'p' && n >= 3 && cli_strncmp(azArg[0], \"progress\", n) == 0) {\n        int i;\n        int nn = 0;\n        p->flgProgress = 0;\n        p->mxProgress = 0;\n        p->nProgress = 0;\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"quiet\") == 0 || cli_strcmp(z, \"q\") == 0) {\n                    p->flgProgress |= 1;\n                    continue;\n                }\n                if (cli_strcmp(z, \"reset\") == 0) {\n                    p->flgProgress |= 2;\n                    continue;\n                }\n                if (cli_strcmp(z, \"once\") == 0) {\n                    p->flgProgress |= 4;\n                    continue;\n                }\n                if (cli_strcmp(z, \"limit\") == 0) {\n                    if (i + 1 >= nArg) {\n                        fprintf(__stderrp, \"Error: missing argument on --limit\\n\");\n                        rc = 1;\n                        goto meta_command_exit;\n                    } else {\n                        p->mxProgress = (int)integerValue(azArg[++i]);\n                    }\n                    continue;\n                }\n                fprintf(__stderrp, \"Error: unknown option: \\\"%s\\\"\\n\", azArg[i]);\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                nn = (int)integerValue(z);\n            }\n        }\n        open_db(p, 0);\n        sqlite3_progress_handler(p->db, nn, progress_handler, p);\n    } else if (c == 'p' && cli_strncmp(azArg[0], \"prompt\", n) == 0) {\n        if (nArg >= 2) {\n            shell_strncpy(mainPrompt, azArg[1], (int)(int)(sizeof (mainPrompt) / sizeof (mainPrompt[0])) - 1);\n        }\n        if (nArg >= 3) {\n            shell_strncpy(continuePrompt, azArg[2], (int)(int)(sizeof (continuePrompt) / sizeof (continuePrompt[0])) - 1);\n        }\n    } else if (c == 'q' && cli_strncmp(azArg[0], \"quit\", n) == 0) {\n        rc = 2;\n    } else if (c == 'r' && n >= 3 && cli_strncmp(azArg[0], \"read\", n) == 0) {\n        FILE *inSaved = p->in;\n        int savedLineno = p->lineno;\n        failIfSafeMode(p, \"cannot run .read in safe mode\");\n        if (nArg != 2) {\n            fprintf(__stderrp, \"Usage: .read FILE\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        if (azArg[1][0] == '|') {\n            p->in = popen(azArg[1] + 1, \"r\");\n            if (p->in == 0) {\n                fprintf(__stderrp, \"Error: cannot open \\\"%s\\\"\\n\", azArg[1]);\n                rc = 1;\n            } else {\n                rc = process_input(p);\n                pclose(p->in);\n            }\n        } else if ((p->in = openChrSource(azArg[1])) == 0) {\n            fprintf(__stderrp, \"Error: cannot open \\\"%s\\\"\\n\", azArg[1]);\n            rc = 1;\n        } else {\n            rc = process_input(p);\n            fclose(p->in);\n        }\n        p->in = inSaved;\n        p->lineno = savedLineno;\n    } else if (c == 'r' && n >= 3 && cli_strncmp(azArg[0], \"restore\", n) == 0) {\n        const char *zSrcFile;\n        const char *zDb;\n        sqlite3 *pSrc;\n        sqlite3_backup *pBackup;\n        int nTimeout = 0;\n        failIfSafeMode(p, \"cannot run .restore in safe mode\");\n        if (nArg == 2) {\n            zSrcFile = azArg[1];\n            zDb = \"main\";\n        } else if (nArg == 3) {\n            zSrcFile = azArg[2];\n            zDb = azArg[1];\n        } else {\n            fprintf(__stderrp, \"Usage: .restore ?DB? FILE\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        rc = sqlite3_open(zSrcFile, &pSrc);\n        if (rc != 0) {\n            fprintf(__stderrp, \"Error: cannot open \\\"%s\\\"\\n\", zSrcFile);\n            close_db(pSrc);\n            return 1;\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(p->db, zDb, pSrc, \"main\");\n        if (pBackup == 0) {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n            close_db(pSrc);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0 || rc == 5)\n            {\n                if (rc == 5) {\n                    if (nTimeout++ >= 3)\n                        break;\n                    sqlite3_sleep(100);\n                }\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else if (rc == 5 || rc == 6) {\n            fprintf(__stderrp, \"Error: source database is busy\\n\");\n            rc = 1;\n        } else {\n            fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n            rc = 1;\n        }\n        close_db(pSrc);\n    } else if (c == 's' && cli_strncmp(azArg[0], \"scanstats\", n) == 0) {\n        if (nArg == 2) {\n            if (cli_strcmp(azArg[1], \"est\") == 0) {\n                p->scanstatsOn = 2;\n            } else {\n                p->scanstatsOn = (u8)booleanValue(azArg[1]);\n            }\n            fprintf(__stderrp, \"Warning: .scanstats not available in this build.\\n\");\n        } else {\n            fprintf(__stderrp, \"Usage: .scanstats on|off|est\\n\");\n            rc = 1;\n        }\n    } else if (c == 's' && cli_strncmp(azArg[0], \"schema\", n) == 0) {\n        ShellText sSelect;\n        ShellState data;\n        char *zErrMsg = 0;\n        const char *zDiv = \"(\";\n        const char *zName = 0;\n        int iSchema = 0;\n        int bDebug = 0;\n        int bNoSystemTabs = 0;\n        int ii;\n        open_db(p, 0);\n        __builtin___memcpy_chk(&data, p, sizeof (data), __builtin_object_size(&data, 0));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        initText(&sSelect);\n        for (ii = 1; ii < nArg; ii++) {\n            if (optionMatch(azArg[ii], \"indent\")) {\n                data.cMode = data.mode = 11;\n            } else if (optionMatch(azArg[ii], \"debug\")) {\n                bDebug = 1;\n            } else if (optionMatch(azArg[ii], \"nosys\")) {\n                bNoSystemTabs = 1;\n            } else if (azArg[ii][0] == '-') {\n                fprintf(__stderrp, \"Unknown option: \\\"%s\\\"\\n\", azArg[ii]);\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zName == 0) {\n                zName = azArg[ii];\n            } else {\n                fprintf(__stderrp, \"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\\n\");\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zName != 0) {\n            int isSchema = sqlite3_strlike(zName, \"sqlite_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_schema\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_schema\", '\\\\') == 0;\n            if (isSchema) {\n                char *new_argv[2], *new_colv[2];\n                new_argv[0] = sqlite3_mprintf(\"CREATE TABLE %s (\\n  type text,\\n  name text,\\n  tbl_name text,\\n  rootpage integer,\\n  sql text\\n)\", zName);\n                shell_check_oom(new_argv[0]);\n                new_argv[1] = 0;\n                new_colv[0] = \"sql\";\n                new_colv[1] = 0;\n                callback(&data, 1, new_argv, new_colv);\n                sqlite3_free(new_argv[0]);\n            }\n        }\n        if (zDiv) {\n            sqlite3_stmt *pStmt = 0;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT name FROM pragma_database_list\", -1, &pStmt, 0);\n            if (rc) {\n                fprintf(__stderrp, \"Error: %s\\n\", sqlite3_errmsg(p->db));\n                sqlite3_finalize(pStmt);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            appendText(&sSelect, \"SELECT sql FROM\", 0);\n            iSchema = 0;\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zDb = (const char *)sqlite3_column_text(pStmt, 0);\n                    char zScNum[30];\n                    sqlite3_snprintf(sizeof (zScNum), zScNum, \"%d\", ++iSchema);\n                    appendText(&sSelect, zDiv, 0);\n                    zDiv = \" UNION ALL \";\n                    appendText(&sSelect, \"SELECT shell_add_schema(sql,\", 0);\n                    if (sqlite3_stricmp(zDb, \"main\") != 0) {\n                        appendText(&sSelect, zDb, '\\'');\n                    } else {\n                        appendText(&sSelect, \"NULL\", 0);\n                    }\n                    appendText(&sSelect, \",name) AS sql, type, tbl_name, name, rowid,\", 0);\n                    appendText(&sSelect, zScNum, 0);\n                    appendText(&sSelect, \" AS snum, \", 0);\n                    appendText(&sSelect, zDb, '\\'');\n                    appendText(&sSelect, \" AS sname FROM \", 0);\n                    appendText(&sSelect, zDb, quoteChar(zDb));\n                    appendText(&sSelect, \".sqlite_schema\", 0);\n                }\n            sqlite3_finalize(pStmt);\n            if (zName) {\n                appendText(&sSelect, \" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\", 0);\n            }\n            appendText(&sSelect, \") WHERE \", 0);\n            if (zName) {\n                char *zQarg = sqlite3_mprintf(\"%Q\", zName);\n                int bGlob;\n                shell_check_oom(zQarg);\n                bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;\n                if (strchr(zName, '.')) {\n                    appendText(&sSelect, \"lower(printf('%s.%s',sname,tbl_name))\", 0);\n                } else {\n                    appendText(&sSelect, \"lower(tbl_name)\", 0);\n                }\n                appendText(&sSelect, bGlob ? \" GLOB \" : \" LIKE \", 0);\n                appendText(&sSelect, zQarg, 0);\n                if (!bGlob) {\n                    appendText(&sSelect, \" ESCAPE '\\\\' \", 0);\n                }\n                appendText(&sSelect, \" AND \", 0);\n                sqlite3_free(zQarg);\n            }\n            if (bNoSystemTabs) {\n                appendText(&sSelect, \"name NOT LIKE 'sqlite_%%' AND \", 0);\n            }\n            appendText(&sSelect, \"sql IS NOT NULL ORDER BY snum, rowid\", 0);\n            if (bDebug) {\n                fprintf(p->out, \"SQL: %s;\\n\", sSelect.z);\n            } else {\n                rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);\n            }\n            freeText(&sSelect);\n        }\n        if (zErrMsg) {\n            fprintf(__stderrp, \"Error: %s\\n\", zErrMsg);\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        } else if (rc != 0) {\n            fprintf(__stderrp, \"Error: querying schema information\\n\");\n            rc = 1;\n        } else {\n            rc = 0;\n        }\n    } else if ((c == 's' && n == 11 && cli_strncmp(azArg[0], \"selecttrace\", n) == 0) || (c == 't' && n == 9 && cli_strncmp(azArg[0], \"treetrace\", n) == 0)) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 1, &x);\n    } else if (c == 's' && n >= 4 && cli_strncmp(azArg[0], \"selftest\", n) == 0) {\n        int bIsInit = 0;\n        int bVerbose = 0;\n        int bSelftestExists;\n        int i, k;\n        int nTest = 0;\n        int nErr = 0;\n        ShellText str;\n        sqlite3_stmt *pStmt = 0;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (cli_strcmp(z, \"-init\") == 0) {\n                bIsInit = 1;\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                bVerbose++;\n            } else {\n                fprintf(__stderrp, \"Unknown option \\\"%s\\\" on \\\"%s\\\"\\n\", azArg[i], azArg[0]);\n                fprintf(__stderrp, \"Should be one of: --init -v\\n\");\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (sqlite3_table_column_metadata(p->db, \"main\", \"selftest\", 0, 0, 0, 0, 0, 0) != 0) {\n            bSelftestExists = 0;\n        } else {\n            bSelftestExists = 1;\n        }\n        if (bIsInit) {\n            createSelftestTable(p);\n            bSelftestExists = 1;\n        }\n        initText(&str);\n        appendText(&str, \"x\", 0);\n        for (k = bSelftestExists; k >= 0; k--) {\n            if (k == 1) {\n                rc = sqlite3_prepare_v2(p->db, \"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\", -1, &pStmt, 0);\n            } else {\n                rc = sqlite3_prepare_v2(p->db, \"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\", -1, &pStmt, 0);\n            }\n            if (rc) {\n                fprintf(__stderrp, \"Error querying the selftest table\\n\");\n                rc = 1;\n                sqlite3_finalize(pStmt);\n                goto meta_command_exit;\n            }\n            for (i = 1; sqlite3_step(pStmt) == 100; i++) {\n                int tno = sqlite3_column_int(pStmt, 0);\n                const char *zOp = (const char *)sqlite3_column_text(pStmt, 1);\n                const char *zSql = (const char *)sqlite3_column_text(pStmt, 2);\n                const char *zAns = (const char *)sqlite3_column_text(pStmt, 3);\n                if (zOp == 0)\n                    continue;\n                if (zSql == 0)\n                    continue;\n                if (zAns == 0)\n                    continue;\n                k = 0;\n                if (bVerbose > 0) {\n                    printf(\"%d: %s %s\\n\", tno, zOp, zSql);\n                }\n                if (cli_strcmp(zOp, \"memo\") == 0) {\n                    fprintf(p->out, \"%s\\n\", zSql);\n                } else if (cli_strcmp(zOp, \"run\") == 0) {\n                    char *zErrMsg = 0;\n                    str.n = 0;\n                    str.z[0] = 0;\n                    rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);\n                    nTest++;\n                    if (bVerbose) {\n                        fprintf(p->out, \"Result: %s\\n\", str.z);\n                    }\n                    if (rc || zErrMsg) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(p->out, \"%d: error-code-%d: %s\\n\", tno, rc, zErrMsg);\n                        sqlite3_free(zErrMsg);\n                    } else if (cli_strcmp(zAns, str.z) != 0) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(p->out, \"%d: Expected: [%s]\\n\", tno, zAns);\n                        fprintf(p->out, \"%d:      Got: [%s]\\n\", tno, str.z);\n                    }\n                } else {\n                    fprintf(__stderrp, \"Unknown operation \\\"%s\\\" on selftest line %d\\n\", zOp, tno);\n                    rc = 1;\n                    break;\n                }\n            }\n            sqlite3_finalize(pStmt);\n        }\n        freeText(&str);\n        fprintf(p->out, \"%d errors out of %d tests\\n\", nErr, nTest);\n    } else if (c == 's' && cli_strncmp(azArg[0], \"separator\", n) == 0) {\n        if (nArg < 2 || nArg > 3) {\n            fprintf(__stderrp, \"Usage: .separator COL ?ROW?\\n\");\n            rc = 1;\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"%.*s\", (int)(int)(sizeof (p->colSeparator) / sizeof (p->colSeparator[0])) - 1, azArg[1]);\n        }\n        if (nArg >= 3) {\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"%.*s\", (int)(int)(sizeof (p->rowSeparator) / sizeof (p->rowSeparator[0])) - 1, azArg[2]);\n        }\n    } else if (c == 's' && n >= 4 && cli_strncmp(azArg[0], \"sha3sum\", n) == 0) {\n        const char *zLike = 0;\n        int i;\n        int bSchema = 0;\n        int bSeparate = 0;\n        int iSize = 224;\n        int bDebug = 0;\n        sqlite3_stmt *pStmt;\n        char *zSql;\n        char *zSep;\n        ShellText sSql;\n        ShellText sQuery;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"schema\") == 0) {\n                    bSchema = 1;\n                } else if (cli_strcmp(z, \"sha3-224\") == 0 || cli_strcmp(z, \"sha3-256\") == 0 || cli_strcmp(z, \"sha3-384\") == 0 || cli_strcmp(z, \"sha3-512\") == 0) {\n                    iSize = atoi(&z[5]);\n                } else if (cli_strcmp(z, \"debug\") == 0) {\n                    bDebug = 1;\n                } else {\n                    fprintf(__stderrp, \"Unknown option \\\"%s\\\" on \\\"%s\\\"\\n\", azArg[i], azArg[0]);\n                    showHelp(p->out, azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zLike) {\n                fprintf(__stderrp, \"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\\n\");\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zLike = z;\n                bSeparate = 1;\n                if (sqlite3_strlike(\"sqlite\\\\_%\", zLike, '\\\\') == 0)\n                    bSchema = 1;\n            }\n        }\n        if (bSchema) {\n            zSql = \"SELECT lower(name) as tname FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\";\n        } else {\n            zSql = \"SELECT lower(name) as tname FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\";\n        }\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        initText(&sQuery);\n        initText(&sSql);\n        appendText(&sSql, \"WITH [sha3sum$query](a,b) AS(\", 0);\n        zSep = \"VALUES(\";\n        while (100 == sqlite3_step(pStmt))\n            {\n                const char *zTab = (const char *)sqlite3_column_text(pStmt, 0);\n                if (zTab == 0)\n                    continue;\n                if (zLike && sqlite3_strlike(zLike, zTab, 0) != 0)\n                    continue;\n                if (cli_strncmp(zTab, \"sqlite_\", 7) != 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, '\"');\n                    appendText(&sQuery, \" NOT INDEXED;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_schema\") == 0) {\n                    appendText(&sQuery, \"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_sequence\") == 0) {\n                    appendText(&sQuery, \"SELECT name,seq FROM sqlite_sequence ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat1\") == 0) {\n                    appendText(&sQuery, \"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat4\") == 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, 0);\n                    appendText(&sQuery, \" ORDER BY tbl, idx, rowid;\\n\", 0);\n                }\n                appendText(&sSql, zSep, 0);\n                appendText(&sSql, sQuery.z, '\\'');\n                sQuery.n = 0;\n                appendText(&sSql, \",\", 0);\n                appendText(&sSql, zTab, '\\'');\n                zSep = \"),(\";\n            }\n        sqlite3_finalize(pStmt);\n        if (bSeparate) {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\", sSql.z, iSize);\n        } else {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\", sSql.z, iSize);\n        }\n        shell_check_oom(zSql);\n        freeText(&sQuery);\n        freeText(&sSql);\n        if (bDebug) {\n            fprintf(p->out, \"%s\\n\", zSql);\n        } else {\n            shell_exec(p, zSql, 0);\n        }\n        {\n            int lrc;\n            char *zRevText = \"SELECT lower(name) as tname FROM sqlite_schema\\nWHERE type='table' AND coalesce(rootpage,0)>1\\nAND name NOT LIKE 'sqlite_%%'%s\\nORDER BY 1 collate nocase\";\n            zRevText = sqlite3_mprintf(zRevText, zLike ? \" AND name LIKE $tspec\" : \"\");\n            zRevText = sqlite3_mprintf(\"with tabcols as materialized(\\nselect tname, cname\\nfrom ( select ss.tname as tname, ti.name as cname\\n from (%z) ss\\n inner join pragma_table_info(tname) ti))\\nselect 'SELECT total(bad_text_count) AS bad_text_count\\nFROM ('||group_concat(query, ' UNION ALL ')||')' as btc_query\\n from (select 'SELECT COUNT(*) AS bad_text_count\\nFROM '||tname||' WHERE '\\n||group_concat('CAST(CAST('||cname||' AS BLOB) AS TEXT)<>'||cname\\n|| ' AND typeof('||cname||')=''text'' ',\\n' OR ') as query, tname from tabcols group by tname)\", zRevText);\n            shell_check_oom(zRevText);\n            if (bDebug)\n                fprintf(p->out, \"%s\\n\", zRevText);\n            lrc = sqlite3_prepare_v2(p->db, zRevText, -1, &pStmt, 0);\n            ((void)0);\n            if (zLike)\n                sqlite3_bind_text(pStmt, 1, zLike, -1, ((sqlite3_destructor_type)0));\n            lrc = 100 == sqlite3_step(pStmt);\n            if (lrc) {\n                const char *zGenQuery = (char *)sqlite3_column_text(pStmt, 0);\n                sqlite3_stmt *pCheckStmt;\n                lrc = sqlite3_prepare_v2(p->db, zGenQuery, -1, &pCheckStmt, 0);\n                if (bDebug)\n                    fprintf(p->out, \"%s\\n\", zGenQuery);\n                if (0 == lrc) {\n                    if (100 == sqlite3_step(pCheckStmt)) {\n                        double countIrreversible = sqlite3_column_double(pCheckStmt, 0);\n                        if (countIrreversible > 0) {\n                            int sz = (int)(countIrreversible + 0.5);\n                            fprintf(__stderrp, \"Digest includes %d invalidly encoded text field%s.\\n\", sz, (sz > 1) ? \"s\" : \"\");\n                        }\n                    }\n                    sqlite3_finalize(pCheckStmt);\n                }\n                sqlite3_finalize(pStmt);\n            }\n            sqlite3_free(zRevText);\n        }\n        sqlite3_free(zSql);\n    } else if (c == 's' && (cli_strncmp(azArg[0], \"shell\", n) == 0 || cli_strncmp(azArg[0], \"system\", n) == 0)) {\n        char *zCmd;\n        int i, x;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (nArg < 2) {\n            fprintf(__stderrp, \"Usage: .system COMMAND\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zCmd = sqlite3_mprintf(strchr(azArg[1], ' ') == 0 ? \"%s\" : \"\\\"%s\\\"\", azArg[1]);\n        for (i = 2; i < nArg && zCmd != 0; i++) {\n            zCmd = sqlite3_mprintf(strchr(azArg[i], ' ') == 0 ? \"%z %s\" : \"%z \\\"%s\\\"\", zCmd, azArg[i]);\n        }\n        x = zCmd != 0 ? system(zCmd) : 1;\n        sqlite3_free(zCmd);\n        if (x)\n            fprintf(__stderrp, \"System command returns %d\\n\", x);\n    } else if (c == 's' && cli_strncmp(azArg[0], \"show\", n) == 0) {\n        static const char *azBool[] = {\"off\", \"on\", \"trigger\", \"full\"};\n        const char *zOut;\n        int i;\n        if (nArg != 1) {\n            fprintf(__stderrp, \"Usage: .show\\n\");\n            rc = 1;\n            goto meta_command_exit;\n        }\n        fprintf(p->out, \"%12.12s: %s\\n\", \"echo\", azBool[(((p)->shellFlgs & (64)) != 0)]);\n        fprintf(p->out, \"%12.12s: %s\\n\", \"eqp\", azBool[p->autoEQP & 3]);\n        fprintf(p->out, \"%12.12s: %s\\n\", \"explain\", p->mode == 9 ? \"on\" : p->autoExplain ? \"auto\" : \"off\");\n        fprintf(p->out, \"%12.12s: %s\\n\", \"headers\", azBool[p->showHeader != 0]);\n        if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n            fprintf(p->out, \"%12.12s: %s --wrap %d --wordwrap %s --%squote\\n\", \"mode\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n        } else {\n            fprintf(p->out, \"%12.12s: %s\\n\", \"mode\", modeDescr[p->mode]);\n        }\n        fprintf(p->out, \"%12.12s: \", \"nullvalue\");\n        output_c_string(p->out, p->nullValue);\n        fprintf(p->out, \"\\n\");\n        fprintf(p->out, \"%12.12s: %s\\n\", \"output\", strlen30(p->outfile) ? p->outfile : \"stdout\");\n        fprintf(p->out, \"%12.12s: \", \"colseparator\");\n        output_c_string(p->out, p->colSeparator);\n        fprintf(p->out, \"\\n\");\n        fprintf(p->out, \"%12.12s: \", \"rowseparator\");\n        output_c_string(p->out, p->rowSeparator);\n        fprintf(p->out, \"\\n\");\n        switch (p->statsOn) {\n          case 0:\n            zOut = \"off\";\n            break;\n          default:\n            zOut = \"on\";\n            break;\n          case 2:\n            zOut = \"stmt\";\n            break;\n          case 3:\n            zOut = \"vmstep\";\n            break;\n        }\n        fprintf(p->out, \"%12.12s: %s\\n\", \"stats\", zOut);\n        fprintf(p->out, \"%12.12s: \", \"width\");\n        for (i = 0; i < p->nWidth; i++) {\n            fprintf(p->out, \"%d \", p->colWidth[i]);\n        }\n        fprintf(p->out, \"\\n\");\n        fprintf(p->out, \"%12.12s: %s\\n\", \"filename\", p->pAuxDb->zDbFilename ? p->pAuxDb->zDbFilename : \"\");\n    } else if (c == 's' && cli_strncmp(azArg[0], \"stats\", n) == 0) {\n        if (nArg == 2) {\n            if (cli_strcmp(azArg[1], \"stmt\") == 0) {\n                p->statsOn = 2;\n            } else if (cli_strcmp(azArg[1], \"vmstep\") == 0) {\n                p->statsOn = 3;\n            } else {\n                p->statsOn = (u8)booleanValue(azArg[1]);\n            }\n        } else if (nArg == 1) {\n            display_stats(p->db, p, 0);\n        } else {\n            fprintf(__stderrp, \"Usage: .stats ?on|off|stmt|vmstep?\\n\");\n            rc = 1;\n        }\n    } else if ((c == 't' && n > 1 && cli_strncmp(azArg[0], \"tables\", n) == 0) || (c == 'i' && (cli_strncmp(azArg[0], \"indices\", n) == 0 || cli_strncmp(azArg[0], \"indexes\", n) == 0))) {\n        sqlite3_stmt *pStmt;\n        char **azResult;\n        int nRow, nAlloc;\n        int ii;\n        ShellText s;\n        initText(&s);\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            sqlite3_finalize(pStmt);\n            return shellDatabaseError(p->db);\n        }\n        if (nArg > 2 && c == 'i') {\n            fprintf(__stderrp, \"Usage: .indexes ?LIKE-PATTERN?\\n\");\n            rc = 1;\n            sqlite3_finalize(pStmt);\n            goto meta_command_exit;\n        }\n        for (ii = 0; sqlite3_step(pStmt) == 100; ii++) {\n            const char *zDbName = (const char *)sqlite3_column_text(pStmt, 1);\n            if (zDbName == 0)\n                continue;\n            if (s.z && s.z[0])\n                appendText(&s, \" UNION ALL \", 0);\n            if (sqlite3_stricmp(zDbName, \"main\") == 0) {\n                appendText(&s, \"SELECT name FROM \", 0);\n            } else {\n                appendText(&s, \"SELECT \", 0);\n                appendText(&s, zDbName, '\\'');\n                appendText(&s, \"||'.'||name FROM \", 0);\n            }\n            appendText(&s, zDbName, '\"');\n            appendText(&s, \".sqlite_schema \", 0);\n            if (c == 't') {\n                appendText(&s, \" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\", 0);\n            } else {\n                appendText(&s, \" WHERE type='index'   AND tbl_name LIKE ?1\", 0);\n            }\n        }\n        rc = sqlite3_finalize(pStmt);\n        if (rc == 0) {\n            appendText(&s, \" ORDER BY 1\", 0);\n            rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);\n        }\n        freeText(&s);\n        if (rc)\n            return shellDatabaseError(p->db);\n        nRow = nAlloc = 0;\n        azResult = 0;\n        if (nArg > 1) {\n            sqlite3_bind_text(pStmt, 1, azArg[1], -1, ((sqlite3_destructor_type)-1));\n        } else {\n            sqlite3_bind_text(pStmt, 1, \"%\", -1, ((sqlite3_destructor_type)0));\n        }\n        while (sqlite3_step(pStmt) == 100)\n            {\n                if (nRow >= nAlloc) {\n                    char **azNew;\n                    int n2 = nAlloc * 2 + 10;\n                    azNew = sqlite3_realloc64(azResult, sizeof (azResult[0]) * n2);\n                    shell_check_oom(azNew);\n                    nAlloc = n2;\n                    azResult = azNew;\n                }\n                azResult[nRow] = sqlite3_mprintf(\"%s\", sqlite3_column_text(pStmt, 0));\n                shell_check_oom(azResult[nRow]);\n                nRow++;\n            }\n        if (sqlite3_finalize(pStmt) != 0) {\n            rc = shellDatabaseError(p->db);\n        }\n        if (rc == 0 && nRow > 0) {\n            int len, maxlen = 0;\n            int i, j;\n            int nPrintCol, nPrintRow;\n            for (i = 0; i < nRow; i++) {\n                len = strlen30(azResult[i]);\n                if (len > maxlen)\n                    maxlen = len;\n            }\n            nPrintCol = 80 / (maxlen + 2);\n            if (nPrintCol < 1)\n                nPrintCol = 1;\n            nPrintRow = (nRow + nPrintCol - 1) / nPrintCol;\n            for (i = 0; i < nPrintRow; i++) {\n                for (j = i; j < nRow; j += nPrintRow) {\n                    char *zSp = j < nPrintRow ? \"\" : \"  \";\n                    fprintf(p->out, \"%s%-*s\", zSp, maxlen, azResult[j] ? azResult[j] : \"\");\n                }\n                fprintf(p->out, \"\\n\");\n            }\n        }\n        for (ii = 0; ii < nRow; ii++)\n            sqlite3_free(azResult[ii]);\n        sqlite3_free(azResult);\n    } else if (c == 't' && cli_strcmp(azArg[0], \"testcase\") == 0) {\n        output_reset(p);\n        p->out = output_file_open(\"testcase-out.txt\", 0);\n        if (p->out == 0) {\n            fprintf(__stderrp, \"Error: cannot open 'testcase-out.txt'\\n\");\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"%s\", azArg[1]);\n        } else {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"?\");\n        }\n    } else if (c == 't' && n >= 8 && cli_strncmp(azArg[0], \"testctrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            int unSafe;\n            const char *zUsage;\n        } aCtrl[] = {{\"always\", 13, 1, \"BOOLEAN\"}, {\"assert\", 12, 1, \"BOOLEAN\"}, {\"byteorder\", 22, 0, \"\"}, {\"extra_schema_checks\", 29, 0, \"BOOLEAN\"}, {\"imposter\", 25, 1, \"SCHEMA ON/OFF ROOTPAGE\"}, {\"internal_functions\", 17, 0, \"\"}, {\"localtime_fault\", 18, 0, \"BOOLEAN\"}, {\"never_corrupt\", 20, 1, \"BOOLEAN\"}, {\"optimizations\", 15, 0, \"DISABLE-MASK\"}, {\"pending_byte\", 11, 0, \"OFFSET  \"}, {\"prng_restore\", 6, 0, \"\"}, {\"prng_save\", 5, 0, \"\"}, {\"prng_seed\", 28, 0, \"SEED ?db?\"}, {\"seek_count\", 30, 0, \"\"}, {\"sorter_mmap\", 24, 0, \"NMAX\"}, {\"tune\", 32, 1, \"ID VALUE\"}};\n        int testctrl = -1;\n        int iCtrl = -1;\n        int rc2 = 0;\n        int isOk = 0;\n        int i, n2;\n        const char *zCmd = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(p->out, \"Available test-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(p->out, \"  .testctrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (cli_strncmp(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (testctrl < 0) {\n                    testctrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    fprintf(__stderrp, \"Error: ambiguous test-control: \\\"%s\\\"\\nUse \\\".testctrl --help\\\" for help\\n\", zCmd);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (testctrl < 0) {\n            fprintf(__stderrp, \"Error: unknown test-control: %s\\nUse \\\".testctrl --help\\\" for help\\n\", zCmd);\n        } else if (aCtrl[iCtrl].unSafe && p->bSafeMode) {\n            fprintf(__stderrp, \"line %d: \\\".testctrl %s\\\" may not be used in safe mode\\n\", p->lineno, aCtrl[iCtrl].zCtrlName);\n            exit(1);\n        } else {\n            switch (testctrl) {\n              case 15:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)strtol(azArg[2], 0, 0);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n              case 5:\n              case 6:\n              case 22:\n                if (nArg == 2) {\n                    rc2 = sqlite3_test_control(testctrl);\n                    isOk = testctrl == 22 ? 1 : 3;\n                }\n                break;\n              case 11:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 28:\n                if (nArg == 3 || nArg == 4) {\n                    int ii = (int)integerValue(azArg[2]);\n                    sqlite3 *db;\n                    if (ii == 0 && cli_strcmp(azArg[2], \"random\") == 0) {\n                        sqlite3_randomness(sizeof (ii), &ii);\n                        printf(\"-- random seed: %d\\n\", ii);\n                    }\n                    if (nArg == 3) {\n                        db = 0;\n                    } else {\n                        db = p->db;\n                        sqlite3_table_column_metadata(db, 0, \"x\", 0, 0, 0, 0, 0, 0);\n                    }\n                    rc2 = sqlite3_test_control(testctrl, ii, db);\n                    isOk = 3;\n                }\n                break;\n              case 12:\n              case 13:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 1;\n                }\n                break;\n              case 18:\n              case 20:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 17:\n                rc2 = sqlite3_test_control(testctrl, p->db);\n                isOk = 3;\n                break;\n              case 25:\n                if (nArg == 5) {\n                    rc2 = sqlite3_test_control(testctrl, p->db, azArg[2], integerValue(azArg[3]), integerValue(azArg[4]));\n                    isOk = 3;\n                }\n                break;\n              case 30:\n                {\n                    u64 x = 0;\n                    rc2 = sqlite3_test_control(testctrl, p->db, &x);\n                    fprintf(p->out, \"%llu\\n\", x);\n                    isOk = 3;\n                    break;\n                }\n              case 24:\n                if (nArg == 3) {\n                    int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(p->out, \"Usage: .testctrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            fprintf(p->out, \"%d\\n\", rc2);\n        } else if (isOk == 2) {\n            fprintf(p->out, \"0x%08x\\n\", rc2);\n        }\n    } else if (c == 't' && n > 4 && cli_strncmp(azArg[0], \"timeout\", n) == 0) {\n        open_db(p, 0);\n        sqlite3_busy_timeout(p->db, nArg >= 2 ? (int)integerValue(azArg[1]) : 0);\n    } else if (c == 't' && n >= 5 && cli_strncmp(azArg[0], \"timer\", n) == 0) {\n        if (nArg == 2) {\n            enableTimer = booleanValue(azArg[1]);\n            if (enableTimer && !1) {\n                fprintf(__stderrp, \"Error: timer not available on this system.\\n\");\n                enableTimer = 0;\n            }\n        } else {\n            fprintf(__stderrp, \"Usage: .timer on|off\\n\");\n            rc = 1;\n        }\n    } else if (c == 't' && cli_strncmp(azArg[0], \"trace\", n) == 0) {\n        int mType = 0;\n        int jj;\n        open_db(p, 0);\n        for (jj = 1; jj < nArg; jj++) {\n            const char *z = azArg[jj];\n            if (z[0] == '-') {\n                if (optionMatch(z, \"expanded\")) {\n                    p->eTraceType = 1;\n                } else if (optionMatch(z, \"plain\")) {\n                    p->eTraceType = 0;\n                } else if (optionMatch(z, \"profile\")) {\n                    mType |= 2;\n                } else if (optionMatch(z, \"row\")) {\n                    mType |= 4;\n                } else if (optionMatch(z, \"stmt\")) {\n                    mType |= 1;\n                } else if (optionMatch(z, \"close\")) {\n                    mType |= 8;\n                } else {\n                    fprintf(__stderrp, \"Unknown option \\\"%s\\\" on \\\".trace\\\"\\n\", z);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else {\n                output_file_close(p->traceOut);\n                p->traceOut = output_file_open(z, 0);\n            }\n        }\n        if (p->traceOut == 0) {\n            sqlite3_trace_v2(p->db, 0, 0, 0);\n        } else {\n            if (mType == 0)\n                mType = 1;\n            sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);\n        }\n    } else if (c == 'v' && cli_strncmp(azArg[0], \"version\", n) == 0) {\n        fprintf(p->out, \"SQLite %s %s\\n\", sqlite3_libversion(), sqlite3_sourceid());\n        fprintf(p->out, \"zlib version %s\\n\", zlibVersion());\n        fprintf(p->out, \"clang-16.0.0\\n\");\n    } else if (c == 'v' && cli_strncmp(azArg[0], \"vfsinfo\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        sqlite3_vfs *pVfs = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 27, &pVfs);\n            if (pVfs) {\n                fprintf(p->out, \"vfs.zName      = \\\"%s\\\"\\n\", pVfs->zName);\n                fprintf(p->out, \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n                fprintf(p->out, \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n                fprintf(p->out, \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            }\n        }\n    } else if (c == 'v' && cli_strncmp(azArg[0], \"vfslist\", n) == 0) {\n        sqlite3_vfs *pVfs;\n        sqlite3_vfs *pCurrent = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, \"main\", 27, &pCurrent);\n        }\n        for (pVfs = sqlite3_vfs_find(0); pVfs; pVfs = pVfs->pNext) {\n            fprintf(p->out, \"vfs.zName      = \\\"%s\\\"%s\\n\", pVfs->zName, pVfs == pCurrent ? \"  <--- CURRENT\" : \"\");\n            fprintf(p->out, \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n            fprintf(p->out, \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n            fprintf(p->out, \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            if (pVfs->pNext) {\n                fprintf(p->out, \"-----------------------------------\\n\");\n            }\n        }\n    } else if (c == 'v' && cli_strncmp(azArg[0], \"vfsname\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        char *zVfsName = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 12, &zVfsName);\n            if (zVfsName) {\n                fprintf(p->out, \"%s\\n\", zVfsName);\n                sqlite3_free(zVfsName);\n            }\n        }\n    } else if (c == 'w' && cli_strncmp(azArg[0], \"wheretrace\", n) == 0) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 3, &x);\n    } else if (c == 'w' && cli_strncmp(azArg[0], \"width\", n) == 0) {\n        int j;\n        ((void)0);\n        p->nWidth = nArg - 1;\n        p->colWidth = realloc(p->colWidth, (p->nWidth + 1) * sizeof(int) * 2);\n        if (p->colWidth == 0 && p->nWidth > 0)\n            shell_out_of_memory();\n        if (p->nWidth)\n            p->actualWidth = &p->colWidth[p->nWidth];\n        for (j = 1; j < nArg; j++) {\n            p->colWidth[j - 1] = (int)integerValue(azArg[j]);\n        }\n    } else {\n        fprintf(__stderrp, \"Error: unknown command or invalid arguments:  \\\"%s\\\". Enter \\\".help\\\" for help\\n\", azArg[0]);\n        rc = 1;\n    }\n  meta_command_exit:\n    if (p->outCount) {\n        p->outCount--;\n        if (p->outCount == 0)\n            output_reset(p);\n    }\n    p->bSafeMode = p->bSafeModePersist;\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#22444:1#arCreateOrUpdateCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const char *zCreate = \"CREATE TABLE IF NOT EXISTS sqlar(\\n  name TEXT PRIMARY KEY,  -- name of the file\\n  mode INT,               -- access permissions\\n  mtime INT,              -- last modification time\\n  sz INT,                 -- original file size\\n  data BLOB               -- compressed content\\n)\";\n    const char *zDrop = \"DROP TABLE IF EXISTS sqlar\";\n    const char *zInsertFmt[2] = {\"REPLACE INTO %s(name,mode,mtime,sz,data)\\n  SELECT\\n    %s,\\n    mode,\\n    mtime,\\n    CASE substr(lsmode(mode),1,1)\\n      WHEN '-' THEN length(data)\\n      WHEN 'd' THEN 0\\n      ELSE -1 END,\\n    sqlar_compress(data)\\n  FROM fsdir(%Q,%Q) AS disk\\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\", \"REPLACE INTO %s(name,mode,mtime,data)\\n  SELECT\\n    %s,\\n    mode,\\n    mtime,\\n    data\\n  FROM fsdir(%Q,%Q) AS disk\\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\"};\n    int i;\n    int rc;\n    const char *zTab = 0;\n    char *zSql;\n    char zTemp[50];\n    char *zExists = 0;\n    arExecSql(pAr, \"PRAGMA page_size=512\");\n    rc = arExecSql(pAr, \"SAVEPOINT ar;\");\n    if (rc != 0)\n        return rc;\n    zTemp[0] = 0;\n    if (pAr->bZip) {\n        if (pAr->zFile) {\n            sqlite3_uint64 r;\n            sqlite3_randomness(sizeof (r), &r);\n            sqlite3_snprintf(sizeof (zTemp), zTemp, \"zip%016llx\", r);\n            zTab = zTemp;\n            zSql = sqlite3_mprintf(\"CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)\", zTab, pAr->zFile);\n            rc = arExecSql(pAr, zSql);\n            sqlite3_free(zSql);\n        } else {\n            zTab = \"zip\";\n        }\n    } else {\n        zTab = \"sqlar\";\n        if (bUpdate == 0) {\n            rc = arExecSql(pAr, zDrop);\n            if (rc != 0)\n                goto end_ar_transaction;\n        }\n        rc = arExecSql(pAr, zCreate);\n    }\n    if (bOnlyIfChanged) {\n        zExists = sqlite3_mprintf(\" AND NOT EXISTS(SELECT 1 FROM %s AS mem WHERE mem.name=disk.name AND mem.mtime=disk.mtime AND mem.mode=disk.mode)\", zTab);\n    } else {\n        zExists = sqlite3_mprintf(\"\");\n    }\n    if (zExists == 0)\n        rc = 7;\n    for (i = 0; i < pAr->nArg && rc == 0; i++) {\n        char *zSql2 = sqlite3_mprintf(zInsertFmt[pAr->bZip], zTab, pAr->bVerbose ? \"shell_putsnl(name)\" : \"name\", pAr->azArg[i], pAr->zDir, zExists);\n        rc = arExecSql(pAr, zSql2);\n        sqlite3_free(zSql2);\n    }\n  end_ar_transaction:\n    if (rc != 0) {\n        sqlite3_exec(pAr->db, \"ROLLBACK TO ar; RELEASE ar;\", 0, 0, 0);\n    } else {\n        rc = arExecSql(pAr, \"RELEASE ar;\");\n        if (pAr->bZip && pAr->zFile) {\n            zSql = sqlite3_mprintf(\"DROP TABLE %s\", zTemp);\n            arExecSql(pAr, zSql);\n            sqlite3_free(zSql);\n        }\n    }\n    sqlite3_free(zExists);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#21803:1#lintDotCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int n;\n    n = (nArg >= 2 ? strlen30(azArg[1]) : 0);\n    if (n < 1 || sqlite3_strnicmp(azArg[1], \"fkey-indexes\", n))\n        goto usage;\n    return lintFkeyIndexes(pState, azArg, nArg);\n  usage:\n    fprintf(__stderrp, \"Usage %s sub-command ?switches...?\\n\", azArg[0]);\n    fprintf(__stderrp, \"Where sub-commands are:\\n\");\n    fprintf(__stderrp, \"    fkey-indexes\\n\");\n    return 1;\n}\n"
  },
  {
    "id": "shell.c#21010:1#tryToCloneData",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_stmt *pQuery = 0;\n    sqlite3_stmt *pInsert = 0;\n    char *zQuery = 0;\n    char *zInsert = 0;\n    int rc;\n    int i, j, n;\n    int nTable = strlen30(zTable);\n    int k = 0;\n    int cnt = 0;\n    const int spinRate = 10000;\n    zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\"\", zTable);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        fprintf(__stderrp, \"Error %d: %s on [%s]\\n\", sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db), zQuery);\n        goto end_data_xfer;\n    }\n    n = sqlite3_column_count(pQuery);\n    zInsert = sqlite3_malloc64(200 + nTable + n * 3);\n    shell_check_oom(zInsert);\n    sqlite3_snprintf(200 + nTable, zInsert, \"INSERT OR IGNORE INTO \\\"%s\\\" VALUES(?\", zTable);\n    i = strlen30(zInsert);\n    for (j = 1; j < n; j++) {\n        __builtin___memcpy_chk(zInsert + i, \",?\", 2, __builtin_object_size(zInsert + i, 0));\n        i += 2;\n    }\n    __builtin___memcpy_chk(zInsert + i, \");\", 3, __builtin_object_size(zInsert + i, 0));\n    rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);\n    if (rc) {\n        fprintf(__stderrp, \"Error %d: %s on [%s]\\n\", sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb), zQuery);\n        goto end_data_xfer;\n    }\n    for (k = 0; k < 2; k++) {\n        while ((rc = sqlite3_step(pQuery)) == 100)\n            {\n                for (i = 0; i < n; i++) {\n                    switch (sqlite3_column_type(pQuery, i)) {\n                      case 5:\n                        {\n                            sqlite3_bind_null(pInsert, i + 1);\n                            break;\n                        }\n                      case 1:\n                        {\n                            sqlite3_bind_int64(pInsert, i + 1, sqlite3_column_int64(pQuery, i));\n                            break;\n                        }\n                      case 2:\n                        {\n                            sqlite3_bind_double(pInsert, i + 1, sqlite3_column_double(pQuery, i));\n                            break;\n                        }\n                      case 3:\n                        {\n                            sqlite3_bind_text(pInsert, i + 1, (const char *)sqlite3_column_text(pQuery, i), -1, ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                      case 4:\n                        {\n                            sqlite3_bind_blob(pInsert, i + 1, sqlite3_column_blob(pQuery, i), sqlite3_column_bytes(pQuery, i), ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                    }\n                }\n                rc = sqlite3_step(pInsert);\n                if (rc != 0 && rc != 100 && rc != 101) {\n                    fprintf(__stderrp, \"Error %d: %s\\n\", sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb));\n                }\n                sqlite3_reset(pInsert);\n                cnt++;\n                if ((cnt % spinRate) == 0) {\n                    printf(\"%c\\b\", \"|/-\\\\\"[(cnt / spinRate) % 4]);\n                    fflush(__stdoutp);\n                }\n            }\n        if (rc == 101)\n            break;\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\" ORDER BY rowid DESC;\", zTable);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            fprintf(__stderrp, \"Warning: cannot step \\\"%s\\\" backwards\", zTable);\n            break;\n        }\n    }\n  end_data_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_finalize(pInsert);\n    sqlite3_free(zQuery);\n    sqlite3_free(zInsert);\n}\n"
  },
  {
    "id": "shell.c#16653:1#editFunc",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    const char *zEditor;\n    char *zTempFile = 0;\n    sqlite3 *db;\n    char *zCmd = 0;\n    int bBin;\n    int rc;\n    int hasCRNL = 0;\n    FILE *f = 0;\n    sqlite3_int64 sz;\n    sqlite3_int64 x;\n    unsigned char *p = 0;\n    if (argc == 2) {\n        zEditor = (const char *)sqlite3_value_text(argv[1]);\n    } else {\n        zEditor = getenv(\"VISUAL\");\n    }\n    if (zEditor == 0) {\n        sqlite3_result_error(context, \"no editor for edit()\", -1);\n        return;\n    }\n    if (sqlite3_value_type(argv[0]) == 5) {\n        sqlite3_result_error(context, \"NULL input to edit()\", -1);\n        return;\n    }\n    db = sqlite3_context_db_handle(context);\n    zTempFile = 0;\n    sqlite3_file_control(db, 0, 16, &zTempFile);\n    if (zTempFile == 0) {\n        sqlite3_uint64 r = 0;\n        sqlite3_randomness(sizeof (r), &r);\n        zTempFile = sqlite3_mprintf(\"temp%llx\", r);\n        if (zTempFile == 0) {\n            sqlite3_result_error_nomem(context);\n            return;\n        }\n    }\n    bBin = sqlite3_value_type(argv[0]) == 4;\n    f = fopen(zTempFile, bBin ? \"wb\" : \"w\");\n    if (f == 0) {\n        sqlite3_result_error(context, \"edit() cannot open temp file\", -1);\n        goto edit_func_end;\n    }\n    sz = sqlite3_value_bytes(argv[0]);\n    if (bBin) {\n        x = fwrite(sqlite3_value_blob(argv[0]), 1, (size_t)sz, f);\n    } else {\n        const char *z = (const char *)sqlite3_value_text(argv[0]);\n        if (z && strstr(z, \"\\r\\n\") != 0)\n            hasCRNL = 1;\n        x = fwrite(sqlite3_value_text(argv[0]), 1, (size_t)sz, f);\n    }\n    fclose(f);\n    f = 0;\n    if (x != sz) {\n        sqlite3_result_error(context, \"edit() could not write the whole file\", -1);\n        goto edit_func_end;\n    }\n    zCmd = sqlite3_mprintf(\"%s \\\"%s\\\"\", zEditor, zTempFile);\n    if (zCmd == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    rc = system(zCmd);\n    sqlite3_free(zCmd);\n    if (rc) {\n        sqlite3_result_error(context, \"EDITOR returned non-zero\", -1);\n        goto edit_func_end;\n    }\n    f = fopen(zTempFile, \"rb\");\n    if (f == 0) {\n        sqlite3_result_error(context, \"edit() cannot reopen temp file after edit\", -1);\n        goto edit_func_end;\n    }\n    fseek(f, 0, 2);\n    sz = ftell(f);\n    rewind(f);\n    p = sqlite3_malloc64(sz + 1);\n    if (p == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    x = fread(p, 1, (size_t)sz, f);\n    fclose(f);\n    f = 0;\n    if (x != sz) {\n        sqlite3_result_error(context, \"could not read back the whole file\", -1);\n        goto edit_func_end;\n    }\n    if (bBin) {\n        sqlite3_result_blob64(context, p, sz, sqlite3_free);\n    } else {\n        sqlite3_int64 i, j;\n        if (hasCRNL) {\n        } else {\n            for (i = j = 0; i < sz; i++) {\n                if (p[i] == '\\r' && p[i + 1] == '\\n')\n                    i++;\n                p[j++] = p[i];\n            }\n            sz = j;\n            p[sz] = 0;\n        }\n        sqlite3_result_text64(context, (const char *)p, sz, sqlite3_free, 1);\n    }\n    p = 0;\n  edit_func_end:\n    if (f)\n        fclose(f);\n    unlink(zTempFile);\n    sqlite3_free(zTempFile);\n    sqlite3_free(p);\n}\n"
  },
  {
    "id": "shell.c#11385:1#idxFindIndexes",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    IdxStatement *pStmt;\n    sqlite3 *dbm = p->dbm;\n    int rc = 0;\n    IdxHash hIdx;\n    idxHashInit(&hIdx);\n    for (pStmt = p->pStatement; rc == 0 && pStmt; pStmt = pStmt->pNext) {\n        IdxHashEntry *pEntry;\n        sqlite3_stmt *pExplain = 0;\n        idxHashClear(&hIdx);\n        rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr, \"EXPLAIN QUERY PLAN %s\", pStmt->zSql);\n        while (rc == 0 && sqlite3_step(pExplain) == 100)\n            {\n                const char *zDetail = (const char *)sqlite3_column_text(pExplain, 3);\n                int nDetail;\n                int i;\n                if (!zDetail)\n                    continue;\n                nDetail = (int)strlen(zDetail);\n                for (i = 0; i < nDetail; i++) {\n                    const char *zIdx = 0;\n                    if (i + 13 < nDetail && memcmp(&zDetail[i], \" USING INDEX \", 13) == 0) {\n                        zIdx = &zDetail[i + 13];\n                    } else if (i + 22 < nDetail && memcmp(&zDetail[i], \" USING COVERING INDEX \", 22) == 0) {\n                        zIdx = &zDetail[i + 22];\n                    }\n                    if (zIdx) {\n                        const char *zSql;\n                        int nIdx = 0;\n                        while (zIdx[nIdx] != '\\x00' && (zIdx[nIdx] != ' ' || zIdx[nIdx + 1] != '('))\n                            {\n                                nIdx++;\n                            }\n                        zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);\n                        if (zSql) {\n                            idxHashAdd(&rc, &hIdx, zSql, 0);\n                            if (rc)\n                                goto find_indexes_out;\n                        }\n                        break;\n                    }\n                }\n                if (zDetail[0] != '-') {\n                    pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, \"%s\\n\", zDetail);\n                }\n            }\n        for (pEntry = hIdx.pFirst; pEntry; pEntry = pEntry->pNext) {\n            pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, \"%s;\\n\", pEntry->zKey);\n        }\n        idxFinalize(&rc, pExplain);\n    }\n  find_indexes_out:\n    idxHashClear(&hIdx);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#4801:1#sqlite3re_match",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    ReStateSet aStateSet[2], *pThis, *pNext;\n    ReStateNumber aSpace[100];\n    ReStateNumber *pToFree;\n    unsigned int i = 0;\n    unsigned int iSwap = 0;\n    int c = 268435455;\n    int cPrev = 0;\n    int rc = 0;\n    ReInput in;\n    in.z = zIn;\n    in.i = 0;\n    in.mx = nIn >= 0 ? nIn : (int)strlen((const char *)zIn);\n    if (pRe->nInit) {\n        unsigned char x = pRe->zInit[0];\n        while (in.i + pRe->nInit <= in.mx && (zIn[in.i] != x || strncmp((const char *)zIn + in.i, (const char *)pRe->zInit, pRe->nInit) != 0))\n            {\n                in.i++;\n            }\n        if (in.i + pRe->nInit > in.mx)\n            return 0;\n        c = 268435455 - 1;\n    }\n    if (pRe->nState <= (sizeof (aSpace) / (sizeof (aSpace[0]) * 2))) {\n        pToFree = 0;\n        aStateSet[0].aState = aSpace;\n    } else {\n        pToFree = sqlite3_malloc64(sizeof(ReStateNumber) * 2 * pRe->nState);\n        if (pToFree == 0)\n            return -1;\n        aStateSet[0].aState = pToFree;\n    }\n    aStateSet[1].aState = &aStateSet[0].aState[pRe->nState];\n    pNext = &aStateSet[1];\n    pNext->nState = 0;\n    re_add_state(pNext, 0);\n    while (c != 0 && pNext->nState > 0)\n        {\n            cPrev = c;\n            c = pRe->xNextChar(&in);\n            pThis = pNext;\n            pNext = &aStateSet[iSwap];\n            iSwap = 1 - iSwap;\n            pNext->nState = 0;\n            for (i = 0; i < pThis->nState; i++) {\n                int x = pThis->aState[i];\n                switch (pRe->aOp[x]) {\n                  case 1:\n                    {\n                        if (pRe->aArg[x] == c)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 18:\n                    {\n                        if (cPrev == 268435455)\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 2:\n                    {\n                        if (c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 11:\n                    {\n                        if (re_word_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 12:\n                    {\n                        if (!re_word_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 13:\n                    {\n                        if (re_digit_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 14:\n                    {\n                        if (!re_digit_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 15:\n                    {\n                        if (re_space_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 16:\n                    {\n                        if (!re_space_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 17:\n                    {\n                        if (re_word_char(c) != re_word_char(cPrev))\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 3:\n                    {\n                        re_add_state(pNext, x);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 4:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 5:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        break;\n                    }\n                  case 6:\n                    {\n                        rc = 1;\n                        goto re_match_end;\n                    }\n                  case 8:\n                    {\n                        if (c == 0)\n                            break;\n                        goto re_op_cc_inc;\n                    }\n                  case 7:\n                  re_op_cc_inc:\n                    {\n                        int j = 1;\n                        int n = pRe->aArg[x];\n                        int hit = 0;\n                        for (j = 1; j > 0 && j < n; j++) {\n                            if (pRe->aOp[x + j] == 9) {\n                                if (pRe->aArg[x + j] == c) {\n                                    hit = 1;\n                                    j = -1;\n                                }\n                            } else {\n                                if (pRe->aArg[x + j] <= c && pRe->aArg[x + j + 1] >= c) {\n                                    hit = 1;\n                                    j = -1;\n                                } else {\n                                    j++;\n                                }\n                            }\n                        }\n                        if (pRe->aOp[x] == 8)\n                            hit = !hit;\n                        if (hit)\n                            re_add_state(pNext, x + n);\n                        break;\n                    }\n                }\n            }\n        }\n    for (i = 0; i < pNext->nState; i++) {\n        int x = pNext->aState[i];\n        while (pRe->aOp[x] == 5)\n            x += pRe->aArg[x];\n        if (pRe->aOp[x] == 6) {\n            rc = 1;\n            break;\n        }\n    }\n  re_match_end:\n    sqlite3_free(pToFree);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#22553:1#arDotCommand",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    ArCommand cmd;\n    int rc;\n    __builtin___memset_chk(&cmd, 0, sizeof (cmd), __builtin_object_size(&cmd, 0));\n    cmd.fromCmdLine = fromCmdLine;\n    rc = arParseCommand(azArg, nArg, &cmd);\n    if (rc == 0) {\n        int eDbType = 0;\n        cmd.p = pState;\n        cmd.db = pState->db;\n        if (cmd.zFile) {\n            eDbType = deduceDatabaseType(cmd.zFile, 1);\n        } else {\n            eDbType = pState->openMode;\n        }\n        if (eDbType == 3) {\n            if (cmd.eCmd == 4 || cmd.eCmd == 5) {\n                if (cmd.zFile == 0) {\n                    cmd.zSrcTable = sqlite3_mprintf(\"zip\");\n                } else {\n                    cmd.zSrcTable = sqlite3_mprintf(\"zipfile(%Q)\", cmd.zFile);\n                }\n            }\n            cmd.bZip = 1;\n        } else if (cmd.zFile) {\n            int flags;\n            if (cmd.bAppend)\n                eDbType = 2;\n            if (cmd.eCmd == 1 || cmd.eCmd == 3 || cmd.eCmd == 7 || cmd.eCmd == 2) {\n                flags = 2 | 4;\n            } else {\n                flags = 1;\n            }\n            cmd.db = 0;\n            if (cmd.bDryRun) {\n                fprintf(pState->out, \"-- open database '%s'%s\\n\", cmd.zFile, eDbType == 2 ? \" using 'apndvfs'\" : \"\");\n            }\n            rc = sqlite3_open_v2(cmd.zFile, &cmd.db, flags, eDbType == 2 ? \"apndvfs\" : 0);\n            if (rc != 0) {\n                fprintf(__stderrp, \"cannot open file: %s (%s)\\n\", cmd.zFile, sqlite3_errmsg(cmd.db));\n                goto end_ar_command;\n            }\n            sqlite3_fileio_init(cmd.db, 0, 0);\n            sqlite3_sqlar_init(cmd.db, 0, 0);\n            sqlite3_create_function(cmd.db, \"shell_putsnl\", 1, 1, cmd.p, shellPutsFunc, 0, 0);\n        }\n        if (cmd.zSrcTable == 0 && cmd.bZip == 0 && cmd.eCmd != 6) {\n            if (cmd.eCmd != 1 && sqlite3_table_column_metadata(cmd.db, 0, \"sqlar\", \"name\", 0, 0, 0, 0, 0)) {\n                fprintf(__stderrp, \"database does not contain an 'sqlar' table\\n\");\n                rc = 1;\n                goto end_ar_command;\n            }\n            cmd.zSrcTable = sqlite3_mprintf(\"sqlar\");\n        }\n        switch (cmd.eCmd) {\n          case 1:\n            rc = arCreateOrUpdateCommand(&cmd, 0, 0);\n            break;\n          case 4:\n            rc = arExtractCommand(&cmd);\n            break;\n          case 5:\n            rc = arListCommand(&cmd);\n            break;\n          case 6:\n            arUsage(pState->out);\n            break;\n          case 3:\n            rc = arCreateOrUpdateCommand(&cmd, 1, 0);\n            break;\n          case 7:\n            rc = arRemoveCommand(&cmd);\n            break;\n          default:\n            ((void)0);\n            rc = arCreateOrUpdateCommand(&cmd, 1, 1);\n            break;\n        }\n    }\n  end_ar_command:\n    if (cmd.db != pState->db) {\n        close_db(cmd.db);\n    }\n    sqlite3_free(cmd.zSrcTable);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#2747:1#decimalCmpFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Decimal *pA = 0, *pB = 0;\n    int rc;\n    (void)(argc);\n    pA = decimal_new(context, argv[0], 0, 0);\n    if (pA == 0 || pA->isNull)\n        goto cmp_done;\n    pB = decimal_new(context, argv[1], 0, 0);\n    if (pB == 0 || pB->isNull)\n        goto cmp_done;\n    rc = decimal_cmp(pA, pB);\n    if (rc < 0)\n        rc = -1;\n    else if (rc > 0)\n        rc = +1;\n    sqlite3_result_int(context, rc);\n  cmp_done:\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
  },
  {
    "id": "shell.c#9086:1#zipfileGetMode",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    const char *z = (const char *)sqlite3_value_text(pVal);\n    u32 mode = 0;\n    if (z == 0) {\n        mode = (bIsDir ? (16384 + 493) : (32768 + 420));\n    } else if (z[0] >= '0' && z[0] <= '9') {\n        mode = (unsigned int)sqlite3_value_int(pVal);\n    } else {\n        const char zTemplate[11] = \"-rwxrwxrwx\";\n        int i;\n        if (strlen(z) != 10)\n            goto parse_error;\n        switch (z[0]) {\n          case '-':\n            mode |= 32768;\n            break;\n          case 'd':\n            mode |= 16384;\n            break;\n          case 'l':\n            mode |= 40960;\n            break;\n          default:\n            goto parse_error;\n        }\n        for (i = 1; i < 10; i++) {\n            if (z[i] == zTemplate[i])\n                mode |= 1 << (9 - i);\n            else if (z[i] != '-')\n                goto parse_error;\n        }\n    }\n    if (((mode & 16384) == 0) == bIsDir) {\n        *pzErr = sqlite3_mprintf(\"zipfile: mode does not match data\");\n        return 19;\n    }\n    *pMode = mode;\n    return 0;\n  parse_error:\n    *pzErr = sqlite3_mprintf(\"zipfile: parse error in mode: %s\", z);\n    return 1;\n}\n"
  },
  {
    "id": "shell.c#9630:1#zipfileStep",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    ZipfileCtx *p;\n    ZipfileEntry e;\n    sqlite3_value *pName = 0;\n    sqlite3_value *pMode = 0;\n    sqlite3_value *pMtime = 0;\n    sqlite3_value *pData = 0;\n    sqlite3_value *pMethod = 0;\n    int bIsDir = 0;\n    u32 mode;\n    int rc = 0;\n    char *zErr = 0;\n    int iMethod = -1;\n    const u8 *aData = 0;\n    int nData = 0;\n    int szUncompressed = 0;\n    u8 *aFree = 0;\n    u32 iCrc32 = 0;\n    char *zName = 0;\n    int nName = 0;\n    char *zFree = 0;\n    int nByte;\n    __builtin___memset_chk(&e, 0, sizeof (e), __builtin_object_size(&e, 0));\n    p = (ZipfileCtx *)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));\n    if (p == 0)\n        return;\n    if (nVal != 2 && nVal != 4 && nVal != 5) {\n        zErr = sqlite3_mprintf(\"wrong number of arguments to function zipfile()\");\n        rc = 1;\n        goto zipfile_step_out;\n    }\n    pName = apVal[0];\n    if (nVal == 2) {\n        pData = apVal[1];\n    } else {\n        pMode = apVal[1];\n        pMtime = apVal[2];\n        pData = apVal[3];\n        if (nVal == 5) {\n            pMethod = apVal[4];\n        }\n    }\n    zName = (char *)sqlite3_value_text(pName);\n    nName = sqlite3_value_bytes(pName);\n    if (zName == 0) {\n        zErr = sqlite3_mprintf(\"first argument to zipfile() must be non-NULL\");\n        rc = 1;\n        goto zipfile_step_out;\n    }\n    if (pMethod && 5 != sqlite3_value_type(pMethod)) {\n        iMethod = (int)sqlite3_value_int64(pMethod);\n        if (iMethod != 0 && iMethod != 8) {\n            zErr = sqlite3_mprintf(\"illegal method value: %d\", iMethod);\n            rc = 1;\n            goto zipfile_step_out;\n        }\n    }\n    if (sqlite3_value_type(pData) == 5) {\n        bIsDir = 1;\n        iMethod = 0;\n    } else {\n        aData = sqlite3_value_blob(pData);\n        szUncompressed = nData = sqlite3_value_bytes(pData);\n        iCrc32 = crc32(0, aData, nData);\n        if (iMethod < 0 || iMethod == 8) {\n            int nOut = 0;\n            rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);\n            if (rc != 0) {\n                goto zipfile_step_out;\n            }\n            if (iMethod == 8 || nOut < nData) {\n                aData = aFree;\n                nData = nOut;\n                iMethod = 8;\n            } else {\n                iMethod = 0;\n            }\n        }\n    }\n    rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);\n    if (rc)\n        goto zipfile_step_out;\n    e.mUnixTime = zipfileGetTime(pMtime);\n    if (bIsDir == 0) {\n        if (nName > 0 && zName[nName - 1] == '/') {\n            zErr = sqlite3_mprintf(\"non-directory name must not end with /\");\n            rc = 1;\n            goto zipfile_step_out;\n        }\n    } else {\n        if (nName == 0 || zName[nName - 1] != '/') {\n            zName = zFree = sqlite3_mprintf(\"%s/\", zName);\n            if (zName == 0) {\n                rc = 7;\n                goto zipfile_step_out;\n            }\n            nName = (int)strlen(zName);\n        } else {\n            while (nName > 1 && zName[nName - 2] == '/')\n                nName--;\n        }\n    }\n    e.cds.iVersionMadeBy = ((3 << 8) + 30);\n    e.cds.iVersionExtract = 20;\n    e.cds.flags = 2048;\n    e.cds.iCompression = (u16)iMethod;\n    zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);\n    e.cds.crc32 = iCrc32;\n    e.cds.szCompressed = nData;\n    e.cds.szUncompressed = szUncompressed;\n    e.cds.iExternalAttr = (mode << 16);\n    e.cds.iOffset = p->body.n;\n    e.cds.nFile = (u16)nName;\n    e.cds.zFile = zName;\n    nByte = 30 + e.cds.nFile + 9;\n    if ((rc = zipfileBufferGrow(&p->body, nByte)))\n        goto zipfile_step_out;\n    p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);\n    if (nData > 0) {\n        if ((rc = zipfileBufferGrow(&p->body, nData)))\n            goto zipfile_step_out;\n        __builtin___memcpy_chk(&p->body.a[p->body.n], aData, nData, __builtin_object_size(&p->body.a[p->body.n], 0));\n        p->body.n += nData;\n    }\n    nByte = 46 + e.cds.nFile + 9;\n    if ((rc = zipfileBufferGrow(&p->cds, nByte)))\n        goto zipfile_step_out;\n    p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);\n    p->nEntry++;\n  zipfile_step_out:\n    sqlite3_free(aFree);\n    sqlite3_free(zFree);\n    if (rc) {\n        if (zErr) {\n            sqlite3_result_error(pCtx, zErr, -1);\n        } else {\n            sqlite3_result_error_code(pCtx, rc);\n        }\n    }\n    sqlite3_free(zErr);\n}\n"
  },
  {
    "id": "shell.c#18762:1#exec_prepared_stmt_columnar",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3_int64 nRow = 0;\n    int nColumn = 0;\n    char **azData = 0;\n    sqlite3_int64 nAlloc = 0;\n    char *abRowDiv = 0;\n    const unsigned char *uz;\n    const char *z;\n    char **azQuoted = 0;\n    int rc;\n    sqlite3_int64 i, nData;\n    int j, nTotal, w, n;\n    const char *colSep = 0;\n    const char *rowSep = 0;\n    const unsigned char **azNextLine = 0;\n    int bNextLine = 0;\n    int bMultiLineRowExists = 0;\n    int bw = p->cmOpts.bWordWrap;\n    const char *zEmpty = \"\";\n    const char *zShowNull = p->nullValue;\n    rc = sqlite3_step(pStmt);\n    if (rc != 100)\n        return;\n    nColumn = sqlite3_column_count(pStmt);\n    nAlloc = nColumn * 4;\n    if (nAlloc <= 0)\n        nAlloc = 1;\n    azData = sqlite3_malloc64(nAlloc * sizeof(char *));\n    shell_check_oom(azData);\n    azNextLine = sqlite3_malloc64(nColumn * sizeof(char *));\n    shell_check_oom((void *)azNextLine);\n    __builtin___memset_chk((void *)azNextLine, 0, nColumn * sizeof(char *), __builtin_object_size((void *)azNextLine, 0));\n    if (p->cmOpts.bQuote) {\n        azQuoted = sqlite3_malloc64(nColumn * sizeof(char *));\n        shell_check_oom(azQuoted);\n        __builtin___memset_chk(azQuoted, 0, nColumn * sizeof(char *), __builtin_object_size(azQuoted, 0));\n    }\n    abRowDiv = sqlite3_malloc64(nAlloc / nColumn);\n    shell_check_oom(abRowDiv);\n    if (nColumn > p->nWidth) {\n        p->colWidth = realloc(p->colWidth, (nColumn + 1) * 2 * sizeof(int));\n        shell_check_oom(p->colWidth);\n        for (i = p->nWidth; i < nColumn; i++)\n            p->colWidth[i] = 0;\n        p->nWidth = nColumn;\n        p->actualWidth = &p->colWidth[nColumn];\n    }\n    __builtin___memset_chk(p->actualWidth, 0, nColumn * sizeof(int), __builtin_object_size(p->actualWidth, 0));\n    for (i = 0; i < nColumn; i++) {\n        w = p->colWidth[i];\n        if (w < 0)\n            w = -w;\n        p->actualWidth[i] = w;\n    }\n    for (i = 0; i < nColumn; i++) {\n        const unsigned char *zNotUsed;\n        int wx = p->colWidth[i];\n        if (wx == 0) {\n            wx = p->cmOpts.iWrap;\n        }\n        if (wx < 0)\n            wx = -wx;\n        uz = (const unsigned char *)sqlite3_column_name(pStmt, i);\n        azData[i] = translateForDisplayAndDup(uz, &zNotUsed, wx, bw);\n    }\n    do {\n        int useNextLine = bNextLine;\n        bNextLine = 0;\n        if ((nRow + 2) * nColumn >= nAlloc) {\n            nAlloc *= 2;\n            azData = sqlite3_realloc64(azData, nAlloc * sizeof(char *));\n            shell_check_oom(azData);\n            abRowDiv = sqlite3_realloc64(abRowDiv, nAlloc / nColumn);\n            shell_check_oom(abRowDiv);\n        }\n        abRowDiv[nRow] = 1;\n        nRow++;\n        for (i = 0; i < nColumn; i++) {\n            int wx = p->colWidth[i];\n            if (wx == 0) {\n                wx = p->cmOpts.iWrap;\n            }\n            if (wx < 0)\n                wx = -wx;\n            if (useNextLine) {\n                uz = azNextLine[i];\n                if (uz == 0)\n                    uz = (u8 *)zEmpty;\n            } else if (p->cmOpts.bQuote) {\n                sqlite3_free(azQuoted[i]);\n                azQuoted[i] = quoted_column(pStmt, i);\n                uz = (const unsigned char *)azQuoted[i];\n            } else {\n                uz = (const unsigned char *)sqlite3_column_text(pStmt, i);\n                if (uz == 0)\n                    uz = (u8 *)zShowNull;\n            }\n            azData[nRow * nColumn + i] = translateForDisplayAndDup(uz, &azNextLine[i], wx, bw);\n            if (azNextLine[i]) {\n                bNextLine = 1;\n                abRowDiv[nRow - 1] = 0;\n                bMultiLineRowExists = 1;\n            }\n        }\n    } while (bNextLine || sqlite3_step(pStmt) == 100);\n    nTotal = nColumn * (nRow + 1);\n    for (i = 0; i < nTotal; i++) {\n        z = azData[i];\n        if (z == 0)\n            z = (char *)zEmpty;\n        n = strlenChar(z);\n        j = i % nColumn;\n        if (n > p->actualWidth[j])\n            p->actualWidth[j] = n;\n    }\n    if (seenInterrupt)\n        goto columnar_end;\n    if (nColumn == 0)\n        goto columnar_end;\n    switch (p->cMode) {\n      case 1:\n        {\n            colSep = \"  \";\n            rowSep = \"\\n\";\n            if (p->showHeader) {\n                for (i = 0; i < nColumn; i++) {\n                    w = p->actualWidth[i];\n                    if (p->colWidth[i] < 0)\n                        w = -w;\n                    utf8_width_print(p->out, w, azData[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", p->out);\n                }\n                for (i = 0; i < nColumn; i++) {\n                    print_dashes(p->out, p->actualWidth[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", p->out);\n                }\n            }\n            break;\n        }\n      case 15:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            print_row_separator(p, nColumn, \"+\");\n            fputs(\"| \", p->out);\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(p->out, \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", p->out);\n            }\n            print_row_separator(p, nColumn, \"+\");\n            break;\n        }\n      case 14:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            fputs(\"| \", p->out);\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(p->out, \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", p->out);\n            }\n            print_row_separator(p, nColumn, \"|\");\n            break;\n        }\n      case 16:\n        {\n            colSep = \" \\342\\224\\202 \";\n            rowSep = \" \\342\\224\\202\\n\";\n            print_box_row_separator(p, nColumn, \"\\342\\224\\214\", \"\\342\\224\\254\", \"\\342\\224\\220\");\n            fprintf(p->out, \"\\342\\224\\202 \");\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(p->out, \"%*s%s%*s%s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\", i == nColumn - 1 ? \" \\342\\224\\202\\n\" : \" \\342\\224\\202 \");\n            }\n            print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n            break;\n        }\n    }\n    for (i = nColumn , j = 0; i < nTotal; i++ , j++) {\n        if (j == 0 && p->cMode != 1) {\n            fprintf(p->out, \"%s\", p->cMode == 16 ? \"\\342\\224\\202 \" : \"| \");\n        }\n        z = azData[i];\n        if (z == 0)\n            z = p->nullValue;\n        w = p->actualWidth[j];\n        if (p->colWidth[j] < 0)\n            w = -w;\n        utf8_width_print(p->out, w, z);\n        if (j == nColumn - 1) {\n            fprintf(p->out, \"%s\", rowSep);\n            if (bMultiLineRowExists && abRowDiv[i / nColumn - 1] && i + 1 < nTotal) {\n                if (p->cMode == 15) {\n                    print_row_separator(p, nColumn, \"+\");\n                } else if (p->cMode == 16) {\n                    print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n                } else if (p->cMode == 1) {\n                    fprintf(p->out, \"\\n\");\n                }\n            }\n            j = -1;\n            if (seenInterrupt)\n                goto columnar_end;\n        } else {\n            fprintf(p->out, \"%s\", colSep);\n        }\n    }\n    if (p->cMode == 15) {\n        print_row_separator(p, nColumn, \"+\");\n    } else if (p->cMode == 16) {\n        print_box_row_separator(p, nColumn, \"\\342\\224\\224\", \"\\342\\224\\264\", \"\\342\\224\\230\");\n    }\n  columnar_end:\n    if (seenInterrupt) {\n        fprintf(p->out, \"Interrupt\\n\");\n    }\n    nData = (nRow + 1) * nColumn;\n    for (i = 0; i < nData; i++) {\n        z = azData[i];\n        if (z != zEmpty && z != zShowNull)\n            free(azData[i]);\n    }\n    sqlite3_free(azData);\n    sqlite3_free((void *)azNextLine);\n    sqlite3_free(abRowDiv);\n    if (azQuoted) {\n        for (i = 0; i < nColumn; i++)\n            sqlite3_free(azQuoted[i]);\n        sqlite3_free(azQuoted);\n    }\n}\n"
  },
  {
    "id": "shell.c#3302:1#base64",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int nb, nc, nv = sqlite3_value_bytes(av[0]);\n    int nvMax = sqlite3_limit(sqlite3_context_db_handle(context), 0, -1);\n    char *cBuf;\n    u8 *bBuf;\n    ((void)0);\n    switch (sqlite3_value_type(av[0])) {\n      case 4:\n        nb = nv;\n        nc = 4 * (nv + 2 / 3);\n        nc += (nc + (72 - 1)) / 72 + 1;\n        if (nvMax < nc) {\n            sqlite3_result_error(context, \"blob expanded to base64 too big\", -1);\n            return;\n        }\n        cBuf = sqlite3_malloc(nc);\n        if (!cBuf)\n            goto memFail;\n        bBuf = (u8 *)sqlite3_value_blob(av[0]);\n        nc = (int)(toBase64(bBuf, nb, cBuf) - cBuf);\n        sqlite3_result_text(context, cBuf, nc, sqlite3_free);\n        break;\n      case 3:\n        nc = nv;\n        nb = 3 * ((nv + 3) / 4);\n        if (nvMax < nb) {\n            sqlite3_result_error(context, \"blob from base64 may be too big\", -1);\n            return;\n        } else if (nb < 1) {\n            nb = 1;\n        }\n        bBuf = sqlite3_malloc(nb);\n        if (!bBuf)\n            goto memFail;\n        cBuf = (char *)sqlite3_value_text(av[0]);\n        nb = (int)(fromBase64(cBuf, nc, bBuf) - bBuf);\n        sqlite3_result_blob(context, bBuf, nb, sqlite3_free);\n        break;\n      default:\n        sqlite3_result_error(context, \"base64 accepts only blob or text\", -1);\n        return;\n    }\n    return;\n  memFail:\n    sqlite3_result_error(context, \"base64 OOM\", -1);\n}\n"
  },
  {
    "id": "shell.c#2521:1#decimal_new",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Decimal *p;\n    int n, i;\n    const unsigned char *zIn;\n    int iExp = 0;\n    p = sqlite3_malloc(sizeof (*p));\n    if (p == 0)\n        goto new_no_mem;\n    p->sign = 0;\n    p->oom = 0;\n    p->isInit = 1;\n    p->isNull = 0;\n    p->nDigit = 0;\n    p->nFrac = 0;\n    if (zAlt) {\n        n = nAlt , zIn = zAlt;\n    } else {\n        if (sqlite3_value_type(pIn) == 5) {\n            p->a = 0;\n            p->isNull = 1;\n            return p;\n        }\n        n = sqlite3_value_bytes(pIn);\n        zIn = sqlite3_value_text(pIn);\n    }\n    p->a = sqlite3_malloc64(n + 1);\n    if (p->a == 0)\n        goto new_no_mem;\n    for (i = 0; isspace(zIn[i]); i++) {\n    }\n    if (zIn[i] == '-') {\n        p->sign = 1;\n        i++;\n    } else if (zIn[i] == '+') {\n        i++;\n    }\n    while (i < n && zIn[i] == '0')\n        i++;\n    while (i < n)\n        {\n            char c = zIn[i];\n            if (c >= '0' && c <= '9') {\n                p->a[p->nDigit++] = c - '0';\n            } else if (c == '.') {\n                p->nFrac = p->nDigit + 1;\n            } else if (c == 'e' || c == 'E') {\n                int j = i + 1;\n                int neg = 0;\n                if (j >= n)\n                    break;\n                if (zIn[j] == '-') {\n                    neg = 1;\n                    j++;\n                } else if (zIn[j] == '+') {\n                    j++;\n                }\n                while (j < n && iExp < 1000000)\n                    {\n                        if (zIn[j] >= '0' && zIn[j] <= '9') {\n                            iExp = iExp * 10 + zIn[j] - '0';\n                        }\n                        j++;\n                    }\n                if (neg)\n                    iExp = -iExp;\n                break;\n            }\n            i++;\n        }\n    if (p->nFrac) {\n        p->nFrac = p->nDigit - (p->nFrac - 1);\n    }\n    if (iExp > 0) {\n        if (p->nFrac > 0) {\n            if (iExp <= p->nFrac) {\n                p->nFrac -= iExp;\n                iExp = 0;\n            } else {\n                iExp -= p->nFrac;\n                p->nFrac = 0;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            __builtin___memset_chk(p->a + p->nDigit, 0, iExp, __builtin_object_size(p->a + p->nDigit, 0));\n            p->nDigit += iExp;\n        }\n    } else if (iExp < 0) {\n        int nExtra;\n        iExp = -iExp;\n        nExtra = p->nDigit - p->nFrac - 1;\n        if (nExtra) {\n            if (nExtra >= iExp) {\n                p->nFrac += iExp;\n                iExp = 0;\n            } else {\n                iExp -= nExtra;\n                p->nFrac = p->nDigit - 1;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            __builtin___memmove_chk(p->a + iExp, p->a, p->nDigit, __builtin_object_size(p->a + iExp, 0));\n            __builtin___memset_chk(p->a, 0, iExp, __builtin_object_size(p->a, 0));\n            p->nDigit += iExp;\n            p->nFrac += iExp;\n        }\n    }\n    return p;\n  new_no_mem:\n    if (pCtx)\n        sqlite3_result_error_nomem(pCtx);\n    sqlite3_free(p);\n    return 0;\n}\n"
  },
  {
    "id": "shell.c#9222:1#zipfileUpdate",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    ZipfileTab *pTab = (ZipfileTab *)pVtab;\n    int rc = 0;\n    ZipfileEntry *pNew = 0;\n    u32 mode = 0;\n    u32 mTime = 0;\n    i64 sz = 0;\n    const char *zPath = 0;\n    int nPath = 0;\n    const u8 *pData = 0;\n    int nData = 0;\n    int iMethod = 0;\n    u8 *pFree = 0;\n    char *zFree = 0;\n    ZipfileEntry *pOld = 0;\n    ZipfileEntry *pOld2 = 0;\n    int bUpdate = 0;\n    int bIsDir = 0;\n    u32 iCrc32 = 0;\n    (void)pRowid;\n    if (pTab->pWriteFd == 0) {\n        rc = zipfileBegin(pVtab);\n        if (rc != 0)\n            return rc;\n    }\n    if (sqlite3_value_type(apVal[0]) != 5) {\n        const char *zDelete = (const char *)sqlite3_value_text(apVal[0]);\n        int nDelete = (int)strlen(zDelete);\n        if (nVal > 1) {\n            const char *zUpdate = (const char *)sqlite3_value_text(apVal[1]);\n            if (zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete) != 0) {\n                bUpdate = 1;\n            }\n        }\n        for (pOld = pTab->pFirstEntry; 1; pOld = pOld->pNext) {\n            if (zipfileComparePath(pOld->cds.zFile, zDelete, nDelete) == 0) {\n                break;\n            }\n            ((void)0);\n        }\n    }\n    if (nVal > 1) {\n        if (sqlite3_value_type(apVal[5]) != 5) {\n            zipfileTableErr(pTab, \"sz must be NULL\");\n            rc = 19;\n        }\n        if (sqlite3_value_type(apVal[6]) != 5) {\n            zipfileTableErr(pTab, \"rawdata must be NULL\");\n            rc = 19;\n        }\n        if (rc == 0) {\n            if (sqlite3_value_type(apVal[7]) == 5) {\n                bIsDir = 1;\n            } else {\n                const u8 *aIn = sqlite3_value_blob(apVal[7]);\n                int nIn = sqlite3_value_bytes(apVal[7]);\n                int bAuto = sqlite3_value_type(apVal[8]) == 5;\n                iMethod = sqlite3_value_int(apVal[8]);\n                sz = nIn;\n                pData = aIn;\n                nData = nIn;\n                if (iMethod != 0 && iMethod != 8) {\n                    zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n                    rc = 19;\n                } else {\n                    if (bAuto || iMethod) {\n                        int nCmp;\n                        rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n                        if (rc == 0) {\n                            if (iMethod || nCmp < nIn) {\n                                iMethod = 8;\n                                pData = pFree;\n                                nData = nCmp;\n                            }\n                        }\n                    }\n                    iCrc32 = crc32(0, aIn, nIn);\n                }\n            }\n        }\n        if (rc == 0) {\n            rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n        }\n        if (rc == 0) {\n            zPath = (const char *)sqlite3_value_text(apVal[2]);\n            if (zPath == 0)\n                zPath = \"\";\n            nPath = (int)strlen(zPath);\n            mTime = zipfileGetTime(apVal[4]);\n        }\n        if (rc == 0 && bIsDir) {\n            if (nPath <= 0 || zPath[nPath - 1] != '/') {\n                zFree = sqlite3_mprintf(\"%s/\", zPath);\n                zPath = (const char *)zFree;\n                if (zFree == 0) {\n                    rc = 7;\n                    nPath = 0;\n                } else {\n                    nPath = (int)strlen(zPath);\n                }\n            }\n        }\n        if ((pOld == 0 || bUpdate) && rc == 0) {\n            ZipfileEntry *p;\n            for (p = pTab->pFirstEntry; p; p = p->pNext) {\n                if (zipfileComparePath(p->cds.zFile, zPath, nPath) == 0) {\n                    switch (sqlite3_vtab_on_conflict(pTab->db)) {\n                      case 2:\n                        {\n                            goto zipfile_update_done;\n                        }\n                      case 5:\n                        {\n                            pOld2 = p;\n                            break;\n                        }\n                      default:\n                        {\n                            zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n                            rc = 19;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        if (rc == 0) {\n            pNew = zipfileNewEntry(zPath);\n            if (pNew == 0) {\n                rc = 7;\n            } else {\n                pNew->cds.iVersionMadeBy = ((3 << 8) + 30);\n                pNew->cds.iVersionExtract = 20;\n                pNew->cds.flags = 2048;\n                pNew->cds.iCompression = (u16)iMethod;\n                zipfileMtimeToDos(&pNew->cds, mTime);\n                pNew->cds.crc32 = iCrc32;\n                pNew->cds.szCompressed = nData;\n                pNew->cds.szUncompressed = (u32)sz;\n                pNew->cds.iExternalAttr = (mode << 16);\n                pNew->cds.iOffset = (u32)pTab->szCurrent;\n                pNew->cds.nFile = (u16)nPath;\n                pNew->mUnixTime = (u32)mTime;\n                rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n                zipfileAddEntry(pTab, pOld, pNew);\n            }\n        }\n    }\n    if (rc == 0 && (pOld || pOld2)) {\n        ZipfileCsr *pCsr;\n        for (pCsr = pTab->pCsrList; pCsr; pCsr = pCsr->pCsrNext) {\n            if (pCsr->pCurrent && (pCsr->pCurrent == pOld || pCsr->pCurrent == pOld2)) {\n                pCsr->pCurrent = pCsr->pCurrent->pNext;\n                pCsr->bNoop = 1;\n            }\n        }\n        zipfileRemoveEntryFromList(pTab, pOld);\n        zipfileRemoveEntryFromList(pTab, pOld2);\n    }\n  zipfile_update_done:\n    sqlite3_free(pFree);\n    sqlite3_free(zFree);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#20156:1#readHexDb",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    unsigned char *a = 0;\n    int nLine;\n    int n = 0;\n    int pgsz = 0;\n    int iOffset = 0;\n    int j, k;\n    int rc;\n    FILE *in;\n    const char *zDbFilename = p->pAuxDb->zDbFilename;\n    unsigned int x[16];\n    char zLine[1000];\n    if (zDbFilename) {\n        in = fopen(zDbFilename, \"r\");\n        if (in == 0) {\n            fprintf(__stderrp, \"cannot open \\\"%s\\\" for reading\\n\", zDbFilename);\n            return 0;\n        }\n        nLine = 0;\n    } else {\n        in = p->in;\n        nLine = p->lineno;\n        if (in == 0)\n            in = __stdinp;\n    }\n    *pnData = 0;\n    nLine++;\n    if (fgets(zLine, sizeof (zLine), in) == 0)\n        goto readHexDb_error;\n    rc = sscanf(zLine, \"| size %d pagesize %d\", &n, &pgsz);\n    if (rc != 2)\n        goto readHexDb_error;\n    if (n < 0)\n        goto readHexDb_error;\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0)\n        goto readHexDb_error;\n    n = (n + pgsz - 1) & ~(pgsz - 1);\n    a = sqlite3_malloc(n ? n : 1);\n    shell_check_oom(a);\n    __builtin___memset_chk(a, 0, n, __builtin_object_size(a, 0));\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0) {\n        fprintf(__stderrp, \"invalid pagesize\\n\");\n        goto readHexDb_error;\n    }\n    for (nLine++; fgets(zLine, sizeof (zLine), in) != 0; nLine++) {\n        rc = sscanf(zLine, \"| page %d offset %d\", &j, &k);\n        if (rc == 2) {\n            iOffset = k;\n            continue;\n        }\n        if (cli_strncmp(zLine, \"| end \", 6) == 0) {\n            break;\n        }\n        rc = sscanf(zLine, \"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\", &j, &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &x[6], &x[7], &x[8], &x[9], &x[10], &x[11], &x[12], &x[13], &x[14], &x[15]);\n        if (rc == 17) {\n            k = iOffset + j;\n            if (k + 16 <= n && k >= 0) {\n                int ii;\n                for (ii = 0; ii < 16; ii++)\n                    a[k + ii] = x[ii] & 255;\n            }\n        }\n    }\n    *pnData = n;\n    if (in != p->in) {\n        fclose(in);\n    } else {\n        p->lineno = nLine;\n    }\n    return a;\n  readHexDb_error:\n    if (in != p->in) {\n        fclose(in);\n    } else {\n        while (fgets(zLine, sizeof (zLine), p->in) != 0)\n            {\n                nLine++;\n                if (cli_strncmp(zLine, \"| end \", 6) == 0)\n                    break;\n            }\n        p->lineno = nLine;\n    }\n    sqlite3_free(a);\n    fprintf(__stderrp, \"Error on line %d of --hexdb input\\n\", nLine);\n    return 0;\n}\n"
  },
  {
    "id": "shell.c#3663:1#base85",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int nb, nc, nv = sqlite3_value_bytes(av[0]);\n    int nvMax = sqlite3_limit(sqlite3_context_db_handle(context), 0, -1);\n    char *cBuf;\n    u8 *bBuf;\n    ((void)0);\n    switch (sqlite3_value_type(av[0])) {\n      case 4:\n        nb = nv;\n        nc = 5 * (nv / 4) + nv % 4 + nv / 64 + 1 + 2;\n        if (nvMax < nc) {\n            sqlite3_result_error(context, \"blob expanded to base85 too big\", -1);\n            return;\n        }\n        cBuf = sqlite3_malloc(nc);\n        if (!cBuf)\n            goto memFail;\n        bBuf = (u8 *)sqlite3_value_blob(av[0]);\n        nc = (int)(toBase85(bBuf, nb, cBuf, \"\\n\") - cBuf);\n        sqlite3_result_text(context, cBuf, nc, sqlite3_free);\n        break;\n      case 3:\n        nc = nv;\n        nb = 4 * (nv / 5) + nv % 5;\n        if (nvMax < nb) {\n            sqlite3_result_error(context, \"blob from base85 may be too big\", -1);\n            return;\n        } else if (nb < 1) {\n            nb = 1;\n        }\n        bBuf = sqlite3_malloc(nb);\n        if (!bBuf)\n            goto memFail;\n        cBuf = (char *)sqlite3_value_text(av[0]);\n        nb = (int)(fromBase85(cBuf, nc, bBuf) - bBuf);\n        sqlite3_result_blob(context, bBuf, nb, sqlite3_free);\n        break;\n      default:\n        sqlite3_result_error(context, \"base85 accepts only blob or text.\", -1);\n        return;\n    }\n    return;\n  memFail:\n    sqlite3_result_error(context, \"base85 OOM\", -1);\n}\n"
  },
  {
    "id": "shell.c#2997:1#decimalMulFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Decimal *pA = decimal_new(context, argv[0], 0, 0);\n    Decimal *pB = decimal_new(context, argv[1], 0, 0);\n    signed char *acc = 0;\n    int i, j, k;\n    int minFrac;\n    (void)(argc);\n    if (pA == 0 || pA->oom || pA->isNull || pB == 0 || pB->oom || pB->isNull) {\n        goto mul_end;\n    }\n    acc = sqlite3_malloc64(pA->nDigit + pB->nDigit + 2);\n    if (acc == 0) {\n        sqlite3_result_error_nomem(context);\n        goto mul_end;\n    }\n    __builtin___memset_chk(acc, 0, pA->nDigit + pB->nDigit + 2, __builtin_object_size(acc, 0));\n    minFrac = pA->nFrac;\n    if (pB->nFrac < minFrac)\n        minFrac = pB->nFrac;\n    for (i = pA->nDigit - 1; i >= 0; i--) {\n        signed char f = pA->a[i];\n        int carry = 0, x;\n        for (j = pB->nDigit - 1 , k = i + j + 3; j >= 0; j-- , k--) {\n            x = acc[k] + f * pB->a[j] + carry;\n            acc[k] = x % 10;\n            carry = x / 10;\n        }\n        x = acc[k] + carry;\n        acc[k] = x % 10;\n        acc[k - 1] += x / 10;\n    }\n    sqlite3_free(pA->a);\n    pA->a = acc;\n    acc = 0;\n    pA->nDigit += pB->nDigit + 2;\n    pA->nFrac += pB->nFrac;\n    pA->sign ^= pB->sign;\n    while (pA->nFrac > minFrac && pA->a[pA->nDigit - 1] == 0)\n        {\n            pA->nFrac--;\n            pA->nDigit--;\n        }\n    decimal_result(context, pA);\n  mul_end:\n    sqlite3_free(acc);\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
  },
  {
    "id": "shell.c#21122:1#tryToCloneSchema",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_stmt *pQuery = 0;\n    char *zQuery = 0;\n    int rc;\n    const unsigned char *zName;\n    const unsigned char *zSql;\n    char *zErrMsg = 0;\n    zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid ASC\", zWhere);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        fprintf(__stderrp, \"Error: (%d) %s on [%s]\\n\", sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db), zQuery);\n        goto end_schema_xfer;\n    }\n    while ((rc = sqlite3_step(pQuery)) == 100)\n        {\n            zName = sqlite3_column_text(pQuery, 0);\n            zSql = sqlite3_column_text(pQuery, 1);\n            if (zName == 0 || zSql == 0)\n                continue;\n            if (sqlite3_stricmp((char *)zName, \"sqlite_sequence\") != 0) {\n                printf(\"%s... \", zName);\n                fflush(__stdoutp);\n                sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n                if (zErrMsg) {\n                    fprintf(__stderrp, \"Error: %s\\nSQL: [%s]\\n\", zErrMsg, zSql);\n                    sqlite3_free(zErrMsg);\n                    zErrMsg = 0;\n                }\n            }\n            if (xForEach) {\n                xForEach(p, newDb, (const char *)zName);\n            }\n            printf(\"done\\n\");\n        }\n    if (rc != 101) {\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\", zWhere);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            fprintf(__stderrp, \"Error: (%d) %s on [%s]\\n\", sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db), zQuery);\n            goto end_schema_xfer;\n        }\n        while (sqlite3_step(pQuery) == 100)\n            {\n                zName = sqlite3_column_text(pQuery, 0);\n                zSql = sqlite3_column_text(pQuery, 1);\n                if (zName == 0 || zSql == 0)\n                    continue;\n                if (sqlite3_stricmp((char *)zName, \"sqlite_sequence\") != 0)\n                    continue;\n                printf(\"%s... \", zName);\n                fflush(__stdoutp);\n                sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n                if (zErrMsg) {\n                    fprintf(__stderrp, \"Error: %s\\nSQL: [%s]\\n\", zErrMsg, zSql);\n                    sqlite3_free(zErrMsg);\n                    zErrMsg = 0;\n                }\n                if (xForEach) {\n                    xForEach(p, newDb, (const char *)zName);\n                }\n                printf(\"done\\n\");\n            }\n    }\n  end_schema_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_free(zQuery);\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../tool/lemon.c#2793:1#eval_preprocessor_boolean",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    int neg = 0;\n    int res = 0;\n    int okTerm = 1;\n    int i;\n    for (i = 0; z[i] != 0; i++) {\n        if (isspace((unsigned char)(z[i])))\n            continue;\n        if (z[i] == '!') {\n            if (!okTerm)\n                goto pp_syntax_error;\n            neg = !neg;\n            continue;\n        }\n        if (z[i] == '|' && z[i + 1] == '|') {\n            if (okTerm)\n                goto pp_syntax_error;\n            if (res)\n                return 1;\n            i++;\n            okTerm = 1;\n            continue;\n        }\n        if (z[i] == '&' && z[i + 1] == '&') {\n            if (okTerm)\n                goto pp_syntax_error;\n            if (!res)\n                return 0;\n            i++;\n            okTerm = 1;\n            continue;\n        }\n        if (z[i] == '(') {\n            int k;\n            int n = 1;\n            if (!okTerm)\n                goto pp_syntax_error;\n            for (k = i + 1; z[k]; k++) {\n                if (z[k] == ')') {\n                    n--;\n                    if (n == 0) {\n                        z[k] = 0;\n                        res = eval_preprocessor_boolean(&z[i + 1], -1);\n                        z[k] = ')';\n                        if (res < 0) {\n                            i = i - res;\n                            goto pp_syntax_error;\n                        }\n                        i = k;\n                        break;\n                    }\n                } else if (z[k] == '(') {\n                    n++;\n                } else if (z[k] == 0) {\n                    i = k;\n                    goto pp_syntax_error;\n                }\n            }\n            if (neg) {\n                res = !res;\n                neg = 0;\n            }\n            okTerm = 0;\n            continue;\n        }\n        if (isalpha((unsigned char)(z[i]))) {\n            int j, k, n;\n            if (!okTerm)\n                goto pp_syntax_error;\n            for (k = i + 1; isalnum((unsigned char)(z[k])) || z[k] == '_'; k++) {\n            }\n            n = k - i;\n            res = 0;\n            for (j = 0; j < nDefine; j++) {\n                if (strncmp(azDefine[j], &z[i], n) == 0 && azDefine[j][n] == 0) {\n                    res = 1;\n                    break;\n                }\n            }\n            i = k - 1;\n            if (neg) {\n                res = !res;\n                neg = 0;\n            }\n            okTerm = 0;\n            continue;\n        }\n        goto pp_syntax_error;\n    }\n    return res;\n  pp_syntax_error:\n    if (lineno > 0) {\n        fprintf(__stderrp, \"%%if syntax error on line %d.\\n\", lineno);\n        fprintf(__stderrp, \"  %.*s <-- syntax error here\\n\", i + 1, z);\n        exit(1);\n    } else {\n        return -(i + 1);\n    }\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#1931:1#DbObjCmd",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    SqliteDb *pDb = (SqliteDb *)cd;\n    int choice;\n    int rc = 0;\n    static const char *DB_strs[] = {\"authorizer\", \"backup\", \"bind_fallback\", \"busy\", \"cache\", \"changes\", \"close\", \"collate\", \"collation_needed\", \"commit_hook\", \"complete\", \"config\", \"copy\", \"deserialize\", \"enable_load_extension\", \"errorcode\", \"erroroffset\", \"eval\", \"exists\", \"function\", \"incrblob\", \"interrupt\", \"last_insert_rowid\", \"nullvalue\", \"onecolumn\", \"preupdate\", \"profile\", \"progress\", \"rekey\", \"restore\", \"rollback_hook\", \"serialize\", \"status\", \"timeout\", \"total_changes\", \"trace\", \"trace_v2\", \"transaction\", \"unlock_notify\", \"update_hook\", \"version\", \"wal_hook\", 0};\n    enum DB_enum {\n        DB_AUTHORIZER,\n        DB_BACKUP,\n        DB_BIND_FALLBACK,\n        DB_BUSY,\n        DB_CACHE,\n        DB_CHANGES,\n        DB_CLOSE,\n        DB_COLLATE,\n        DB_COLLATION_NEEDED,\n        DB_COMMIT_HOOK,\n        DB_COMPLETE,\n        DB_CONFIG,\n        DB_COPY,\n        DB_DESERIALIZE,\n        DB_ENABLE_LOAD_EXTENSION,\n        DB_ERRORCODE,\n        DB_ERROROFFSET,\n        DB_EVAL,\n        DB_EXISTS,\n        DB_FUNCTION,\n        DB_INCRBLOB,\n        DB_INTERRUPT,\n        DB_LAST_INSERT_ROWID,\n        DB_NULLVALUE,\n        DB_ONECOLUMN,\n        DB_PREUPDATE,\n        DB_PROFILE,\n        DB_PROGRESS,\n        DB_REKEY,\n        DB_RESTORE,\n        DB_ROLLBACK_HOOK,\n        DB_SERIALIZE,\n        DB_STATUS,\n        DB_TIMEOUT,\n        DB_TOTAL_CHANGES,\n        DB_TRACE,\n        DB_TRACE_V2,\n        DB_TRANSACTION,\n        DB_UNLOCK_NOTIFY,\n        DB_UPDATE_HOOK,\n        DB_VERSION,\n        DB_WAL_HOOK\n    };\n    if (objc < 2) {\n        (tclStubsPtr->tcl_WrongNumArgs)(interp, 1, objv, \"SUBCOMMAND ...\");\n        return 1;\n    }\n    if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[1], DB_strs, \"option\", 0, &choice)) {\n        return 1;\n    }\n    switch ((enum DB_enum)choice) {\n      case DB_AUTHORIZER:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zAuth) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zAuth, (char *)0);\n                }\n            } else {\n                char *zAuth;\n                int len;\n                if (pDb->zAuth) {\n                    (tclStubsPtr->tcl_Free)(pDb->zAuth);\n                }\n                zAuth = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zAuth && len > 0) {\n                    pDb->zAuth = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zAuth, zAuth, len + 1, __builtin_object_size(pDb->zAuth, 0));\n                } else {\n                    pDb->zAuth = 0;\n                }\n                if (pDb->zAuth) {\n                    typedef int (*sqlite3_auth_cb)(void *, int, const char *, const char *, const char *, const char *);\n                    pDb->interp = interp;\n                    sqlite3_set_authorizer(pDb->db, (sqlite3_auth_cb)auth_callback, pDb);\n                } else {\n                    sqlite3_set_authorizer(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_BACKUP:\n        {\n            const char *zDestFile;\n            const char *zSrcDb;\n            sqlite3 *pDest;\n            sqlite3_backup *pBackup;\n            if (objc == 3) {\n                zSrcDb = \"main\";\n                zDestFile = (tclStubsPtr->tcl_GetString)(objv[2]);\n            } else if (objc == 4) {\n                zSrcDb = (tclStubsPtr->tcl_GetString)(objv[2]);\n                zDestFile = (tclStubsPtr->tcl_GetString)(objv[3]);\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? FILENAME\");\n                return 1;\n            }\n            rc = sqlite3_open_v2(zDestFile, &pDest, 2 | 4 | pDb->openFlags, 0);\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"cannot open target database: \", sqlite3_errmsg(pDest), (char *)0);\n                sqlite3_close(pDest);\n                return 1;\n            }\n            pBackup = sqlite3_backup_init(pDest, \"main\", pDb->db, zSrcDb);\n            if (pBackup == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"backup failed: \", sqlite3_errmsg(pDest), (char *)0);\n                sqlite3_close(pDest);\n                return 1;\n            }\n            while ((rc = sqlite3_backup_step(pBackup, 100)) == 0)\n                {\n                }\n            sqlite3_backup_finish(pBackup);\n            if (rc == 101) {\n                rc = 0;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"backup failed: \", sqlite3_errmsg(pDest), (char *)0);\n                rc = 1;\n            }\n            sqlite3_close(pDest);\n            break;\n        }\n      case DB_BIND_FALLBACK:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zBindFallback) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zBindFallback, (char *)0);\n                }\n            } else {\n                char *zCallback;\n                int len;\n                if (pDb->zBindFallback) {\n                    (tclStubsPtr->tcl_Free)(pDb->zBindFallback);\n                }\n                zCallback = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zCallback && len > 0) {\n                    pDb->zBindFallback = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zBindFallback, zCallback, len + 1, __builtin_object_size(pDb->zBindFallback, 0));\n                } else {\n                    pDb->zBindFallback = 0;\n                }\n            }\n            break;\n        }\n      case DB_BUSY:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"CALLBACK\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zBusy) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zBusy, (char *)0);\n                }\n            } else {\n                char *zBusy;\n                int len;\n                if (pDb->zBusy) {\n                    (tclStubsPtr->tcl_Free)(pDb->zBusy);\n                }\n                zBusy = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zBusy && len > 0) {\n                    pDb->zBusy = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zBusy, zBusy, len + 1, __builtin_object_size(pDb->zBusy, 0));\n                } else {\n                    pDb->zBusy = 0;\n                }\n                if (pDb->zBusy) {\n                    pDb->interp = interp;\n                    sqlite3_busy_handler(pDb->db, DbBusyHandler, pDb);\n                } else {\n                    sqlite3_busy_handler(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_CACHE:\n        {\n            char *subCmd;\n            int n;\n            if (objc <= 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 1, objv, \"cache option ?arg?\");\n                return 1;\n            }\n            subCmd = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            if (*subCmd == 'f' && strcmp(subCmd, \"flush\") == 0) {\n                if (objc != 3) {\n                    (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"flush\");\n                    return 1;\n                } else {\n                    flushStmtCache(pDb);\n                }\n            } else if (*subCmd == 's' && strcmp(subCmd, \"size\") == 0) {\n                if (objc != 4) {\n                    (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"size n\");\n                    return 1;\n                } else {\n                    if (1 == (tclStubsPtr->tcl_GetIntFromObj)(interp, objv[3], &n)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"cannot convert \\\"\", (tclStubsPtr->tcl_GetStringFromObj)(objv[3], 0), \"\\\" to integer\", (char *)0);\n                        return 1;\n                    } else {\n                        if (n < 0) {\n                            flushStmtCache(pDb);\n                            n = 0;\n                        } else if (n > 100) {\n                            n = 100;\n                        }\n                        pDb->maxStmt = n;\n                    }\n                }\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"bad option \\\"\", (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0), \"\\\": must be flush or size\", (char *)0);\n                return 1;\n            }\n            break;\n        }\n      case DB_CHANGES:\n        {\n            Tcl_Obj *pResult;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, sqlite3_changes64(pDb->db));\n            break;\n        }\n      case DB_CLOSE:\n        {\n            (tclStubsPtr->tcl_DeleteCommand)(interp, (tclStubsPtr->tcl_GetStringFromObj)(objv[0], 0));\n            break;\n        }\n      case DB_COLLATE:\n        {\n            SqlCollate *pCollate;\n            char *zName;\n            char *zScript;\n            int nScript;\n            if (objc != 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NAME SCRIPT\");\n                return 1;\n            }\n            zName = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            zScript = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], &nScript);\n            pCollate = (SqlCollate *)(tclStubsPtr->tcl_Alloc)(sizeof (*pCollate) + nScript + 1);\n            if (pCollate == 0)\n                return 1;\n            pCollate->interp = interp;\n            pCollate->pNext = pDb->pCollate;\n            pCollate->zScript = (char *)&pCollate[1];\n            pDb->pCollate = pCollate;\n            __builtin___memcpy_chk(pCollate->zScript, zScript, nScript + 1, __builtin_object_size(pCollate->zScript, 0));\n            if (sqlite3_create_collation(pDb->db, zName, 1, pCollate, tclSqlCollate)) {\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_errmsg(pDb->db), ((Tcl_FreeProc *)1));\n                return 1;\n            }\n            break;\n        }\n      case DB_COLLATION_NEEDED:\n        {\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SCRIPT\");\n                return 1;\n            }\n            if (pDb->pCollateNeeded) {\n                do {\n                    if (--(pDb->pCollateNeeded)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pDb->pCollateNeeded);\n                } while (0);\n            }\n            pDb->pCollateNeeded = (tclStubsPtr->tcl_DuplicateObj)(objv[2]);\n            ++(pDb->pCollateNeeded)->refCount;\n            sqlite3_collation_needed(pDb->db, pDb, tclCollateNeeded);\n            break;\n        }\n      case DB_COMMIT_HOOK:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zCommit) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zCommit, (char *)0);\n                }\n            } else {\n                const char *zCommit;\n                int len;\n                if (pDb->zCommit) {\n                    (tclStubsPtr->tcl_Free)(pDb->zCommit);\n                }\n                zCommit = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zCommit && len > 0) {\n                    pDb->zCommit = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zCommit, zCommit, len + 1, __builtin_object_size(pDb->zCommit, 0));\n                } else {\n                    pDb->zCommit = 0;\n                }\n                if (pDb->zCommit) {\n                    pDb->interp = interp;\n                    sqlite3_commit_hook(pDb->db, DbCommitHandler, pDb);\n                } else {\n                    sqlite3_commit_hook(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_COMPLETE:\n        {\n            Tcl_Obj *pResult;\n            int isComplete;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SQL\");\n                return 1;\n            }\n            isComplete = sqlite3_complete((tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0));\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetBooleanObj)(pResult, isComplete);\n            break;\n        }\n      case DB_CONFIG:\n        {\n            static const struct DbConfigChoices {\n                const char *zName;\n                int op;\n            } aDbConfig[] = {{\"defensive\", 1010}, {\"dqs_ddl\", 1014}, {\"dqs_dml\", 1013}, {\"enable_fkey\", 1002}, {\"enable_qpsg\", 1007}, {\"enable_trigger\", 1003}, {\"enable_view\", 1015}, {\"fts3_tokenizer\", 1004}, {\"legacy_alter_table\", 1012}, {\"legacy_file_format\", 1016}, {\"load_extension\", 1005}, {\"no_ckpt_on_close\", 1006}, {\"reset_database\", 1009}, {\"trigger_eqp\", 1008}, {\"trusted_schema\", 1017}, {\"writable_schema\", 1011}};\n            Tcl_Obj *pResult;\n            int ii;\n            if (objc > 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?OPTION? ?BOOLEAN?\");\n                return 1;\n            }\n            if (objc == 2) {\n                pResult = (tclStubsPtr->tcl_NewListObj)(0, 0);\n                for (ii = 0; ii < sizeof (aDbConfig) / sizeof (aDbConfig[0]); ii++) {\n                    int v = 0;\n                    sqlite3_db_config(pDb->db, aDbConfig[ii].op, -1, &v);\n                    (tclStubsPtr->tcl_ListObjAppendElement)(interp, pResult, (tclStubsPtr->tcl_NewStringObj)(aDbConfig[ii].zName, -1));\n                    (tclStubsPtr->tcl_ListObjAppendElement)(interp, pResult, (tclStubsPtr->tcl_NewIntObj)(v));\n                }\n            } else {\n                const char *zOpt = (tclStubsPtr->tcl_GetString)(objv[2]);\n                int onoff = -1;\n                int v = 0;\n                if (zOpt[0] == '-')\n                    zOpt++;\n                for (ii = 0; ii < sizeof (aDbConfig) / sizeof (aDbConfig[0]); ii++) {\n                    if (strcmp(aDbConfig[ii].zName, zOpt) == 0)\n                        break;\n                }\n                if (ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unknown config option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                    return 1;\n                }\n                if (objc == 4) {\n                    if ((tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[3], &onoff)) {\n                        return 1;\n                    }\n                }\n                sqlite3_db_config(pDb->db, aDbConfig[ii].op, onoff, &v);\n                pResult = (tclStubsPtr->tcl_NewIntObj)(v);\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, pResult);\n            break;\n        }\n      case DB_COPY:\n        {\n            char *zTable;\n            char *zFile;\n            char *zConflict;\n            sqlite3_stmt *pStmt;\n            int nCol;\n            int nByte;\n            int i, j;\n            int nSep;\n            int nNull;\n            char *zSql;\n            char *zLine;\n            char **azCol;\n            const char *zCommit;\n            FILE *in;\n            int lineno = 0;\n            char zLineNum[80];\n            Tcl_Obj *pResult;\n            const char *zSep;\n            const char *zNull;\n            if (objc < 5 || objc > 7) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\");\n                return 1;\n            }\n            if (objc >= 6) {\n                zSep = (tclStubsPtr->tcl_GetStringFromObj)(objv[5], 0);\n            } else {\n                zSep = \"\\t\";\n            }\n            if (objc >= 7) {\n                zNull = (tclStubsPtr->tcl_GetStringFromObj)(objv[6], 0);\n            } else {\n                zNull = \"\";\n            }\n            zConflict = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            zTable = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], 0);\n            zFile = (tclStubsPtr->tcl_GetStringFromObj)(objv[4], 0);\n            nSep = strlen30(zSep);\n            nNull = strlen30(zNull);\n            if (nSep == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: non-null separator required for copy\", (char *)0);\n                return 1;\n            }\n            if (strcmp(zConflict, \"rollback\") != 0 && strcmp(zConflict, \"abort\") != 0 && strcmp(zConflict, \"fail\") != 0 && strcmp(zConflict, \"ignore\") != 0 && strcmp(zConflict, \"replace\") != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \\\"\", zConflict, \"\\\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\", (char *)0);\n                return 1;\n            }\n            zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n            if (zSql == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: no such table: \", zTable, (char *)0);\n                return 1;\n            }\n            nByte = strlen30(zSql);\n            rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n            sqlite3_free(zSql);\n            if (rc) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                nCol = 0;\n            } else {\n                nCol = sqlite3_column_count(pStmt);\n            }\n            sqlite3_finalize(pStmt);\n            if (nCol == 0) {\n                return 1;\n            }\n            zSql = malloc(nByte + 50 + nCol * 2);\n            if (zSql == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: can't malloc()\", (char *)0);\n                return 1;\n            }\n            sqlite3_snprintf(nByte + 50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\", zConflict, zTable);\n            j = strlen30(zSql);\n            for (i = 1; i < nCol; i++) {\n                zSql[j++] = ',';\n                zSql[j++] = '?';\n            }\n            zSql[j++] = ')';\n            zSql[j] = 0;\n            rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n            free(zSql);\n            if (rc) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                sqlite3_finalize(pStmt);\n                return 1;\n            }\n            in = fopen(zFile, \"rb\");\n            if (in == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: cannot open file: \", zFile, (char *)0);\n                sqlite3_finalize(pStmt);\n                return 1;\n            }\n            azCol = malloc(sizeof (azCol[0]) * (nCol + 1));\n            if (azCol == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: can't malloc()\", (char *)0);\n                fclose(in);\n                return 1;\n            }\n            (void)sqlite3_exec(pDb->db, \"BEGIN\", 0, 0, 0);\n            zCommit = \"COMMIT\";\n            while ((zLine = local_getline(0, in)) != 0)\n                {\n                    char *z;\n                    lineno++;\n                    azCol[0] = zLine;\n                    for (i = 0 , z = zLine; *z; z++) {\n                        if (*z == zSep[0] && strncmp(z, zSep, nSep) == 0) {\n                            *z = 0;\n                            i++;\n                            if (i < nCol) {\n                                azCol[i] = &z[nSep];\n                                z += nSep - 1;\n                            }\n                        }\n                    }\n                    if (i + 1 != nCol) {\n                        char *zErr;\n                        int nErr = strlen30(zFile) + 200;\n                        zErr = malloc(nErr);\n                        if (zErr) {\n                            sqlite3_snprintf(nErr, zErr, \"Error: %s line %d: expected %d columns of data but found %d\", zFile, lineno, nCol, i + 1);\n                            (tclStubsPtr->tcl_AppendResult)(interp, zErr, (char *)0);\n                            free(zErr);\n                        }\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                    for (i = 0; i < nCol; i++) {\n                        if ((nNull > 0 && strcmp(azCol[i], zNull) == 0) || strlen30(azCol[i]) == 0) {\n                            sqlite3_bind_null(pStmt, i + 1);\n                        } else {\n                            sqlite3_bind_text(pStmt, i + 1, azCol[i], -1, ((sqlite3_destructor_type)0));\n                        }\n                    }\n                    sqlite3_step(pStmt);\n                    rc = sqlite3_reset(pStmt);\n                    free(zLine);\n                    if (rc != 0) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                }\n            free(azCol);\n            fclose(in);\n            sqlite3_finalize(pStmt);\n            (void)sqlite3_exec(pDb->db, zCommit, 0, 0, 0);\n            if (zCommit[0] == 'C') {\n                pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n                (tclStubsPtr->tcl_SetIntObj)(pResult, lineno);\n                rc = 0;\n            } else {\n                sqlite3_snprintf(sizeof (zLineNum), zLineNum, \"%d\", lineno);\n                (tclStubsPtr->tcl_AppendResult)(interp, \", failed while processing line: \", zLineNum, (char *)0);\n                rc = 1;\n            }\n            break;\n        }\n      case DB_DESERIALIZE:\n        {\n            const char *zSchema = 0;\n            Tcl_Obj *pValue = 0;\n            unsigned char *pBA;\n            unsigned char *pData;\n            int len, xrc;\n            sqlite3_int64 mxSize = 0;\n            int i;\n            int isReadonly = 0;\n            if (objc < 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? VALUE\");\n                rc = 1;\n                break;\n            }\n            for (i = 2; i < objc - 1; i++) {\n                const char *z = (tclStubsPtr->tcl_GetString)(objv[i]);\n                if (strcmp(z, \"-maxsize\") == 0 && i < objc - 2) {\n                    Tcl_WideInt x;\n                    rc = (tclStubsPtr->tcl_GetWideIntFromObj)(interp, objv[++i], &x);\n                    if (rc)\n                        goto deserialize_error;\n                    mxSize = x;\n                    continue;\n                }\n                if (strcmp(z, \"-readonly\") == 0 && i < objc - 2) {\n                    rc = (tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[++i], &isReadonly);\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (zSchema == 0 && i == objc - 2 && z[0] != '-') {\n                    zSchema = z;\n                    continue;\n                }\n                (tclStubsPtr->tcl_AppendResult)(interp, \"unknown option: \", z, (char *)0);\n                rc = 1;\n                goto deserialize_error;\n            }\n            pValue = objv[objc - 1];\n            pBA = (tclStubsPtr->tcl_GetByteArrayFromObj)(pValue, &len);\n            pData = sqlite3_malloc64(len);\n            if (pData == 0 && len > 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"out of memory\", (char *)0);\n                rc = 1;\n            } else {\n                int flags;\n                if (len > 0)\n                    __builtin___memcpy_chk(pData, pBA, len, __builtin_object_size(pData, 0));\n                if (isReadonly) {\n                    flags = 1 | 4;\n                } else {\n                    flags = 1 | 2;\n                }\n                xrc = sqlite3_deserialize(pDb->db, zSchema, pData, len, len, flags);\n                if (xrc) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unable to set MEMDB content\", (char *)0);\n                    rc = 1;\n                }\n                if (mxSize > 0) {\n                    sqlite3_file_control(pDb->db, zSchema, 36, &mxSize);\n                }\n            }\n          deserialize_error:\n            break;\n        }\n      case DB_ENABLE_LOAD_EXTENSION:\n        {\n            int onoff;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"BOOLEAN\");\n                return 1;\n            }\n            if ((tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[2], &onoff)) {\n                return 1;\n            }\n            sqlite3_enable_load_extension(pDb->db, onoff);\n            break;\n        }\n      case DB_ERRORCODE:\n        {\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(sqlite3_errcode(pDb->db)));\n            break;\n        }\n      case DB_ERROROFFSET:\n        {\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(sqlite3_error_offset(pDb->db)));\n            break;\n        }\n      case DB_EXISTS:\n      case DB_ONECOLUMN:\n        {\n            Tcl_Obj *pResult = 0;\n            DbEvalContext sEval;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SQL\");\n                return 1;\n            }\n            dbEvalInit(&sEval, pDb, objv[2], 0, 0);\n            rc = dbEvalStep(&sEval);\n            if (choice == DB_ONECOLUMN) {\n                if (rc == 0) {\n                    pResult = dbEvalColumnValue(&sEval, 0);\n                } else if (rc == 3) {\n                    (tclStubsPtr->tcl_ResetResult)(interp);\n                }\n            } else if (rc == 3 || rc == 0) {\n                pResult = (tclStubsPtr->tcl_NewBooleanObj)(rc == 0);\n            }\n            dbEvalFinalize(&sEval);\n            if (pResult)\n                (tclStubsPtr->tcl_SetObjResult)(interp, pResult);\n            if (rc == 3) {\n                rc = 0;\n            }\n            break;\n        }\n      case DB_EVAL:\n        {\n            int evalFlags = 0;\n            const char *zOpt;\n            while (objc > 3 && (zOpt = (tclStubsPtr->tcl_GetString)(objv[2])) != 0 && zOpt[0] == '-')\n                {\n                    if (strcmp(zOpt, \"-withoutnulls\") == 0) {\n                        evalFlags |= 1;\n                    } else {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"unknown option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                        return 1;\n                    }\n                    objc--;\n                    objv++;\n                }\n            if (objc < 3 || objc > 5) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\");\n                return 1;\n            }\n            if (objc == 3) {\n                DbEvalContext sEval;\n                Tcl_Obj *pRet = (tclStubsPtr->tcl_NewObj)();\n                ++(pRet)->refCount;\n                dbEvalInit(&sEval, pDb, objv[2], 0, 0);\n                while (0 == (rc = dbEvalStep(&sEval)))\n                    {\n                        int i;\n                        int nCol;\n                        dbEvalRowInfo(&sEval, &nCol, 0);\n                        for (i = 0; i < nCol; i++) {\n                            (tclStubsPtr->tcl_ListObjAppendElement)(interp, pRet, dbEvalColumnValue(&sEval, i));\n                        }\n                    }\n                dbEvalFinalize(&sEval);\n                if (rc == 3) {\n                    (tclStubsPtr->tcl_SetObjResult)(interp, pRet);\n                    rc = 0;\n                }\n                do {\n                    if (--(pRet)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pRet);\n                } while (0);\n            } else {\n                ClientData cd2[2];\n                DbEvalContext *p;\n                Tcl_Obj *pArray = 0;\n                Tcl_Obj *pScript;\n                if (objc >= 5 && *(char *)(tclStubsPtr->tcl_GetString)(objv[3])) {\n                    pArray = objv[3];\n                }\n                pScript = objv[objc - 1];\n                ++(pScript)->refCount;\n                p = (DbEvalContext *)(tclStubsPtr->tcl_Alloc)(sizeof(DbEvalContext));\n                dbEvalInit(p, pDb, objv[2], pArray, evalFlags);\n                cd2[0] = (void *)p;\n                cd2[1] = (void *)pScript;\n                rc = DbEvalNextCmd(cd2, interp, 0);\n            }\n            break;\n        }\n      case DB_FUNCTION:\n        {\n            int flags = 1;\n            SqlFunc *pFunc;\n            Tcl_Obj *pScript;\n            char *zName;\n            int nArg = -1;\n            int i;\n            int eType = 5;\n            if (objc < 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NAME ?SWITCHES? SCRIPT\");\n                return 1;\n            }\n            for (i = 3; i < (objc - 1); i++) {\n                const char *z = (tclStubsPtr->tcl_GetString)(objv[i]);\n                int n = strlen30(z);\n                if (n > 1 && strncmp(z, \"-argcount\", n) == 0) {\n                    if (i == (objc - 2)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"option requires an argument: \", z, (char *)0);\n                        return 1;\n                    }\n                    if ((tclStubsPtr->tcl_GetIntFromObj)(interp, objv[i + 1], &nArg))\n                        return 1;\n                    if (nArg < 0) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"number of arguments must be non-negative\", (char *)0);\n                        return 1;\n                    }\n                    i++;\n                } else if (n > 1 && strncmp(z, \"-deterministic\", n) == 0) {\n                    flags |= 2048;\n                } else if (n > 1 && strncmp(z, \"-directonly\", n) == 0) {\n                    flags |= 524288;\n                } else if (n > 1 && strncmp(z, \"-innocuous\", n) == 0) {\n                    flags |= 2097152;\n                } else if (n > 1 && strncmp(z, \"-returntype\", n) == 0) {\n                    const char *azType[] = {\"integer\", \"real\", \"text\", \"blob\", \"any\", 0};\n                    ((void)0);\n                    ((void)0);\n                    if (i == (objc - 2)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"option requires an argument: \", z, (char *)0);\n                        return 1;\n                    }\n                    i++;\n                    if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[i], azType, \"type\", 0, &eType)) {\n                        return 1;\n                    }\n                    eType++;\n                } else {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"bad option \\\"\", z, \"\\\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\", (char *)0);\n                    return 1;\n                }\n            }\n            pScript = objv[objc - 1];\n            zName = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            pFunc = findSqlFunc(pDb, zName);\n            if (pFunc == 0)\n                return 1;\n            if (pFunc->pScript) {\n                do {\n                    if (--(pFunc->pScript)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pFunc->pScript);\n                } while (0);\n            }\n            pFunc->pScript = pScript;\n            ++(pScript)->refCount;\n            pFunc->useEvalObjv = safeToUseEvalObjv(interp, pScript);\n            pFunc->eType = eType;\n            rc = sqlite3_create_function(pDb->db, zName, nArg, flags, pFunc, tclSqlFunc, 0, 0);\n            if (rc != 0) {\n                rc = 1;\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_errmsg(pDb->db), ((Tcl_FreeProc *)1));\n            }\n            break;\n        }\n      case DB_INCRBLOB:\n        {\n            int isReadonly = 0;\n            const char *zDb = \"main\";\n            const char *zTable;\n            const char *zColumn;\n            Tcl_WideInt iRow;\n            if (objc > 3 && strcmp((tclStubsPtr->tcl_GetString)(objv[2]), \"-readonly\") == 0) {\n                isReadonly = 1;\n            }\n            if (objc != (5 + isReadonly) && objc != (6 + isReadonly)) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?-readonly? ?DB? TABLE COLUMN ROWID\");\n                return 1;\n            }\n            if (objc == (6 + isReadonly)) {\n                zDb = (tclStubsPtr->tcl_GetString)(objv[2 + isReadonly]);\n            }\n            zTable = (tclStubsPtr->tcl_GetString)(objv[objc - 3]);\n            zColumn = (tclStubsPtr->tcl_GetString)(objv[objc - 2]);\n            rc = (tclStubsPtr->tcl_GetWideIntFromObj)(interp, objv[objc - 1], &iRow);\n            if (rc == 0) {\n                rc = createIncrblobChannel(interp, pDb, zDb, zTable, zColumn, (sqlite3_int64)iRow, isReadonly);\n            }\n            break;\n        }\n      case DB_INTERRUPT:\n        {\n            sqlite3_interrupt(pDb->db);\n            break;\n        }\n      case DB_NULLVALUE:\n        {\n            if (objc != 2 && objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NULLVALUE\");\n                return 1;\n            }\n            if (objc == 3) {\n                int len;\n                char *zNull = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (pDb->zNull) {\n                    (tclStubsPtr->tcl_Free)(pDb->zNull);\n                }\n                if (zNull && len > 0) {\n                    pDb->zNull = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zNull, zNull, len, __builtin_object_size(pDb->zNull, 0));\n                    pDb->zNull[len] = '\\x00';\n                } else {\n                    pDb->zNull = 0;\n                }\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewStringObj)(pDb->zNull, -1));\n            break;\n        }\n      case DB_LAST_INSERT_ROWID:\n        {\n            Tcl_Obj *pResult;\n            Tcl_WideInt rowid;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            rowid = sqlite3_last_insert_rowid(pDb->db);\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, rowid);\n            break;\n        }\n      case DB_PROGRESS:\n        {\n            if (objc == 2) {\n                if (pDb->zProgress) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zProgress, (char *)0);\n                }\n                sqlite3_progress_handler(pDb->db, 0, 0, 0);\n            } else if (objc == 4) {\n                char *zProgress;\n                int len;\n                int N;\n                if (0 != (tclStubsPtr->tcl_GetIntFromObj)(interp, objv[2], &N)) {\n                    return 1;\n                }\n                ;\n                if (pDb->zProgress) {\n                    (tclStubsPtr->tcl_Free)(pDb->zProgress);\n                }\n                zProgress = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], &len);\n                if (zProgress && len > 0) {\n                    pDb->zProgress = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zProgress, zProgress, len + 1, __builtin_object_size(pDb->zProgress, 0));\n                } else {\n                    pDb->zProgress = 0;\n                }\n                if (pDb->zProgress) {\n                    pDb->interp = interp;\n                    sqlite3_progress_handler(pDb->db, N, DbProgressHandler, pDb);\n                } else {\n                    sqlite3_progress_handler(pDb->db, 0, 0, 0);\n                }\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"N CALLBACK\");\n                return 1;\n            }\n            break;\n        }\n      case DB_PROFILE:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zProfile) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zProfile, (char *)0);\n                }\n            } else {\n                char *zProfile;\n                int len;\n                if (pDb->zProfile) {\n                    (tclStubsPtr->tcl_Free)(pDb->zProfile);\n                }\n                zProfile = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zProfile && len > 0) {\n                    pDb->zProfile = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zProfile, zProfile, len + 1, __builtin_object_size(pDb->zProfile, 0));\n                } else {\n                    pDb->zProfile = 0;\n                }\n                if (pDb->zProfile) {\n                    pDb->interp = interp;\n                    sqlite3_profile(pDb->db, DbProfileHandler, pDb);\n                } else {\n                    sqlite3_profile(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_REKEY:\n        {\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"KEY\");\n                return 1;\n            }\n            break;\n        }\n      case DB_RESTORE:\n        {\n            const char *zSrcFile;\n            const char *zDestDb;\n            sqlite3 *pSrc;\n            sqlite3_backup *pBackup;\n            int nTimeout = 0;\n            if (objc == 3) {\n                zDestDb = \"main\";\n                zSrcFile = (tclStubsPtr->tcl_GetString)(objv[2]);\n            } else if (objc == 4) {\n                zDestDb = (tclStubsPtr->tcl_GetString)(objv[2]);\n                zSrcFile = (tclStubsPtr->tcl_GetString)(objv[3]);\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? FILENAME\");\n                return 1;\n            }\n            rc = sqlite3_open_v2(zSrcFile, &pSrc, 1 | pDb->openFlags, 0);\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"cannot open source database: \", sqlite3_errmsg(pSrc), (char *)0);\n                sqlite3_close(pSrc);\n                return 1;\n            }\n            pBackup = sqlite3_backup_init(pDb->db, zDestDb, pSrc, \"main\");\n            if (pBackup == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: \", sqlite3_errmsg(pDb->db), (char *)0);\n                sqlite3_close(pSrc);\n                return 1;\n            }\n            while ((rc = sqlite3_backup_step(pBackup, 100)) == 0 || rc == 5)\n                {\n                    if (rc == 5) {\n                        if (nTimeout++ >= 3)\n                            break;\n                        sqlite3_sleep(100);\n                    }\n                }\n            sqlite3_backup_finish(pBackup);\n            if (rc == 101) {\n                rc = 0;\n            } else if (rc == 5 || rc == 6) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: source database busy\", (char *)0);\n                rc = 1;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: \", sqlite3_errmsg(pDb->db), (char *)0);\n                rc = 1;\n            }\n            sqlite3_close(pSrc);\n            break;\n        }\n      case DB_SERIALIZE:\n        {\n            const char *zSchema = objc >= 3 ? (tclStubsPtr->tcl_GetString)(objv[2]) : \"main\";\n            sqlite3_int64 sz = 0;\n            unsigned char *pData;\n            if (objc != 2 && objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE?\");\n                rc = 1;\n            } else {\n                int needFree;\n                pData = sqlite3_serialize(pDb->db, zSchema, &sz, 1);\n                if (pData) {\n                    needFree = 0;\n                } else {\n                    pData = sqlite3_serialize(pDb->db, zSchema, &sz, 0);\n                    needFree = 1;\n                }\n                (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewByteArrayObj)(pData, sz));\n                if (needFree)\n                    sqlite3_free(pData);\n            }\n            break;\n        }\n      case DB_STATUS:\n        {\n            int v;\n            const char *zOp;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"(step|sort|autoindex)\");\n                return 1;\n            }\n            zOp = (tclStubsPtr->tcl_GetString)(objv[2]);\n            if (strcmp(zOp, \"step\") == 0) {\n                v = pDb->nStep;\n            } else if (strcmp(zOp, \"sort\") == 0) {\n                v = pDb->nSort;\n            } else if (strcmp(zOp, \"autoindex\") == 0) {\n                v = pDb->nIndex;\n            } else if (strcmp(zOp, \"vmstep\") == 0) {\n                v = pDb->nVMStep;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"bad argument: should be autoindex, step, sort or vmstep\", (char *)0);\n                return 1;\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(v));\n            break;\n        }\n      case DB_TIMEOUT:\n        {\n            int ms;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"MILLISECONDS\");\n                return 1;\n            }\n            if ((tclStubsPtr->tcl_GetIntFromObj)(interp, objv[2], &ms))\n                return 1;\n            sqlite3_busy_timeout(pDb->db, ms);\n            break;\n        }\n      case DB_TOTAL_CHANGES:\n        {\n            Tcl_Obj *pResult;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, sqlite3_total_changes64(pDb->db));\n            break;\n        }\n      case DB_TRACE:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zTrace) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zTrace, (char *)0);\n                }\n            } else {\n                char *zTrace;\n                int len;\n                if (pDb->zTrace) {\n                    (tclStubsPtr->tcl_Free)(pDb->zTrace);\n                }\n                zTrace = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zTrace && len > 0) {\n                    pDb->zTrace = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zTrace, zTrace, len + 1, __builtin_object_size(pDb->zTrace, 0));\n                } else {\n                    pDb->zTrace = 0;\n                }\n                if (pDb->zTrace) {\n                    pDb->interp = interp;\n                    sqlite3_trace(pDb->db, DbTraceHandler, pDb);\n                } else {\n                    sqlite3_trace(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRACE_V2:\n        {\n            if (objc > 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK? ?MASK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zTraceV2) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zTraceV2, (char *)0);\n                }\n            } else {\n                char *zTraceV2;\n                int len;\n                Tcl_WideInt wMask = 0;\n                if (objc == 4) {\n                    static const char *TTYPE_strs[] = {\"statement\", \"profile\", \"row\", \"close\", 0};\n                    enum TTYPE_enum {\n                        TTYPE_STMT,\n                        TTYPE_PROFILE,\n                        TTYPE_ROW,\n                        TTYPE_CLOSE\n                    };\n                    int i;\n                    if (0 != (tclStubsPtr->tcl_ListObjLength)(interp, objv[3], &len)) {\n                        return 1;\n                    }\n                    for (i = 0; i < len; i++) {\n                        Tcl_Obj *pObj;\n                        int ttype;\n                        if (0 != (tclStubsPtr->tcl_ListObjIndex)(interp, objv[3], i, &pObj)) {\n                            return 1;\n                        }\n                        if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, pObj, TTYPE_strs, \"trace type\", 0, &ttype) != 0) {\n                            Tcl_WideInt wType;\n                            Tcl_Obj *pError = (tclStubsPtr->tcl_DuplicateObj)((tclStubsPtr->tcl_GetObjResult)(interp));\n                            ++(pError)->refCount;\n                            if (0 == (tclStubsPtr->tcl_GetWideIntFromObj)(interp, pObj, &wType)) {\n                                do {\n                                    if (--(pError)->refCount <= 0)\n                                        (tclStubsPtr->tclFreeObj)(pError);\n                                } while (0);\n                                wMask |= wType;\n                            } else {\n                                (tclStubsPtr->tcl_SetObjResult)(interp, pError);\n                                do {\n                                    if (--(pError)->refCount <= 0)\n                                        (tclStubsPtr->tclFreeObj)(pError);\n                                } while (0);\n                                return 1;\n                            }\n                        } else {\n                            switch ((enum TTYPE_enum)ttype) {\n                              case TTYPE_STMT:\n                                wMask |= 1;\n                                break;\n                              case TTYPE_PROFILE:\n                                wMask |= 2;\n                                break;\n                              case TTYPE_ROW:\n                                wMask |= 4;\n                                break;\n                              case TTYPE_CLOSE:\n                                wMask |= 8;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    wMask = 1;\n                }\n                if (pDb->zTraceV2) {\n                    (tclStubsPtr->tcl_Free)(pDb->zTraceV2);\n                }\n                zTraceV2 = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zTraceV2 && len > 0) {\n                    pDb->zTraceV2 = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zTraceV2, zTraceV2, len + 1, __builtin_object_size(pDb->zTraceV2, 0));\n                } else {\n                    pDb->zTraceV2 = 0;\n                }\n                if (pDb->zTraceV2) {\n                    pDb->interp = interp;\n                    sqlite3_trace_v2(pDb->db, (unsigned int)wMask, DbTraceV2Handler, pDb);\n                } else {\n                    sqlite3_trace_v2(pDb->db, 0, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRANSACTION:\n        {\n            Tcl_Obj *pScript;\n            const char *zBegin = \"SAVEPOINT _tcl_transaction\";\n            if (objc != 3 && objc != 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"[TYPE] SCRIPT\");\n                return 1;\n            }\n            if (pDb->nTransaction == 0 && objc == 4) {\n                static const char *TTYPE_strs[] = {\"deferred\", \"exclusive\", \"immediate\", 0};\n                enum TTYPE_enum {\n                    TTYPE_DEFERRED,\n                    TTYPE_EXCLUSIVE,\n                    TTYPE_IMMEDIATE\n                };\n                int ttype;\n                if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[2], TTYPE_strs, \"transaction type\", 0, &ttype)) {\n                    return 1;\n                }\n                switch ((enum TTYPE_enum)ttype) {\n                  case TTYPE_DEFERRED:\n                    ;\n                    break;\n                  case TTYPE_EXCLUSIVE:\n                    zBegin = \"BEGIN EXCLUSIVE\";\n                    break;\n                  case TTYPE_IMMEDIATE:\n                    zBegin = \"BEGIN IMMEDIATE\";\n                    break;\n                }\n            }\n            pScript = objv[objc - 1];\n            pDb->disableAuth++;\n            rc = sqlite3_exec(pDb->db, zBegin, 0, 0, 0);\n            pDb->disableAuth--;\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, sqlite3_errmsg(pDb->db), (char *)0);\n                return 1;\n            }\n            pDb->nTransaction++;\n            addDatabaseRef(pDb);\n            if (0) {\n                (void)0;\n                (void)0;\n            } else {\n                rc = DbTransPostCmd(&cd, interp, (tclStubsPtr->tcl_EvalObjEx)(interp, pScript, 0));\n            }\n            break;\n        }\n      case DB_UNLOCK_NOTIFY:\n        {\n            (tclStubsPtr->tcl_AppendResult)(interp, \"unlock_notify not available in this build\", (char *)0);\n            rc = 1;\n            break;\n        }\n      case DB_PREUPDATE:\n        {\n            (tclStubsPtr->tcl_AppendResult)(interp, \"preupdate_hook was omitted at compile-time\", (char *)0);\n            rc = 1;\n            break;\n        }\n      case DB_WAL_HOOK:\n      case DB_UPDATE_HOOK:\n      case DB_ROLLBACK_HOOK:\n        {\n            Tcl_Obj **ppHook = 0;\n            if (choice == DB_WAL_HOOK)\n                ppHook = &pDb->pWalHook;\n            if (choice == DB_UPDATE_HOOK)\n                ppHook = &pDb->pUpdateHook;\n            if (choice == DB_ROLLBACK_HOOK)\n                ppHook = &pDb->pRollbackHook;\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?SCRIPT?\");\n                return 1;\n            }\n            DbHookCmd(interp, pDb, (objc == 3 ? objv[2] : 0), ppHook);\n            break;\n        }\n      case DB_VERSION:\n        {\n            int i;\n            for (i = 2; i < objc; i++) {\n                const char *zArg = (tclStubsPtr->tcl_GetString)(objv[i]);\n                {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unknown argument: \", zArg, (char *)0);\n                    return 1;\n                }\n            }\n            if (i == 2) {\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_libversion(), ((Tcl_FreeProc *)0));\n            }\n            break;\n        }\n    }\n    return rc;\n}\n"
  }
]
