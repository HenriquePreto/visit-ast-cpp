[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzlib.c#409:1#BZ2_bzCompress",
    "nobreaks": 1,
    "body": "{\n    Bool progress;\n    EState *s;\n    if (strm == ((void *)0))\n        return (-2);\n    s = strm->state;\n    if (s == ((void *)0))\n        return (-2);\n    if (s->strm != strm)\n        return (-2);\n  preswitch:\n    switch (s->mode) {\n      case 1:\n        return (-1);\n      case 2:\n        if (action == 0) {\n            progress = handle_compress(strm);\n            return progress ? 1 : (-2);\n        } else if (action == 1) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 3;\n            goto preswitch;\n        } else if (action == 2) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 4;\n            goto preswitch;\n        } else\n            return (-2);\n      case 3:\n        if (action != 1)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 2;\n        s->mode = 2;\n        return 1;\n      case 4:\n        if (action != 2)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (!progress)\n            return (-1);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 3;\n        s->mode = 1;\n        return 4;\n    }\n    return 0;\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/decompress.c#106:1#BZ2_decompress",
    "nobreaks": 1,
    "body": "{\n    UChar uc;\n    Int32 retVal;\n    Int32 minLen, maxLen;\n    bz_stream *strm = s->strm;\n    Int32 i;\n    Int32 j;\n    Int32 t;\n    Int32 alphaSize;\n    Int32 nGroups;\n    Int32 nSelectors;\n    Int32 EOB;\n    Int32 groupNo;\n    Int32 groupPos;\n    Int32 nextSym;\n    Int32 nblockMAX;\n    Int32 nblock;\n    Int32 es;\n    Int32 N;\n    Int32 curr;\n    Int32 zt;\n    Int32 zn;\n    Int32 zvec;\n    Int32 zj;\n    Int32 gSel;\n    Int32 gMinlen;\n    Int32 *gLimit;\n    Int32 *gBase;\n    Int32 *gPerm;\n    if (s->state == 10) {\n        s->save_i = 0;\n        s->save_j = 0;\n        s->save_t = 0;\n        s->save_alphaSize = 0;\n        s->save_nGroups = 0;\n        s->save_nSelectors = 0;\n        s->save_EOB = 0;\n        s->save_groupNo = 0;\n        s->save_groupPos = 0;\n        s->save_nextSym = 0;\n        s->save_nblockMAX = 0;\n        s->save_nblock = 0;\n        s->save_es = 0;\n        s->save_N = 0;\n        s->save_curr = 0;\n        s->save_zt = 0;\n        s->save_zn = 0;\n        s->save_zvec = 0;\n        s->save_zj = 0;\n        s->save_gSel = 0;\n        s->save_gMinlen = 0;\n        s->save_gLimit = ((void *)0);\n        s->save_gBase = ((void *)0);\n        s->save_gPerm = ((void *)0);\n    }\n    i = s->save_i;\n    j = s->save_j;\n    t = s->save_t;\n    alphaSize = s->save_alphaSize;\n    nGroups = s->save_nGroups;\n    nSelectors = s->save_nSelectors;\n    EOB = s->save_EOB;\n    groupNo = s->save_groupNo;\n    groupPos = s->save_groupPos;\n    nextSym = s->save_nextSym;\n    nblockMAX = s->save_nblockMAX;\n    nblock = s->save_nblock;\n    es = s->save_es;\n    N = s->save_N;\n    curr = s->save_curr;\n    zt = s->save_zt;\n    zn = s->save_zn;\n    zvec = s->save_zvec;\n    zj = s->save_zj;\n    gSel = s->save_gSel;\n    gMinlen = s->save_gMinlen;\n    gLimit = s->save_gLimit;\n    gBase = s->save_gBase;\n    gPerm = s->save_gPerm;\n    retVal = 0;\n    switch (s->state) {\n      case 10:\n        s->state = 10;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 66) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 11:\n        s->state = 11;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 90) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 12:\n        s->state = 12;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (uc != 104) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 13:\n        s->state = 13;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    s->blockSize100k = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (s->blockSize100k < (48 + 1) || s->blockSize100k > (48 + 9)) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->blockSize100k -= 48;\n        if (s->smallDecompress) {\n            s->ll16 = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(UInt16)), 1);\n            s->ll4 = (strm->bzalloc)(strm->opaque, (((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)), 1);\n            if (s->ll16 == ((void *)0) || s->ll4 == ((void *)0)) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        } else {\n            s->tt = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(Int32)), 1);\n            if (s->tt == ((void *)0)) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n      case 14:\n        s->state = 14;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc == 23)\n            goto endhdr_2;\n        if (uc != 49) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 15:\n        s->state = 15;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 65) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 16:\n        s->state = 16;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 17:\n        s->state = 17;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 38) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 18:\n        s->state = 18;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 83) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 19:\n        s->state = 19;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->currBlockNo++;\n        if (s->verbosity >= 2)\n            fprintf(__stderrp, \"\\n    [%d: huff+mtf \", s->currBlockNo);\n        s->storedBlockCRC = 0;\n      case 20:\n        s->state = 20;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 21:\n        s->state = 21;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 22:\n        s->state = 22;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 23:\n        s->state = 23;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 24:\n        s->state = 24;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 1) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                    s->bsLive -= 1;\n                    s->blockRandomised = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = 0;\n      case 25:\n        s->state = 25;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 26:\n        s->state = 26;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 27:\n        s->state = 27;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n        if (s->origPtr < 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        if (s->origPtr > 10 + 100000 * s->blockSize100k) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < 16; i++) {\n          case 28:\n            s->state = 28;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 1) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                        s->bsLive -= 1;\n                        uc = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            if (uc == 1)\n                s->inUse16[i] = ((Bool)1);\n            else\n                s->inUse16[i] = ((Bool)0);\n        }\n        for (i = 0; i < 256; i++)\n            s->inUse[i] = ((Bool)0);\n        for (i = 0; i < 16; i++)\n            if (s->inUse16[i])\n                for (j = 0; j < 16; j++) {\n                  case 29:\n                    s->state = 29;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 1)\n                        s->inUse[i * 16 + j] = ((Bool)1);\n                }\n        makeMaps_d(s);\n        if (s->nInUse == 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        alphaSize = s->nInUse + 2;\n      case 30:\n        s->state = 30;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 3) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 3)) & ((1 << 3) - 1);\n                    s->bsLive -= 3;\n                    nGroups = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nGroups < 2 || nGroups > 6) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 31:\n        s->state = 31;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 15) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 15)) & ((1 << 15) - 1);\n                    s->bsLive -= 15;\n                    nSelectors = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nSelectors < 1) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < nSelectors; i++) {\n            j = 0;\n            while (((Bool)1))\n                {\n                  case 32:\n                    s->state = 32;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 0)\n                        break;\n                    j++;\n                    if (j >= nGroups) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                }\n            if (i < (2 + (900000 / 50)))\n                s->selectorMtf[i] = j;\n        }\n        if (nSelectors > (2 + (900000 / 50)))\n            nSelectors = (2 + (900000 / 50));\n        {\n            UChar pos[6], tmp, v;\n            for (v = 0; v < nGroups; v++)\n                pos[v] = v;\n            for (i = 0; i < nSelectors; i++) {\n                v = s->selectorMtf[i];\n                tmp = pos[v];\n                while (v > 0)\n                    {\n                        pos[v] = pos[v - 1];\n                        v--;\n                    }\n                pos[0] = tmp;\n                s->selector[i] = tmp;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n          case 33:\n            s->state = 33;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 5) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 5)) & ((1 << 5) - 1);\n                        s->bsLive -= 5;\n                        curr = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            for (i = 0; i < alphaSize; i++) {\n                while (((Bool)1))\n                    {\n                        if (curr < 1 || curr > 20) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                      case 34:\n                        s->state = 34;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            break;\n                      case 35:\n                        s->state = 35;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            curr++;\n                        else\n                            curr--;\n                    }\n                s->len[t][i] = curr;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (s->len[t][i] > maxLen)\n                    maxLen = s->len[t][i];\n                if (s->len[t][i] < minLen)\n                    minLen = s->len[t][i];\n            }\n            BZ2_hbCreateDecodeTables(&(s->limit[t][0]), &(s->base[t][0]), &(s->perm[t][0]), &(s->len[t][0]), minLen, maxLen, alphaSize);\n            s->minLens[t] = minLen;\n        }\n        EOB = s->nInUse + 1;\n        nblockMAX = 100000 * s->blockSize100k;\n        groupNo = -1;\n        groupPos = 0;\n        for (i = 0; i <= 255; i++)\n            s->unzftab[i] = 0;\n        {\n            Int32 ii, jj, kk;\n            kk = 4096 - 1;\n            for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                for (jj = 16 - 1; jj >= 0; jj--) {\n                    s->mtfa[kk] = (UChar)(ii * 16 + jj);\n                    kk--;\n                }\n                s->mtfbase[ii] = kk + 1;\n            }\n        }\n        nblock = 0;\n        {\n            if (groupPos == 0) {\n                groupNo++;\n                if (groupNo >= nSelectors) {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                groupPos = 50;\n                gSel = s->selector[groupNo];\n                gMinlen = s->minLens[gSel];\n                gLimit = &(s->limit[gSel][0]);\n                gPerm = &(s->perm[gSel][0]);\n                gBase = &(s->base[gSel][0]);\n            }\n            groupPos--;\n            zn = gMinlen;\n          case 36:\n            s->state = 36;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= zn) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                        s->bsLive -= zn;\n                        zvec = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            while (1)\n                {\n                    if (zn > 20) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    if (zvec <= gLimit[zn])\n                        break;\n                    zn++;\n                  case 37:\n                    s->state = 37;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                zj = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    zvec = (zvec << 1) | zj;\n                }\n            ;\n            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n            nextSym = gPerm[zvec - gBase[zn]];\n        }\n        ;\n        while (((Bool)1))\n            {\n                if (nextSym == EOB)\n                    break;\n                if (nextSym == 0 || nextSym == 1) {\n                    es = -1;\n                    N = 1;\n                    do {\n                        if (N >= 2 * 1024 * 1024) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        if (nextSym == 0)\n                            es = es + (0 + 1) * N;\n                        else if (nextSym == 1)\n                            es = es + (1 + 1) * N;\n                        N = N * 2;\n                        {\n                            if (groupPos == 0) {\n                                groupNo++;\n                                if (groupNo >= nSelectors) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                groupPos = 50;\n                                gSel = s->selector[groupNo];\n                                gMinlen = s->minLens[gSel];\n                                gLimit = &(s->limit[gSel][0]);\n                                gPerm = &(s->perm[gSel][0]);\n                                gBase = &(s->base[gSel][0]);\n                            }\n                            groupPos--;\n                            zn = gMinlen;\n                          case 38:\n                            s->state = 38;\n                            while (((Bool)1))\n                                {\n                                    if (s->bsLive >= zn) {\n                                        UInt32 v;\n                                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                        s->bsLive -= zn;\n                                        zvec = v;\n                                        break;\n                                    }\n                                    if (s->strm->avail_in == 0) {\n                                        retVal = 0;\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                    s->bsLive += 8;\n                                    s->strm->next_in++;\n                                    s->strm->avail_in--;\n                                    s->strm->total_in_lo32++;\n                                    if (s->strm->total_in_lo32 == 0)\n                                        s->strm->total_in_hi32++;\n                                }\n                            ;\n                            while (1)\n                                {\n                                    if (zn > 20) {\n                                        retVal = (-4);\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    if (zvec <= gLimit[zn])\n                                        break;\n                                    zn++;\n                                  case 39:\n                                    s->state = 39;\n                                    while (((Bool)1))\n                                        {\n                                            if (s->bsLive >= 1) {\n                                                UInt32 v;\n                                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                                s->bsLive -= 1;\n                                                zj = v;\n                                                break;\n                                            }\n                                            if (s->strm->avail_in == 0) {\n                                                retVal = 0;\n                                                goto save_state_and_return;\n                                            }\n                                            ;\n                                            ;\n                                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                            s->bsLive += 8;\n                                            s->strm->next_in++;\n                                            s->strm->avail_in--;\n                                            s->strm->total_in_lo32++;\n                                            if (s->strm->total_in_lo32 == 0)\n                                                s->strm->total_in_hi32++;\n                                        }\n                                    ;\n                                    zvec = (zvec << 1) | zj;\n                                }\n                            ;\n                            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            nextSym = gPerm[zvec - gBase[zn]];\n                        }\n                        ;\n                    } while (nextSym == 0 || nextSym == 1);\n                    es++;\n                    uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];\n                    s->unzftab[uc] += es;\n                    if (s->smallDecompress)\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->ll16[nblock] = (UInt16)uc;\n                                nblock++;\n                                es--;\n                            }\n                    else\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->tt[nblock] = (UInt32)uc;\n                                nblock++;\n                                es--;\n                            }\n                    ;\n                    continue;\n                } else {\n                    if (nblock >= nblockMAX) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    {\n                        Int32 ii, jj, kk, pp, lno, off;\n                        UInt32 nn;\n                        nn = (UInt32)(nextSym - 1);\n                        if (nn < 16) {\n                            pp = s->mtfbase[0];\n                            uc = s->mtfa[pp + nn];\n                            while (nn > 3)\n                                {\n                                    Int32 z = pp + nn;\n                                    s->mtfa[(z)] = s->mtfa[(z) - 1];\n                                    s->mtfa[(z) - 1] = s->mtfa[(z) - 2];\n                                    s->mtfa[(z) - 2] = s->mtfa[(z) - 3];\n                                    s->mtfa[(z) - 3] = s->mtfa[(z) - 4];\n                                    nn -= 4;\n                                }\n                            while (nn > 0)\n                                {\n                                    s->mtfa[(pp + nn)] = s->mtfa[(pp + nn) - 1];\n                                    nn--;\n                                }\n                            ;\n                            s->mtfa[pp] = uc;\n                        } else {\n                            lno = nn / 16;\n                            off = nn % 16;\n                            pp = s->mtfbase[lno] + off;\n                            uc = s->mtfa[pp];\n                            while (pp > s->mtfbase[lno])\n                                {\n                                    s->mtfa[pp] = s->mtfa[pp - 1];\n                                    pp--;\n                                }\n                            ;\n                            s->mtfbase[lno]++;\n                            while (lno > 0)\n                                {\n                                    s->mtfbase[lno]--;\n                                    s->mtfa[s->mtfbase[lno]] = s->mtfa[s->mtfbase[lno - 1] + 16 - 1];\n                                    lno--;\n                                }\n                            s->mtfbase[0]--;\n                            s->mtfa[s->mtfbase[0]] = uc;\n                            if (s->mtfbase[0] == 0) {\n                                kk = 4096 - 1;\n                                for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                                    for (jj = 16 - 1; jj >= 0; jj--) {\n                                        s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                                        kk--;\n                                    }\n                                    s->mtfbase[ii] = kk + 1;\n                                }\n                            }\n                        }\n                    }\n                    s->unzftab[s->seqToUnseq[uc]]++;\n                    if (s->smallDecompress)\n                        s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]);\n                    else\n                        s->tt[nblock] = (UInt32)(s->seqToUnseq[uc]);\n                    nblock++;\n                    {\n                        if (groupPos == 0) {\n                            groupNo++;\n                            if (groupNo >= nSelectors) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            groupPos = 50;\n                            gSel = s->selector[groupNo];\n                            gMinlen = s->minLens[gSel];\n                            gLimit = &(s->limit[gSel][0]);\n                            gPerm = &(s->perm[gSel][0]);\n                            gBase = &(s->base[gSel][0]);\n                        }\n                        groupPos--;\n                        zn = gMinlen;\n                      case 40:\n                        s->state = 40;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= zn) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                    s->bsLive -= zn;\n                                    zvec = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        while (1)\n                            {\n                                if (zn > 20) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                if (zvec <= gLimit[zn])\n                                    break;\n                                zn++;\n                              case 41:\n                                s->state = 41;\n                                while (((Bool)1))\n                                    {\n                                        if (s->bsLive >= 1) {\n                                            UInt32 v;\n                                            v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                            s->bsLive -= 1;\n                                            zj = v;\n                                            break;\n                                        }\n                                        if (s->strm->avail_in == 0) {\n                                            retVal = 0;\n                                            goto save_state_and_return;\n                                        }\n                                        ;\n                                        ;\n                                        s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                        s->bsLive += 8;\n                                        s->strm->next_in++;\n                                        s->strm->avail_in--;\n                                        s->strm->total_in_lo32++;\n                                        if (s->strm->total_in_lo32 == 0)\n                                            s->strm->total_in_hi32++;\n                                    }\n                                ;\n                                zvec = (zvec << 1) | zj;\n                            }\n                        ;\n                        if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        nextSym = gPerm[zvec - gBase[zn]];\n                    }\n                    ;\n                    continue;\n                }\n            }\n        if (s->origPtr < 0 || s->origPtr >= nblock) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i <= 255; i++) {\n            if (s->unzftab[i] < 0 || s->unzftab[i] > nblock) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n        s->cftab[0] = 0;\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] = s->unzftab[i - 1];\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] += s->cftab[i - 1];\n        for (i = 0; i <= 256; i++) {\n            if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        for (i = 1; i <= 256; i++) {\n            if (s->cftab[i - 1] > s->cftab[i]) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        s->state_out_len = 0;\n        s->state_out_ch = 0;\n        {\n            s->calculatedBlockCRC = 4294967295L;\n        }\n        ;\n        s->state = 2;\n        if (s->verbosity >= 2)\n            fprintf(__stderrp, \"rt+rld\");\n        if (s->smallDecompress) {\n            for (i = 0; i <= 256; i++)\n                s->cftabCopy[i] = s->cftab[i];\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->ll16[i]);\n                {\n                    s->ll16[i] = (UInt16)(s->cftabCopy[uc] & 65535);\n                    {\n                        if (((i) & 1) == 0)\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 240) | (s->cftabCopy[uc] >> 16);\n                        else\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 15) | ((s->cftabCopy[uc] >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                s->cftabCopy[uc]++;\n            }\n            i = s->origPtr;\n            j = (((UInt32)s->ll16[i]) | (((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 4)) & 15) << 16));\n            do {\n                Int32 tmp = (((UInt32)s->ll16[j]) | (((((UInt32)(s->ll4[(j) >> 1])) >> (((j) << 2) & 4)) & 15) << 16));\n                {\n                    s->ll16[j] = (UInt16)(i & 65535);\n                    {\n                        if (((j) & 1) == 0)\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 240) | (i >> 16);\n                        else\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 15) | ((i >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                i = j;\n                j = tmp;\n            } while (i != s->origPtr);\n            s->tPos = s->origPtr;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n            }\n        } else {\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->tt[i] & 255);\n                s->tt[s->cftab[uc]] |= (i << 8);\n                s->cftab[uc]++;\n            }\n            s->tPos = s->tt[s->origPtr] >> 8;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n            }\n        }\n        {\n            retVal = 0;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      endhdr_2:\n      case 42:\n        s->state = 42;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 114) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 43:\n        s->state = 43;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 69) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 44:\n        s->state = 44;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 56) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 45:\n        s->state = 45;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 80) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 46:\n        s->state = 46;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 144) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->storedCombinedCRC = 0;\n      case 47:\n        s->state = 47;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 48:\n        s->state = 48;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 49:\n        s->state = 49;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 50:\n        s->state = 50;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n        s->state = 1;\n        {\n            retVal = 4;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      default:\n        {\n            if (!(((Bool)0)))\n                BZ2_bz__AssertH__fail(4001);\n        }\n        ;\n    }\n    {\n        if (!(((Bool)0)))\n            BZ2_bz__AssertH__fail(4002);\n    }\n    ;\n  save_state_and_return:\n    s->save_i = i;\n    s->save_j = j;\n    s->save_t = t;\n    s->save_alphaSize = alphaSize;\n    s->save_nGroups = nGroups;\n    s->save_nSelectors = nSelectors;\n    s->save_EOB = EOB;\n    s->save_groupNo = groupNo;\n    s->save_groupPos = groupPos;\n    s->save_nextSym = nextSym;\n    s->save_nblockMAX = nblockMAX;\n    s->save_nblock = nblock;\n    s->save_es = es;\n    s->save_N = N;\n    s->save_curr = curr;\n    s->save_zt = zt;\n    s->save_zn = zn;\n    s->save_zvec = zvec;\n    s->save_zj = zj;\n    s->save_gSel = gSel;\n    s->save_gMinlen = gMinlen;\n    s->save_gLimit = gLimit;\n    s->save_gBase = gBase;\n    s->save_gPerm = gPerm;\n    return retVal;\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#415:1#uncompressStream",
    "nobreaks": 1,
    "body": "{\n    BZFILE *bzf = ((void *)0);\n    Int32 bzerr, bzerr_dummy, ret, nread, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    ;\n    ;\n    if (ferror(stream))\n        goto errhandler_io;\n    if (ferror(zStream))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = BZ2_bzReadOpen(&bzerr, zStream, verbosity, (int)smallMode, unused, nUnused);\n            if (bzf == ((void *)0) || bzerr != 0)\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    nread = BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto trycat;\n                    if ((bzerr == 0 || bzerr == 4) && nread > 0)\n                        fwrite(obuf, sizeof(UChar), nread, stream);\n                    if (ferror(stream))\n                        goto errhandler_io;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            if (nUnused == 0 && myfeof(zStream))\n                break;\n        }\n  closeok:\n    if (ferror(zStream))\n        goto errhandler_io;\n    if (stream != __stdoutp) {\n        Int32 fd = fileno(stream);\n        if (fd < 0)\n            goto errhandler_io;\n        applySavedFileAttrToOutputFile(fd);\n    }\n    ret = fclose(zStream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (ferror(stream))\n        goto errhandler_io;\n    ret = fflush(stream);\n    if (ret != 0)\n        goto errhandler_io;\n    if (stream != __stdoutp) {\n        ret = fclose(stream);\n        outputHandleJustInCase = ((void *)0);\n        if (ret == (-1))\n            goto errhandler_io;\n    }\n    outputHandleJustInCase = ((void *)0);\n    if (verbosity >= 2)\n        fprintf(__stderrp, \"\\n    \");\n    return ((Bool)1);\n  trycat:\n    if (forceOverwrite) {\n        rewind(zStream);\n        while (((Bool)1))\n            {\n                if (myfeof(zStream))\n                    break;\n                nread = fread(obuf, sizeof(UChar), 5000, zStream);\n                if (ferror(zStream))\n                    goto errhandler_io;\n                if (nread > 0)\n                    fwrite(obuf, sizeof(UChar), nread, stream);\n                if (ferror(stream))\n                    goto errhandler_io;\n            }\n        goto closeok;\n    }\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        crcError();\n      case (-3):\n        outOfMemory();\n      case (-7):\n        compressedStreamEOF();\n      case (-5):\n        if (zStream != __stdinp)\n            fclose(zStream);\n        if (stream != __stdoutp)\n            fclose(stream);\n        if (streamNo == 1) {\n            return ((Bool)0);\n        } else {\n            if (noisy)\n                fprintf(__stderrp, \"\\n%s: %s: trailing garbage after EOF ignored\\n\", progName, inName);\n            return ((Bool)1);\n        }\n      default:\n        panic(\"decompress:unexpected error\");\n    }\n    panic(\"decompress:end\");\n    return ((Bool)1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/bzip2/bzip2.c#536:1#testStream",
    "nobreaks": 1,
    "body": "{\n    BZFILE *bzf = ((void *)0);\n    Int32 bzerr, bzerr_dummy, ret, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    ;\n    if (ferror(zStream))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = BZ2_bzReadOpen(&bzerr, zStream, verbosity, (int)smallMode, unused, nUnused);\n            if (bzf == ((void *)0) || bzerr != 0)\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto errhandler;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            if (nUnused == 0 && myfeof(zStream))\n                break;\n        }\n    if (ferror(zStream))\n        goto errhandler_io;\n    ret = fclose(zStream);\n    if (ret == (-1))\n        goto errhandler_io;\n    if (verbosity >= 2)\n        fprintf(__stderrp, \"\\n    \");\n    return ((Bool)1);\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    if (verbosity == 0)\n        fprintf(__stderrp, \"%s: %s: \", progName, inName);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        fprintf(__stderrp, \"data integrity (CRC) error in data\\n\");\n        return ((Bool)0);\n      case (-3):\n        outOfMemory();\n      case (-7):\n        fprintf(__stderrp, \"file ends unexpectedly\\n\");\n        return ((Bool)0);\n      case (-5):\n        if (zStream != __stdinp)\n            fclose(zStream);\n        if (streamNo == 1) {\n            fprintf(__stderrp, \"bad magic number (file not created by bzip2)\\n\");\n            return ((Bool)0);\n        } else {\n            if (noisy)\n                fprintf(__stderrp, \"trailing garbage after EOF ignored\\n\");\n            return ((Bool)1);\n        }\n      default:\n        panic(\"test:unexpected error\");\n    }\n    panic(\"test:end\");\n    return ((Bool)1);\n}\n"
  }
]
[
  {
    "id": "sqlite3.c#198992:1#jsonReturn",
    "nobreaks": 1,
    "body": "{\n    switch (pNode->eType) {\n      default:\n        {\n            ((void)0);\n            sqlite3_result_null(pCtx);\n            break;\n        }\n      case 1:\n        {\n            sqlite3_result_int(pCtx, 1);\n            break;\n        }\n      case 2:\n        {\n            sqlite3_result_int(pCtx, 0);\n            break;\n        }\n      case 3:\n        {\n            sqlite3_int64 i = 0;\n            const char *z;\n            ((void)0);\n            z = pNode->u.zJContent;\n            if (z[0] == '-') {\n                z++;\n            }\n            while (z[0] >= '0' && z[0] <= '9')\n                {\n                    unsigned int v = *(z++) - '0';\n                    if (i >= (4294967295U | (((i64)2147483647) << 32)) / 10) {\n                        if (i > (4294967295U | (((i64)2147483647) << 32)) / 10)\n                            goto int_as_real;\n                        if (z[0] >= '0' && z[0] <= '9')\n                            goto int_as_real;\n                        if (v == 9)\n                            goto int_as_real;\n                        if (v == 8) {\n                            if (pNode->u.zJContent[0] == '-') {\n                                sqlite3_result_int64(pCtx, (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))));\n                                goto int_done;\n                            } else {\n                                goto int_as_real;\n                            }\n                        }\n                    }\n                    i = i * 10 + v;\n                }\n            if (pNode->u.zJContent[0] == '-') {\n                i = -i;\n            }\n            sqlite3_result_int64(pCtx, i);\n          int_done:\n            break;\n          int_as_real:\n            ;\n        }\n      case 4:\n        {\n            double r;\n            const char *z;\n            ((void)0);\n            z = pNode->u.zJContent;\n            sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);\n            sqlite3_result_double(pCtx, r);\n            break;\n        }\n      case 5:\n        {\n            ((void)0);\n            if ((pNode->jnFlags & 2) == 0) {\n                ((void)0);\n                sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2, ((sqlite3_destructor_type)-1));\n            } else {\n                u32 i;\n                u32 n = pNode->n;\n                const char *z;\n                char *zOut;\n                u32 j;\n                ((void)0);\n                z = pNode->u.zJContent;\n                zOut = sqlite3_malloc(n + 1);\n                if (zOut == 0) {\n                    sqlite3_result_error_nomem(pCtx);\n                    break;\n                }\n                for (i = 1 , j = 0; i < n - 1; i++) {\n                    char c = z[i];\n                    if (c != '\\\\') {\n                        zOut[j++] = c;\n                    } else {\n                        c = z[++i];\n                        if (c == 'u') {\n                            u32 v = jsonHexToInt4(z + i + 1);\n                            i += 4;\n                            if (v == 0)\n                                break;\n                            if (v <= 127) {\n                                zOut[j++] = (char)v;\n                            } else if (v <= 2047) {\n                                zOut[j++] = (char)(192 | (v >> 6));\n                                zOut[j++] = 128 | (v & 63);\n                            } else {\n                                u32 vlo;\n                                if ((v & 64512) == 55296 && i < n - 6 && z[i + 1] == '\\\\' && z[i + 2] == 'u' && ((vlo = jsonHexToInt4(z + i + 3)) & 64512) == 56320) {\n                                    v = ((v & 1023) << 10) + (vlo & 1023) + 65536;\n                                    i += 6;\n                                    zOut[j++] = 240 | (v >> 18);\n                                    zOut[j++] = 128 | ((v >> 12) & 63);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                } else {\n                                    zOut[j++] = 224 | (v >> 12);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                }\n                            }\n                        } else {\n                            if (c == 'b') {\n                                c = '\\b';\n                            } else if (c == 'f') {\n                                c = '\\f';\n                            } else if (c == 'n') {\n                                c = '\\n';\n                            } else if (c == 'r') {\n                                c = '\\r';\n                            } else if (c == 't') {\n                                c = '\\t';\n                            }\n                            zOut[j++] = c;\n                        }\n                    }\n                }\n                zOut[j] = 0;\n                sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n            }\n            break;\n        }\n      case 6:\n      case 7:\n        {\n            jsonReturnJson(pNode, pCtx, aReplace);\n            break;\n        }\n    }\n}\n"
  },
  {
    "id": "#23:25#sqlite3GetToken",
    "nobreaks": 1,
    "body": "{\n    int i, c;\n    switch (aiClass[*z]) {\n      case 7:\n        {\n            ;\n            ;\n            ;\n            ;\n            ;\n            for (i = 1; (sqlite3CtypeMap[(unsigned char)(z[i])] & 1); i++) {\n            }\n            *tokenType = 183;\n            return i;\n        }\n      case 11:\n        {\n            if (z[1] == '-') {\n                for (i = 2; (c = z[i]) != 0 && c != '\\n'; i++) {\n                }\n                *tokenType = 183;\n                return i;\n            } else if (z[1] == '>') {\n                *tokenType = 112;\n                return 2 + (z[2] == '>');\n            }\n            *tokenType = 107;\n            return 1;\n        }\n      case 17:\n        {\n            *tokenType = 22;\n            return 1;\n        }\n      case 18:\n        {\n            *tokenType = 23;\n            return 1;\n        }\n      case 19:\n        {\n            *tokenType = 1;\n            return 1;\n        }\n      case 20:\n        {\n            *tokenType = 106;\n            return 1;\n        }\n      case 21:\n        {\n            *tokenType = 108;\n            return 1;\n        }\n      case 16:\n        {\n            if (z[1] != '*' || z[2] == 0) {\n                *tokenType = 109;\n                return 1;\n            }\n            for (i = 3 , c = z[2]; (c != '*' || z[i] != '/') && (c = z[i]) != 0; i++) {\n            }\n            if (c)\n                i++;\n            *tokenType = 183;\n            return i;\n        }\n      case 22:\n        {\n            *tokenType = 110;\n            return 1;\n        }\n      case 14:\n        {\n            *tokenType = 53;\n            return 1 + (z[1] == '=');\n        }\n      case 12:\n        {\n            if ((c = z[1]) == '=') {\n                *tokenType = 55;\n                return 2;\n            } else if (c == '>') {\n                *tokenType = 52;\n                return 2;\n            } else if (c == '<') {\n                *tokenType = 104;\n                return 2;\n            } else {\n                *tokenType = 56;\n                return 1;\n            }\n        }\n      case 13:\n        {\n            if ((c = z[1]) == '=') {\n                *tokenType = 57;\n                return 2;\n            } else if (c == '>') {\n                *tokenType = 105;\n                return 2;\n            } else {\n                *tokenType = 54;\n                return 1;\n            }\n        }\n      case 15:\n        {\n            if (z[1] != '=') {\n                *tokenType = 184;\n                return 1;\n            } else {\n                *tokenType = 52;\n                return 2;\n            }\n        }\n      case 10:\n        {\n            if (z[1] != '|') {\n                *tokenType = 103;\n                return 1;\n            } else {\n                *tokenType = 111;\n                return 2;\n            }\n        }\n      case 23:\n        {\n            *tokenType = 25;\n            return 1;\n        }\n      case 24:\n        {\n            *tokenType = 102;\n            return 1;\n        }\n      case 25:\n        {\n            *tokenType = 114;\n            return 1;\n        }\n      case 8:\n        {\n            int delim = z[0];\n            ;\n            ;\n            ;\n            for (i = 1; (c = z[i]) != 0; i++) {\n                if (c == delim) {\n                    if (z[i + 1] == delim) {\n                        i++;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            if (c == '\\'') {\n                *tokenType = 117;\n                return i + 1;\n            } else if (c != 0) {\n                *tokenType = 59;\n                return i + 1;\n            } else {\n                *tokenType = 184;\n                return i;\n            }\n        }\n      case 26:\n        {\n            if (!(sqlite3CtypeMap[(unsigned char)(z[1])] & 4)) {\n                *tokenType = 141;\n                return 1;\n            }\n        }\n      case 3:\n        {\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            *tokenType = 155;\n            if (z[0] == '0' && (z[1] == 'x' || z[1] == 'X') && (sqlite3CtypeMap[(unsigned char)(z[2])] & 8)) {\n                for (i = 3; (sqlite3CtypeMap[(unsigned char)(z[i])] & 8); i++) {\n                }\n                return i;\n            }\n            for (i = 0; (sqlite3CtypeMap[(unsigned char)(z[i])] & 4); i++) {\n            }\n            if (z[i] == '.') {\n                i++;\n                while ((sqlite3CtypeMap[(unsigned char)(z[i])] & 4))\n                    {\n                        i++;\n                    }\n                *tokenType = 153;\n            }\n            if ((z[i] == 'e' || z[i] == 'E') && ((sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) || ((z[i + 1] == '+' || z[i + 1] == '-') && (sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4)))) {\n                i += 2;\n                while ((sqlite3CtypeMap[(unsigned char)(z[i])] & 4))\n                    {\n                        i++;\n                    }\n                *tokenType = 153;\n            }\n            while (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0))\n                {\n                    *tokenType = 184;\n                    i++;\n                }\n            return i;\n        }\n      case 9:\n        {\n            for (i = 1 , c = z[0]; c != ']' && (c = z[i]) != 0; i++) {\n            }\n            *tokenType = c == ']' ? 59 : 184;\n            return i;\n        }\n      case 6:\n        {\n            *tokenType = 156;\n            for (i = 1; (sqlite3CtypeMap[(unsigned char)(z[i])] & 4); i++) {\n            }\n            return i;\n        }\n      case 4:\n      case 5:\n        {\n            int n = 0;\n            ;\n            ;\n            ;\n            ;\n            *tokenType = 156;\n            for (i = 1; (c = z[i]) != 0; i++) {\n                if (((sqlite3CtypeMap[(unsigned char)c] & 70) != 0)) {\n                    n++;\n                } else if (c == '(' && n > 0) {\n                    do {\n                        i++;\n                    } while ((c = z[i]) != 0 && !(sqlite3CtypeMap[(unsigned char)(c)] & 1) && c != ')');\n                    if (c == ')') {\n                        i++;\n                    } else {\n                        *tokenType = 184;\n                    }\n                    break;\n                } else if (c == ':' && z[i + 1] == ':') {\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            if (n == 0)\n                *tokenType = 184;\n            return i;\n        }\n      case 1:\n        {\n            for (i = 1; aiClass[z[i]] <= 2; i++) {\n            }\n            if (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0)) {\n                i++;\n                break;\n            }\n            *tokenType = 59;\n            return keywordCode((char *)z, i, tokenType);\n        }\n      case 0:\n        {\n            ;\n            ;\n            if (z[1] == '\\'') {\n                *tokenType = 154;\n                for (i = 2; (sqlite3CtypeMap[(unsigned char)(z[i])] & 8); i++) {\n                }\n                if (z[i] != '\\'' || i % 2) {\n                    *tokenType = 184;\n                    while (z[i] && z[i] != '\\'')\n                        {\n                            i++;\n                        }\n                }\n                if (z[i])\n                    i++;\n                return i;\n            }\n        }\n      case 2:\n      case 27:\n        {\n            i = 1;\n            break;\n        }\n      case 30:\n        {\n            if (z[1] == 187 && z[2] == 191) {\n                *tokenType = 183;\n                return 3;\n            }\n            i = 1;\n            break;\n        }\n      case 29:\n        {\n            *tokenType = 184;\n            return 0;\n        }\n      default:\n        {\n            *tokenType = 184;\n            return 1;\n        }\n    }\n    while (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0))\n        {\n            i++;\n        }\n    *tokenType = 59;\n    return i;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprCodeTarget",
    "nobreaks": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op;\n    int inReg = target;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    Expr tempX;\n    int p5 = 0;\n    ((void)0);\n    ((void)0);\n  expr_code_doover:\n    if (pExpr == 0) {\n        op = 121;\n    } else if (pParse->pIdxEpr != 0 && !(((pExpr)->flags & (8388608)) != 0) && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target)) >= 0) {\n        return r1;\n    } else {\n        ((void)0);\n        op = pExpr->op;\n    }\n    switch (op) {\n      case 169:\n        {\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            struct AggInfo_col *pCol;\n            ((void)0);\n            ((void)0);\n            pCol = &pAggInfo->aCol[pExpr->iAgg];\n            if (!pAggInfo->directMode) {\n                return (((void)0) , (pAggInfo)->iFirstReg + (pExpr->iAgg));\n            } else if (pAggInfo->useSortingIdx) {\n                Table *pTab = pCol->pTab;\n                sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);\n                if (pTab == 0) {\n                } else if (pCol->iColumn < 0) {\n                    ;\n                } else {\n                    ;\n                    if (pTab->aCol[pCol->iColumn].affinity == 69) {\n                        sqlite3VdbeAddOp1(v, 87, target);\n                    }\n                }\n                return target;\n            } else if (pExpr->y.pTab == 0) {\n                sqlite3VdbeAddOp3(v, 94, pExpr->iTable, pExpr->iColumn, target);\n                return target;\n            }\n        }\n      case 167:\n        {\n            int iTab = pExpr->iTable;\n            int iReg;\n            if ((((pExpr)->flags & (32)) != 0)) {\n                int aff;\n                iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                ((void)0);\n                ((void)0);\n                aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n                if (aff > 65) {\n                    static const char zAff[] = \"B\\000C\\000D\\000E\\000F\";\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeAddOp4(v, 96, iReg, 1, 0, &zAff[(aff - 'B') * 2], (-1));\n                }\n                return iReg;\n            }\n            if (iTab < 0) {\n                if (pParse->iSelfTab < 0) {\n                    Column *pCol;\n                    Table *pTab;\n                    int iSrc;\n                    int iCol = pExpr->iColumn;\n                    ((void)0);\n                    pTab = pExpr->y.pTab;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    if (iCol < 0) {\n                        return -1 - pParse->iSelfTab;\n                    }\n                    pCol = pTab->aCol + iCol;\n                    ;\n                    iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n                    if (pCol->colFlags & 96) {\n                        if (pCol->colFlags & 256) {\n                            sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zCnName);\n                            return 0;\n                        }\n                        pCol->colFlags |= 256;\n                        if (pCol->colFlags & 128) {\n                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n                        }\n                        pCol->colFlags &= ~(256 | 128);\n                        return iSrc;\n                    } else if (pCol->affinity == 69) {\n                        sqlite3VdbeAddOp2(v, 81, iSrc, target);\n                        sqlite3VdbeAddOp1(v, 87, target);\n                        return target;\n                    } else {\n                        return iSrc;\n                    }\n                } else {\n                    iTab = pParse->iSelfTab - 1;\n                }\n            }\n            ((void)0);\n            ((void)0);\n            iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, pExpr->iColumn, iTab, target, pExpr->op2);\n            return iReg;\n        }\n      case 155:\n        {\n            codeInteger(pParse, pExpr, 0, target);\n            return target;\n        }\n      case 170:\n        {\n            sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target);\n            return target;\n        }\n      case 153:\n        {\n            ((void)0);\n            codeReal(v, pExpr->u.zToken, 0, target);\n            return target;\n        }\n      case 117:\n        {\n            ((void)0);\n            sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n            return target;\n        }\n      default:\n        {\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            return target;\n        }\n      case 154:\n        {\n            int n;\n            const char *z;\n            char *zBlob;\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            z = &pExpr->u.zToken[2];\n            n = sqlite3Strlen30(z) - 1;\n            ((void)0);\n            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n            sqlite3VdbeAddOp4(v, 77, n / 2, target, 0, zBlob, (-6));\n            return target;\n        }\n      case 156:\n        {\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 78, pExpr->iColumn, target);\n            if (pExpr->u.zToken[1] != 0) {\n                const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n                ((void)0);\n                pParse->pVList[0] = 0;\n                sqlite3VdbeAppendP4(v, (char *)z, (-1));\n            }\n            return target;\n        }\n      case 176:\n        {\n            return pExpr->iTable;\n        }\n      case 36:\n        {\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            if (inReg != target) {\n                sqlite3VdbeAddOp2(v, 81, inReg, target);\n                inReg = target;\n            }\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 88, target, sqlite3AffinityType(pExpr->u.zToken, 0));\n            return inReg;\n        }\n      case 45:\n      case 171:\n        op = (op == 45) ? 53 : 52;\n        p5 = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            if (sqlite3ExprIsVector(pLeft)) {\n                codeVectorCompare(pParse, pExpr, target, op, p5);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n                sqlite3VdbeAddOp2(v, 71, 1, inReg);\n                codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v) + 2, p5, (((pExpr)->flags & (1024)) != 0));\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                ((void)0);\n                ;\n                ;\n                if (p5 == 128) {\n                    sqlite3VdbeAddOp2(v, 71, 0, inReg);\n                } else {\n                    sqlite3VdbeAddOp3(v, 92, r1, inReg, r2);\n                }\n                ;\n                ;\n            }\n            break;\n        }\n      case 44:\n      case 43:\n      case 106:\n      case 108:\n      case 107:\n      case 110:\n      case 102:\n      case 103:\n      case 109:\n      case 104:\n      case 105:\n      case 111:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            sqlite3VdbeAddOp3(v, op, r2, r1, target);\n            ;\n            ;\n            break;\n        }\n      case 173:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            ((void)0);\n            if (pLeft->op == 155) {\n                codeInteger(pParse, pLeft, 1, target);\n                return target;\n            } else if (pLeft->op == 153) {\n                ((void)0);\n                codeReal(v, pLeft->u.zToken, 1, target);\n                return target;\n            } else {\n                tempX.op = 155;\n                tempX.flags = 2048 | 65536;\n                tempX.u.iValue = 0;\n                ;\n                r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n                sqlite3VdbeAddOp3(v, 107, r2, r1, target);\n                ;\n            }\n            break;\n        }\n      case 114:\n      case 19:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            sqlite3VdbeAddOp2(v, op, r1, inReg);\n            break;\n        }\n      case 175:\n        {\n            int isTrue;\n            int bNormal;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            bNormal = pExpr->op2 == 45;\n            ;\n            ;\n            sqlite3VdbeAddOp4Int(v, 91, r1, inReg, !isTrue, isTrue ^ bNormal);\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            int addr;\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            addr = sqlite3VdbeAddOp1(v, op, r1);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 71, 0, target);\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 168:\n        {\n            AggInfo *pInfo = pExpr->pAggInfo;\n            if (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)) {\n                ((void)0);\n                sqlite3ErrorMsg(pParse, \"misuse of aggregate: %#T()\", pExpr);\n            } else {\n                return (((void)0) , (pInfo)->iFirstReg + (pInfo)->nColumn + (pExpr->iAgg));\n            }\n            break;\n        }\n      case 172:\n        {\n            ExprList *pFarg;\n            int nFarg;\n            FuncDef *pDef;\n            const char *zId;\n            u32 constMask = 0;\n            int i;\n            sqlite3 *db = pParse->db;\n            u8 enc = ((db)->enc);\n            CollSeq *pColl = 0;\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                return pExpr->y.pWin->regResult;\n            }\n            if (((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr)) {\n                return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n            }\n            ((void)0);\n            ((void)0);\n            pFarg = pExpr->x.pList;\n            nFarg = pFarg ? pFarg->nExpr : 0;\n            ((void)0);\n            zId = pExpr->u.zToken;\n            pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n            if (pDef == 0 || pDef->xFinalize != 0) {\n                sqlite3ErrorMsg(pParse, \"unknown function: %#T()\", pExpr);\n                break;\n            }\n            if (pDef->funcFlags & 4194304) {\n                ((void)0);\n                ((void)0);\n                return exprCodeInlineFunction(pParse, pFarg, ((int)(intptr_t)(pDef->pUserData)), target);\n            } else if (pDef->funcFlags & (524288 | 2097152)) {\n                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n            }\n            for (i = 0; i < nFarg; i++) {\n                if (i < 32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {\n                    ;\n                    constMask |= (((unsigned int)1) << (i));\n                }\n                if ((pDef->funcFlags & 32) != 0 && !pColl) {\n                    pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n                }\n            }\n            if (pFarg) {\n                if (constMask) {\n                    r1 = pParse->nMem + 1;\n                    pParse->nMem += nFarg;\n                } else {\n                    r1 = sqlite3GetTempRange(pParse, nFarg);\n                }\n                if ((pDef->funcFlags & (64 | 128)) != 0) {\n                    u8 exprOp;\n                    ((void)0);\n                    ((void)0);\n                    exprOp = pFarg->a[0].pExpr->op;\n                    if (exprOp == 167 || exprOp == 169) {\n                        ((void)0);\n                        ((void)0);\n                        ;\n                        pFarg->a[0].pExpr->op2 = pDef->funcFlags & (64 | 128);\n                    }\n                }\n                sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 1 | 2);\n            } else {\n                r1 = 0;\n            }\n            if (nFarg >= 2 && (((pExpr)->flags & (256)) != 0)) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n            } else if (nFarg > 0) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n            }\n            if (pDef->funcFlags & 32) {\n                if (!pColl)\n                    pColl = db->pDfltColl;\n                sqlite3VdbeAddOp4(v, 85, 0, 0, 0, (char *)pColl, (-2));\n            }\n            sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg, pDef, pExpr->op2);\n            if (nFarg) {\n                if (constMask == 0) {\n                    sqlite3ReleaseTempRange(pParse, r1, nFarg);\n                } else {\n                    ;\n                }\n            }\n            return target;\n        }\n      case 20:\n      case 138:\n        {\n            int nCol;\n            ;\n            ;\n            if (pParse->db->mallocFailed) {\n                return 0;\n            } else if (op == 138 && ((((pExpr)->flags & 4096) != 0)) && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {\n                sqlite3SubselectError(pParse, nCol, 1);\n            } else {\n                return sqlite3CodeSubselect(pParse, pExpr);\n            }\n            break;\n        }\n      case 178:\n        {\n            int n;\n            Expr *pLeft = pExpr->pLeft;\n            if (pLeft->iTable == 0 || pParse->withinRJSubrtn > pLeft->op2) {\n                pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);\n                pLeft->op2 = pParse->withinRJSubrtn;\n            }\n            ((void)0);\n            n = sqlite3ExprVectorSize(pLeft);\n            if (pExpr->iTable != n) {\n                sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pExpr->iTable, n);\n            }\n            return pLeft->iTable + pExpr->iColumn;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            sqlite3VdbeAddOp2(v, 86, target, 0);\n            sqlite3VdbeResolveLabel(v, destIfNull);\n            return target;\n        }\n      case 48:\n        {\n            exprCodeBetween(pParse, pExpr, target, 0, 0);\n            return target;\n        }\n      case 113:\n        {\n            if (!(((pExpr)->flags & (512)) != 0) && (pExpr->pLeft) && pExpr->pLeft->op == 172) {\n                inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                if (inReg != target) {\n                    sqlite3VdbeAddOp2(v, 81, inReg, target);\n                    inReg = target;\n                }\n                sqlite3VdbeAddOp1(v, 179, inReg);\n                return inReg;\n            } else {\n                pExpr = pExpr->pLeft;\n                goto expr_code_doover;\n            }\n        }\n      case 181:\n      case 174:\n        {\n            pExpr = pExpr->pLeft;\n            goto expr_code_doover;\n        }\n      case 77:\n        {\n            Table *pTab;\n            int iCol;\n            int p1;\n            ((void)0);\n            pTab = pExpr->y.pTab;\n            iCol = pExpr->iColumn;\n            p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, iCol);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            ((void)0);\n            sqlite3VdbeAddOp2(v, 157, p1, target);\n            ;\n            if (iCol >= 0 && pTab->aCol[iCol].affinity == 69) {\n                sqlite3VdbeAddOp1(v, 87, target);\n            }\n            break;\n        }\n      case 177:\n        {\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            break;\n        }\n      case 179:\n        {\n            int addrINR;\n            u8 okConstFactor = pParse->okConstFactor;\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            if (pAggInfo) {\n                ((void)0);\n                if (!pAggInfo->directMode) {\n                    inReg = (((void)0) , (pAggInfo)->iFirstReg + (pExpr->iAgg));\n                    break;\n                }\n                if (pExpr->pAggInfo->useSortingIdx) {\n                    sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pAggInfo->aCol[pExpr->iAgg].iSorterColumn, target);\n                    inReg = target;\n                    break;\n                }\n            }\n            addrINR = sqlite3VdbeAddOp1(v, 20, pExpr->iTable);\n            pParse->okConstFactor = 0;\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            pParse->okConstFactor = okConstFactor;\n            sqlite3VdbeJumpHere(v, addrINR);\n            sqlite3VdbeChangeP3(v, addrINR, inReg);\n            break;\n        }\n      case 157:\n        {\n            int endLabel;\n            int nextCase;\n            int nExpr;\n            int i;\n            ExprList *pEList;\n            struct ExprList_item *aListelem;\n            Expr opCompare;\n            Expr *pX;\n            Expr *pTest = 0;\n            Expr *pDel = 0;\n            sqlite3 *db = pParse->db;\n            ((void)0);\n            ((void)0);\n            pEList = pExpr->x.pList;\n            aListelem = pEList->a;\n            nExpr = pEList->nExpr;\n            endLabel = sqlite3VdbeMakeLabel(pParse);\n            if ((pX = pExpr->pLeft) != 0) {\n                pDel = sqlite3ExprDup(db, pX, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDel);\n                    break;\n                }\n                ;\n                exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n                ;\n                __builtin___memset_chk(&opCompare, 0, sizeof (opCompare), __builtin_object_size(&opCompare, 0));\n                opCompare.op = 53;\n                opCompare.pLeft = pDel;\n                pTest = &opCompare;\n                regFree1 = 0;\n            }\n            for (i = 0; i < nExpr - 1; i = i + 2) {\n                if (pX) {\n                    ((void)0);\n                    opCompare.pRight = aListelem[i].pExpr;\n                } else {\n                    pTest = aListelem[i].pExpr;\n                }\n                nextCase = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);\n                ;\n                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);\n                sqlite3VdbeGoto(v, endLabel);\n                sqlite3VdbeResolveLabel(v, nextCase);\n            }\n            if ((nExpr & 1) != 0) {\n                sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, target);\n            }\n            sqlite3ExprDelete(db, pDel);\n            setDoNotMergeFlagOnCopy(v);\n            sqlite3VdbeResolveLabel(v, endLabel);\n            break;\n        }\n      case 71:\n        {\n            ((void)0);\n            if (!pParse->pTriggerTab && !pParse->nested) {\n                sqlite3ErrorMsg(pParse, \"RAISE() may only be used within a trigger-program\");\n                return 0;\n            }\n            if (pExpr->affExpr == 2) {\n                sqlite3MayAbort(pParse);\n            }\n            ((void)0);\n            if (pExpr->affExpr == 4) {\n                sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr->u.zToken, 0);\n                ;\n            } else {\n                sqlite3HaltConstraint(pParse, pParse->pTriggerTab ? (19 | (7 << 8)) : 1, pExpr->affExpr, pExpr->u.zToken, 0, 0);\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    return inReg;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeExec",
    "nobreaks": 1,
    "body": "{\n    Op *aOp = p->aOp;\n    Op *pOp = aOp;\n    int rc = 0;\n    sqlite3 *db = p->db;\n    u8 resetSchemaOnFault = 0;\n    u8 encoding = ((db)->enc);\n    int iCompare = 0;\n    u64 nVmStep = 0;\n    u64 nProgressLimit;\n    Mem *aMem = p->aMem;\n    Mem *pIn1 = 0;\n    Mem *pIn2 = 0;\n    Mem *pIn3 = 0;\n    Mem *pOut = 0;\n    ((void)0);\n    if (((p->lockMask) != 0)) {\n        sqlite3VdbeEnter(p);\n    }\n    if (db->xProgress) {\n        u32 iPrior = p->aCounter[4];\n        ((void)0);\n        nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);\n    } else {\n        nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n    }\n    if (p->rc == 7) {\n        goto no_mem;\n    }\n    ((void)0);\n    ;\n    p->rc = 0;\n    ((void)0);\n    p->iCurrentTime = 0;\n    ((void)0);\n    db->busyHandler.nBusy = 0;\n    if (__atomic_load_n((&db->u1.isInterrupted), 0))\n        goto abort_due_to_interrupt;\n    ;\n    for (pOp = &aOp[p->pc]; 1; pOp++) {\n        ((void)0);\n        ((void)0);\n        nVmStep++;\n        switch (pOp->opcode) {\n          case 9:\n            {\n              jump_to_p2_and_check_for_interrupt:\n                pOp = &aOp[pOp->p2 - 1];\n              check_for_interrupt:\n                if (__atomic_load_n((&db->u1.isInterrupted), 0))\n                    goto abort_due_to_interrupt;\n                while (nVmStep >= nProgressLimit && db->xProgress != 0)\n                    {\n                        ((void)0);\n                        nProgressLimit += db->nProgressOps;\n                        if (db->xProgress(db->pProgressArg)) {\n                            nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                            rc = 9;\n                            goto abort_due_to_error;\n                        }\n                    }\n                break;\n            }\n          case 10:\n            {\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                pIn1->flags = 4;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                goto jump_to_p2_and_check_for_interrupt;\n            }\n          case 67:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & 4) {\n                    if (pOp->p3) {\n                        ;\n                    }\n                    pOp = &aOp[pIn1->u.i];\n                } else if ((pOp->p3)) {\n                    ;\n                }\n                break;\n            }\n          case 11:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pOut = &aMem[pOp->p1];\n                ((void)0);\n                pOut->u.i = pOp->p3 - 1;\n                pOut->flags = 4;\n                if (pOp->p2 == 0)\n                    break;\n              jump_to_p2:\n                ((void)0);\n                ((void)0);\n                pOp = &aOp[pOp->p2 - 1];\n                break;\n            }\n          case 68:\n            {\n                VdbeOp *pCaller;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pCaller = &aOp[pIn1->u.i];\n                ((void)0);\n                ((void)0);\n                pOp = &aOp[pCaller->p2 - 1];\n                pIn1->flags = 0;\n                break;\n            }\n          case 12:\n            {\n                int pcDest;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                pIn1->flags = 4;\n                pcDest = (int)pIn1->u.i;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                pOp = &aOp[pcDest];\n                break;\n            }\n          case 69:\n            {\n                pIn3 = &aMem[pOp->p3];\n                if ((pIn3->flags & 1) == 0)\n                    break;\n            }\n          case 70:\n            {\n                VdbeFrame *pFrame;\n                int pcx;\n                ((void)0);\n                if (p->pFrame && pOp->p1 == 0) {\n                    pFrame = p->pFrame;\n                    p->pFrame = pFrame->pParent;\n                    p->nFrame--;\n                    sqlite3VdbeSetChanges(db, p->nChange);\n                    pcx = sqlite3VdbeFrameRestore(pFrame);\n                    if (pOp->p2 == 4) {\n                        pcx = p->aOp[pcx].p2 - 1;\n                    }\n                    aOp = p->aOp;\n                    aMem = p->aMem;\n                    pOp = &aOp[pcx];\n                    break;\n                }\n                p->rc = pOp->p1;\n                p->errorAction = (u8)pOp->p2;\n                ((void)0);\n                if (p->rc) {\n                    if (pOp->p5) {\n                        static const char *const azType[] = {\"NOT NULL\", \"UNIQUE\", \"CHECK\", \"FOREIGN KEY\"};\n                        ;\n                        ;\n                        ;\n                        ;\n                        sqlite3VdbeError(p, \"%s constraint failed\", azType[pOp->p5 - 1]);\n                        if (pOp->p4.z) {\n                            p->zErrMsg = sqlite3MPrintf(db, \"%z: %s\", p->zErrMsg, pOp->p4.z);\n                        }\n                    } else {\n                        sqlite3VdbeError(p, \"%s\", pOp->p4.z);\n                    }\n                    pcx = (int)(pOp - aOp);\n                    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n                }\n                rc = sqlite3VdbeHalt(p);\n                ((void)0);\n                if (rc == 5) {\n                    p->rc = 5;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = p->rc ? 1 : 101;\n                }\n                goto vdbe_return;\n            }\n          case 71:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = pOp->p1;\n                break;\n            }\n          case 72:\n            {\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pOut->u.i = *pOp->p4.pI64;\n                break;\n            }\n          case 153:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 8;\n                ((void)0);\n                pOut->u.r = *pOp->p4.pReal;\n                break;\n            }\n          case 117:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n                if (encoding != 1) {\n                    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));\n                    ((void)0);\n                    if (rc)\n                        goto too_big;\n                    if (0 != sqlite3VdbeChangeEncoding(pOut, encoding))\n                        goto no_mem;\n                    ((void)0);\n                    ((void)0);\n                    pOut->szMalloc = 0;\n                    pOut->flags |= 8192;\n                    if (pOp->p4type == (-6)) {\n                        sqlite3DbFree(db, pOp->p4.z);\n                    }\n                    pOp->p4type = (-6);\n                    pOp->p4.z = pOut->z;\n                    pOp->p1 = pOut->n;\n                }\n                if (pOp->p1 > db->aLimit[0]) {\n                    goto too_big;\n                }\n                pOp->opcode = 73;\n                ((void)0);\n            }\n          case 73:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = pOp->p4.z;\n                pOut->n = pOp->p1;\n                pOut->enc = encoding;\n                ;\n                if (pOp->p3 > 0) {\n                    ((void)0);\n                    pIn3 = &aMem[pOp->p3];\n                    ((void)0);\n                    if (pIn3->u.i == pOp->p5)\n                        pOut->flags = 16 | 8192 | 512;\n                }\n                break;\n            }\n          case 74:\n          case 75:\n            {\n                int cnt;\n                u16 nullFlag;\n                pOut = out2Prerelease(p, pOp);\n                cnt = pOp->p3 - pOp->p2;\n                ((void)0);\n                pOut->flags = nullFlag = pOp->p1 ? (1 | 256) : 1;\n                pOut->n = 0;\n                while (cnt > 0)\n                    {\n                        pOut++;\n                        ;\n                        sqlite3VdbeMemSetNull(pOut);\n                        pOut->flags = nullFlag;\n                        pOut->n = 0;\n                        cnt--;\n                    }\n                break;\n            }\n          case 76:\n            {\n                ((void)0);\n                pOut = &aMem[pOp->p1];\n                pOut->flags = (pOut->flags & ~(0 | 63)) | 1;\n                break;\n            }\n          case 77:\n            {\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                if (pOp->p4.z == 0) {\n                    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);\n                    if (sqlite3VdbeMemExpandBlob(pOut))\n                        goto no_mem;\n                } else {\n                    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n                }\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 78:\n            {\n                Mem *pVar;\n                ((void)0);\n                ((void)0);\n                pVar = &p->aVar[pOp->p1 - 1];\n                if (sqlite3VdbeMemTooBig(pVar)) {\n                    goto too_big;\n                }\n                pOut = &aMem[pOp->p2];\n                if ((((pOut)->flags & (32768 | 4096)) != 0))\n                    sqlite3VdbeMemSetNull(pOut);\n                __builtin___memcpy_chk(pOut, pVar, __builtin_offsetof(Mem, db), __builtin_object_size(pOut, 0));\n                pOut->flags &= ~(4096 | 16384);\n                pOut->flags |= 8192 | 64;\n                ;\n                break;\n            }\n          case 79:\n            {\n                int n;\n                int p1;\n                int p2;\n                n = pOp->p3;\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[p1];\n                pOut = &aMem[p2];\n                do {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ;\n                    sqlite3VdbeMemMove(pOut, pIn1);\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                    ;\n                    ;\n                    pIn1++;\n                    pOut++;\n                } while (--n);\n                break;\n            }\n          case 80:\n            {\n                int n;\n                n = pOp->p3;\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                ((void)0);\n                while (1)\n                    {\n                        ;\n                        sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                        if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                            goto no_mem;\n                        }\n                        ;\n                        if ((pOut->flags & 2048) != 0 && (pOp->p5 & 2) != 0) {\n                            pOut->flags &= ~2048;\n                        }\n                        ;\n                        if ((n--) == 0)\n                            break;\n                        pOut++;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 81:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                ((void)0);\n                sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                break;\n            }\n          case 82:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);\n                break;\n            }\n          case 83:\n            {\n                if ((rc = sqlite3VdbeCheckFk(p, 0)) != 0) {\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 84:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                p->cacheCtr = (p->cacheCtr + 2) | 1;\n                p->pResultRow = &aMem[pOp->p1];\n                if (db->mallocFailed)\n                    goto no_mem;\n                if (db->mTrace & 4) {\n                    db->trace.xV2(4, db->pTraceArg, p, 0);\n                }\n                p->pc = (int)(pOp - aOp) + 1;\n                rc = 100;\n                goto vdbe_return;\n            }\n          case 111:\n            {\n                i64 nByte;\n                u16 flags1;\n                u16 flags2;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                flags1 = pIn1->flags;\n                ;\n                ;\n                if ((flags1 | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                if ((flags1 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn1, encoding, 0))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                } else if ((flags1 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn1))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                }\n                flags2 = pIn2->flags;\n                if ((flags2 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn2, encoding, 0))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                } else if ((flags2 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn2))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                }\n                nByte = pIn1->n + pIn2->n;\n                if (nByte > db->aLimit[0]) {\n                    goto too_big;\n                }\n                if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {\n                    goto no_mem;\n                }\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 2);\n                if (pOut != pIn2) {\n                    __builtin___memcpy_chk(pOut->z, pIn2->z, pIn2->n, __builtin_object_size(pOut->z, 0));\n                    ((void)0);\n                    pIn2->flags = flags2;\n                }\n                __builtin___memcpy_chk(&pOut->z[pIn2->n], pIn1->z, pIn1->n, __builtin_object_size(&pOut->z[pIn2->n], 0));\n                ((void)0);\n                pIn1->flags = flags1;\n                if (encoding > 1)\n                    nByte &= ~1;\n                pOut->z[nByte] = 0;\n                pOut->z[nByte + 1] = 0;\n                pOut->flags |= 512;\n                pOut->n = (int)nByte;\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n            {\n                u16 type1;\n                u16 type2;\n                i64 iA;\n                i64 iB;\n                double rA;\n                double rB;\n                pIn1 = &aMem[pOp->p1];\n                type1 = pIn1->flags;\n                pIn2 = &aMem[pOp->p2];\n                type2 = pIn2->flags;\n                pOut = &aMem[pOp->p3];\n                if ((type1 & type2 & 4) != 0) {\n                  int_math:\n                    iA = pIn1->u.i;\n                    iB = pIn2->u.i;\n                    switch (pOp->opcode) {\n                      case 106:\n                        if (sqlite3AddInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 107:\n                        if (sqlite3SubInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 108:\n                        if (sqlite3MulInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 109:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1 && iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                                goto fp_math;\n                            iB /= iA;\n                            break;\n                        }\n                      default:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            iB %= iA;\n                            break;\n                        }\n                    }\n                    pOut->u.i = iB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                } else if (((type1 | type2) & 1) != 0) {\n                    goto arithmetic_result_is_null;\n                } else {\n                    type1 = numericType(pIn1);\n                    type2 = numericType(pIn2);\n                    if ((type1 & type2 & 4) != 0)\n                        goto int_math;\n                  fp_math:\n                    rA = sqlite3VdbeRealValue(pIn1);\n                    rB = sqlite3VdbeRealValue(pIn2);\n                    switch (pOp->opcode) {\n                      case 106:\n                        rB += rA;\n                        break;\n                      case 107:\n                        rB -= rA;\n                        break;\n                      case 108:\n                        rB *= rA;\n                        break;\n                      case 109:\n                        {\n                            if (rA == (double)0)\n                                goto arithmetic_result_is_null;\n                            rB /= rA;\n                            break;\n                        }\n                      default:\n                        {\n                            iA = sqlite3VdbeIntValue(pIn1);\n                            iB = sqlite3VdbeIntValue(pIn2);\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            rB = (double)(iB % iA);\n                            break;\n                        }\n                    }\n                    if (sqlite3IsNaN(rB)) {\n                        goto arithmetic_result_is_null;\n                    }\n                    pOut->u.r = rB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 8);\n                }\n                break;\n              arithmetic_result_is_null:\n                sqlite3VdbeMemSetNull(pOut);\n                break;\n            }\n          case 85:\n            {\n                ((void)0);\n                if (pOp->p1) {\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);\n                }\n                break;\n            }\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n            {\n                i64 iA;\n                u64 uA;\n                i64 iB;\n                u8 op;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                if ((pIn1->flags | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                iA = sqlite3VdbeIntValue(pIn2);\n                iB = sqlite3VdbeIntValue(pIn1);\n                op = pOp->opcode;\n                if (op == 102) {\n                    iA &= iB;\n                } else if (op == 103) {\n                    iA |= iB;\n                } else if (iB != 0) {\n                    ((void)0);\n                    if (iB < 0) {\n                        ((void)0);\n                        op = 2 * 104 + 1 - op;\n                        iB = iB > (-64) ? -iB : 64;\n                    }\n                    if (iB >= 64) {\n                        iA = (iA >= 0 || op == 104) ? 0 : -1;\n                    } else {\n                        __builtin___memcpy_chk(&uA, &iA, sizeof (uA), __builtin_object_size(&uA, 0));\n                        if (op == 104) {\n                            uA <<= iB;\n                        } else {\n                            uA >>= iB;\n                            if (iA < 0)\n                                uA |= ((((u64)4294967295U) << 32) | 4294967295U) << (64 - iB);\n                        }\n                        __builtin___memcpy_chk(&iA, &uA, sizeof (iA), __builtin_object_size(&iA, 0));\n                    }\n                }\n                pOut->u.i = iA;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 86:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn1->u.i += pOp->p2;\n                break;\n            }\n          case 13:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if ((pIn1->flags & 4) == 0) {\n                    applyAffinity(pIn1, 67, encoding);\n                    if ((pIn1->flags & 4) == 0) {\n                        ;\n                        if (pOp->p2 == 0) {\n                            rc = 20;\n                            goto abort_due_to_error;\n                        } else {\n                            goto jump_to_p2;\n                        }\n                    }\n                }\n                ;\n                ((pIn1)->flags = ((pIn1)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 87:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & (4 | 32)) {\n                    ;\n                    ;\n                    sqlite3VdbeMemRealify(pIn1);\n                    ;\n                }\n                break;\n            }\n          case 88:\n            {\n                ((void)0);\n                ;\n                ;\n                ;\n                ;\n                ;\n                pIn1 = &aMem[pOp->p1];\n                ;\n                rc = (((pIn1)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                ;\n                ;\n                break;\n            }\n          case 53:\n          case 52:\n          case 56:\n          case 55:\n          case 54:\n          case 57:\n            {\n                int res, res2;\n                char affinity;\n                u16 flags1;\n                u16 flags3;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                flags1 = pIn1->flags;\n                flags3 = pIn3->flags;\n                if ((flags1 & flags3 & 4) != 0) {\n                    if (pIn3->u.i > pIn1->u.i) {\n                        if (sqlite3aGTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = +1;\n                    } else if (pIn3->u.i < pIn1->u.i) {\n                        if (sqlite3aLTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = -1;\n                    } else {\n                        if (sqlite3aEQb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = 0;\n                    }\n                    ;\n                    break;\n                }\n                if ((flags1 | flags3) & 1) {\n                    if (pOp->p5 & 128) {\n                        ((void)0);\n                        ((void)0);\n                        ;\n                        if ((flags1 & flags3 & 1) != 0 && (flags3 & 256) == 0) {\n                            res = 0;\n                        } else {\n                            res = ((flags3 & 1) ? -1 : +1);\n                        }\n                    } else {\n                        ;\n                        if (pOp->p5 & 16) {\n                            goto jump_to_p2;\n                        }\n                        iCompare = 1;\n                        break;\n                    }\n                } else {\n                    affinity = pOp->p5 & 71;\n                    if (affinity >= 67) {\n                        if ((flags1 | flags3) & 2) {\n                            if ((flags1 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn1, 0);\n                                ((void)0);\n                                flags3 = pIn3->flags;\n                            }\n                            if ((flags3 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn3, 0);\n                            }\n                        }\n                    } else if (affinity == 66 && ((flags1 | flags3) & 2) != 0) {\n                        if ((flags1 & 2) == 0 && (flags1 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn1, encoding, 1);\n                            ;\n                            flags1 = (pIn1->flags & ~3519) | (flags1 & 3519);\n                            if ((pIn1 == pIn3))\n                                flags3 = flags1 | 2;\n                        }\n                        if ((flags3 & 2) == 0 && (flags3 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn3, encoding, 1);\n                            ;\n                            flags3 = (pIn3->flags & ~3519) | (flags3 & 3519);\n                        }\n                    }\n                    ((void)0);\n                    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (res < 0) {\n                    res2 = sqlite3aLTb[pOp->opcode];\n                } else if (res == 0) {\n                    res2 = sqlite3aEQb[pOp->opcode];\n                } else {\n                    res2 = sqlite3aGTb[pOp->opcode];\n                }\n                iCompare = res;\n                ((void)0);\n                pIn3->flags = flags3;\n                ((void)0);\n                pIn1->flags = flags1;\n                ;\n                if (res2) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 58:\n            {\n                ((void)0);\n                ;\n                if (iCompare == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 89:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                break;\n            }\n          case 90:\n            {\n                int n;\n                int i;\n                int p1;\n                int p2;\n                const KeyInfo *pKeyInfo;\n                u32 idx;\n                CollSeq *pColl;\n                int bRev;\n                u32 *aPermute;\n                if ((pOp->p5 & 1) == 0) {\n                    aPermute = 0;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    aPermute = pOp[-1].p4.ai + 1;\n                    ((void)0);\n                }\n                n = pOp->p3;\n                pKeyInfo = pOp->p4.pKeyInfo;\n                ((void)0);\n                ((void)0);\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                for (i = 0; i < n; i++) {\n                    idx = aPermute ? aPermute[i] : (u32)i;\n                    ((void)0);\n                    ((void)0);\n                    ;\n                    ;\n                    ((void)0);\n                    pColl = pKeyInfo->aColl[i];\n                    bRev = (pKeyInfo->aSortFlags[i] & 1);\n                    iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);\n                    if (iCompare) {\n                        if ((pKeyInfo->aSortFlags[i] & 2) && ((aMem[p1 + idx].flags & 1) || (aMem[p2 + idx].flags & 1))) {\n                            iCompare = -iCompare;\n                        }\n                        if (bRev)\n                            iCompare = -iCompare;\n                        break;\n                    }\n                }\n                ((void)0);\n                break;\n            }\n          case 14:\n            {\n                ((void)0);\n                ((void)0);\n                if (iCompare < 0) {\n                    ;\n                    pOp = &aOp[pOp->p1 - 1];\n                } else if (iCompare == 0) {\n                    ;\n                    pOp = &aOp[pOp->p2 - 1];\n                } else {\n                    ;\n                    pOp = &aOp[pOp->p3 - 1];\n                }\n                break;\n            }\n          case 44:\n          case 43:\n            {\n                int v1;\n                int v2;\n                v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);\n                v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);\n                if (pOp->opcode == 44) {\n                    static const unsigned char and_logic[] = {0, 0, 0, 0, 1, 2, 0, 2, 2};\n                    v1 = and_logic[v1 * 3 + v2];\n                } else {\n                    static const unsigned char or_logic[] = {0, 1, 2, 1, 1, 1, 2, 1, 2};\n                    v1 = or_logic[v1 * 3 + v2];\n                }\n                pOut = &aMem[pOp->p3];\n                if (v1 == 2) {\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                } else {\n                    pOut->u.i = v1;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                }\n                break;\n            }\n          case 91:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                sqlite3VdbeMemSetInt64(&aMem[pOp->p2], sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);\n                break;\n            }\n          case 19:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                if ((pIn1->flags & 1) == 0) {\n                    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1, 0));\n                } else {\n                    sqlite3VdbeMemSetNull(pOut);\n                }\n                break;\n            }\n          case 114:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetNull(pOut);\n                if ((pIn1->flags & 1) == 0) {\n                    pOut->flags = 4;\n                    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);\n                }\n                break;\n            }\n          case 15:\n            {\n                u32 iAddr;\n                ((void)0);\n                if (p->pFrame) {\n                    iAddr = (int)(pOp - p->aOp);\n                    if ((p->pFrame->aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    p->pFrame->aOnce[iAddr / 8] |= 1 << (iAddr & 7);\n                } else {\n                    if (p->aOp[0].p1 == pOp->p1) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                }\n                ;\n                pOp->p1 = p->aOp[0].p1;\n                break;\n            }\n          case 16:\n            {\n                int c;\n                c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 17:\n            {\n                int c;\n                c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 50:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) != 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 18:\n            {\n                VdbeCursor *pC;\n                u16 typeMask;\n                u32 serialType;\n                ((void)0);\n                ((void)0);\n                if (pOp->p1 >= 0) {\n                    pC = p->apCsr[pOp->p1];\n                    ((void)0);\n                    ((void)0);\n                    if (pOp->p3 < pC->nHdrParsed) {\n                        serialType = pC->aType[pOp->p3];\n                        if (serialType >= 12) {\n                            if (serialType & 1) {\n                                typeMask = 4;\n                            } else {\n                                typeMask = 8;\n                            }\n                        } else {\n                            static const unsigned char aMask[] = {16, 1, 1, 1, 1, 1, 1, 2, 1, 1, 16, 16};\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            typeMask = aMask[serialType];\n                        }\n                    } else {\n                        typeMask = 1 << (pOp->p4.i - 1);\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                    }\n                } else {\n                    ((void)0);\n                    typeMask = 1 << (sqlite3_value_type((sqlite3_value *)&aMem[pOp->p3]) - 1);\n                    ;\n                    ;\n                    ;\n                    ;\n                    ;\n                }\n                ;\n                if (typeMask & pOp->p5) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 92:\n            {\n                if ((aMem[pOp->p1].flags & 1) != 0 || (aMem[pOp->p3].flags & 1) != 0) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n                } else {\n                    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n                }\n                break;\n            }\n          case 51:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 20:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if ((pC) && pC->nullRow) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p3);\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 94:\n            {\n                u32 p2;\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 *aOffset;\n                int len;\n                int i;\n                Mem *pDest;\n                Mem sMem;\n                const u8 *zData;\n                const u8 *zHdr;\n                const u8 *zEndHdr;\n                u64 offset64;\n                u32 t;\n                Mem *pReg;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                p2 = (u32)pOp->p2;\n              op_column_restart:\n                ((void)0);\n                ((void)0);\n                aOffset = pC->aOffset;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pC->cacheStatus != p->cacheCtr) {\n                    if (pC->nullRow) {\n                        if (pC->eCurType == 3 && pC->seekResult > 0) {\n                            pReg = &aMem[pC->seekResult];\n                            ((void)0);\n                            ((void)0);\n                            pC->payloadSize = pC->szRow = pReg->n;\n                            pC->aRow = (u8 *)pReg->z;\n                        } else {\n                            pDest = &aMem[pOp->p3];\n                            ;\n                            sqlite3VdbeMemSetNull(pDest);\n                            goto op_column_out;\n                        }\n                    } else {\n                        pCrsr = pC->uc.pCursor;\n                        if (pC->deferredMoveto) {\n                            u32 iMap;\n                            ((void)0);\n                            if (pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1 + p2]) > 0) {\n                                pC = pC->pAltCursor;\n                                p2 = iMap - 1;\n                                goto op_column_restart;\n                            }\n                            rc = sqlite3VdbeFinishMoveto(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                        } else if (sqlite3BtreeCursorHasMoved(pCrsr)) {\n                            rc = sqlite3VdbeHandleMovedCursor(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                            goto op_column_restart;\n                        }\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);\n                        pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);\n                        ((void)0);\n                        ((void)0);\n                    }\n                    pC->cacheStatus = p->cacheCtr;\n                    if ((aOffset[0] = pC->aRow[0]) < 128) {\n                        pC->iHdrOffset = 1;\n                    } else {\n                        pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);\n                    }\n                    pC->nHdrParsed = 0;\n                    if (pC->szRow < aOffset[0]) {\n                        pC->aRow = 0;\n                        pC->szRow = 0;\n                        if (aOffset[0] > 98307 || aOffset[0] > pC->payloadSize) {\n                            goto op_column_corrupt;\n                        }\n                    } else {\n                        zData = pC->aRow;\n                        ((void)0);\n                        ;\n                        goto op_column_read_header;\n                    }\n                } else if (sqlite3BtreeCursorHasMoved(pC->uc.pCursor)) {\n                    rc = sqlite3VdbeHandleMovedCursor(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    goto op_column_restart;\n                }\n                if (pC->nHdrParsed <= p2) {\n                    if (pC->iHdrOffset < aOffset[0]) {\n                        if (pC->aRow == 0) {\n                            __builtin___memset_chk(&sMem, 0, sizeof (sMem), __builtin_object_size(&sMem, 0));\n                            rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor, aOffset[0], &sMem);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                            zData = (u8 *)sMem.z;\n                        } else {\n                            zData = pC->aRow;\n                        }\n                      op_column_read_header:\n                        i = pC->nHdrParsed;\n                        offset64 = aOffset[i];\n                        zHdr = zData + pC->iHdrOffset;\n                        zEndHdr = zData + aOffset[0];\n                        ;\n                        do {\n                            if ((pC->aType[i] = t = zHdr[0]) < 128) {\n                                zHdr++;\n                                offset64 += sqlite3VdbeOneByteSerialTypeLen(t);\n                            } else {\n                                zHdr += sqlite3GetVarint32(zHdr, &t);\n                                pC->aType[i] = t;\n                                offset64 += sqlite3VdbeSerialTypeLen(t);\n                            }\n                            aOffset[++i] = (u32)(offset64 & 4294967295U);\n                        } while ((u32)i <= p2 && zHdr < zEndHdr);\n                        if ((zHdr >= zEndHdr && (zHdr > zEndHdr || offset64 != pC->payloadSize)) || (offset64 > pC->payloadSize)) {\n                            if (aOffset[0] == 0) {\n                                i = 0;\n                                zHdr = zEndHdr;\n                            } else {\n                                if (pC->aRow == 0)\n                                    sqlite3VdbeMemRelease(&sMem);\n                                goto op_column_corrupt;\n                            }\n                        }\n                        pC->nHdrParsed = i;\n                        pC->iHdrOffset = (u32)(zHdr - zData);\n                        if (pC->aRow == 0)\n                            sqlite3VdbeMemRelease(&sMem);\n                    } else {\n                        t = 0;\n                    }\n                    if (pC->nHdrParsed <= p2) {\n                        pDest = &aMem[pOp->p3];\n                        ;\n                        if (pOp->p4type == (-10)) {\n                            sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 8192);\n                        } else {\n                            sqlite3VdbeMemSetNull(pDest);\n                        }\n                        goto op_column_out;\n                    }\n                } else {\n                    t = pC->aType[p2];\n                }\n                ((void)0);\n                ((void)0);\n                pDest = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                if ((((pDest)->flags & (32768 | 4096)) != 0)) {\n                    sqlite3VdbeMemSetNull(pDest);\n                }\n                ((void)0);\n                if (pC->szRow >= aOffset[p2 + 1]) {\n                    zData = pC->aRow + aOffset[p2];\n                    if (t < 12) {\n                        sqlite3VdbeSerialGet(zData, t, pDest);\n                    } else {\n                        static const u16 aFlag[] = {16, 2 | 512};\n                        pDest->n = len = (t - 12) / 2;\n                        pDest->enc = encoding;\n                        if (pDest->szMalloc < len + 2) {\n                            if (len > db->aLimit[0])\n                                goto too_big;\n                            pDest->flags = 1;\n                            if (sqlite3VdbeMemGrow(pDest, len + 2, 0))\n                                goto no_mem;\n                        } else {\n                            pDest->z = pDest->zMalloc;\n                        }\n                        __builtin___memcpy_chk(pDest->z, zData, len, __builtin_object_size(pDest->z, 0));\n                        pDest->z[len] = 0;\n                        pDest->z[len + 1] = 0;\n                        pDest->flags = aFlag[t & 1];\n                    }\n                } else {\n                    pDest->enc = encoding;\n                    if (((pOp->p5 & (64 | 128)) != 0 && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & 128) != 0)) || (len = sqlite3VdbeSerialTypeLen(t)) == 0) {\n                        sqlite3VdbeSerialGet((u8 *)sqlite3CtypeMap, t, pDest);\n                    } else {\n                        if (len > db->aLimit[0])\n                            goto too_big;\n                        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        sqlite3VdbeSerialGet((const u8 *)pDest->z, t, pDest);\n                        pDest->flags &= ~16384;\n                    }\n                }\n              op_column_out:\n                ;\n                ;\n                break;\n              op_column_corrupt:\n                if (aOp[0].p3 > 0) {\n                    pOp = &aOp[aOp[0].p3 - 1];\n                    break;\n                } else {\n                    rc = sqlite3CorruptError(93251);\n                    goto abort_due_to_error;\n                }\n            }\n          case 95:\n            {\n                Table *pTab;\n                Column *aCol;\n                int i;\n                ((void)0);\n                pTab = pOp->p4.pTab;\n                ((void)0);\n                ((void)0);\n                aCol = pTab->aCol;\n                pIn1 = &aMem[pOp->p1];\n                for (i = 0; i < pTab->nCol; i++) {\n                    if (aCol[i].colFlags & 96) {\n                        if (aCol[i].colFlags & 32)\n                            continue;\n                        if (pOp->p3) {\n                            pIn1++;\n                            continue;\n                        }\n                    }\n                    ((void)0);\n                    applyAffinity(pIn1, aCol[i].affinity, encoding);\n                    if ((pIn1->flags & 1) == 0) {\n                        switch (aCol[i].eCType) {\n                          case 2:\n                            {\n                                if ((pIn1->flags & 16) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 4:\n                          case 3:\n                            {\n                                if ((pIn1->flags & 4) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 6:\n                            {\n                                if ((pIn1->flags & 2) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 5:\n                            {\n                                ;\n                                ((void)0);\n                                if (pIn1->flags & 4) {\n                                    ;\n                                    ;\n                                    ;\n                                    ;\n                                    if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                        pIn1->flags |= 32;\n                                        pIn1->flags &= ~4;\n                                    } else {\n                                        pIn1->u.r = (double)pIn1->u.i;\n                                        pIn1->flags |= 8;\n                                        pIn1->flags &= ~4;\n                                    }\n                                } else if ((pIn1->flags & (8 | 32)) == 0) {\n                                    goto vdbe_type_error;\n                                }\n                                break;\n                            }\n                          default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    ;\n                    pIn1++;\n                }\n                ((void)0);\n                break;\n              vdbe_type_error:\n                sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab->zName, aCol[i].zCnName);\n                rc = (19 | (12 << 8));\n                goto abort_due_to_error;\n            }\n          case 96:\n            {\n                const char *zAffinity;\n                zAffinity = pOp->p4.z;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                while (1)\n                    {\n                        ((void)0);\n                        ((void)0);\n                        applyAffinity(pIn1, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pIn1->flags & 4) != 0) {\n                            ;\n                            ;\n                            ;\n                            ;\n                            if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                pIn1->flags |= 32;\n                                pIn1->flags &= ~4;\n                            } else {\n                                pIn1->u.r = (double)pIn1->u.i;\n                                pIn1->flags |= 8;\n                                pIn1->flags &= ~4;\n                            }\n                        }\n                        ;\n                        zAffinity++;\n                        if (zAffinity[0] == 0)\n                            break;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 97:\n            {\n                Mem *pRec;\n                u64 nData;\n                int nHdr;\n                i64 nByte;\n                i64 nZero;\n                int nVarint;\n                u32 serial_type;\n                Mem *pData0;\n                Mem *pLast;\n                int nField;\n                char *zAffinity;\n                u32 len;\n                u8 *zHdr;\n                u8 *zPayload;\n                nData = 0;\n                nHdr = 0;\n                nZero = 0;\n                nField = pOp->p1;\n                zAffinity = pOp->p4.z;\n                ((void)0);\n                pData0 = &aMem[nField];\n                nField = pOp->p2;\n                pLast = &pData0[nField - 1];\n                ((void)0);\n                pOut = &aMem[pOp->p3];\n                ;\n                ((void)0);\n                if (zAffinity) {\n                    pRec = pData0;\n                    do {\n                        applyAffinity(pRec, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pRec->flags & 4)) {\n                            pRec->flags |= 32;\n                            pRec->flags &= ~(4);\n                        }\n                        ;\n                        zAffinity++;\n                        pRec++;\n                        ((void)0);\n                    } while (zAffinity[0]);\n                }\n                pRec = pLast;\n                do {\n                    ((void)0);\n                    if (pRec->flags & 1) {\n                        if (pRec->flags & 1024) {\n                            ((void)0);\n                            pRec->uTemp = 10;\n                        } else {\n                            pRec->uTemp = 0;\n                        }\n                        nHdr++;\n                    } else if (pRec->flags & (4 | 32)) {\n                        i64 i = pRec->u.i;\n                        u64 uu;\n                        ;\n                        ;\n                        if (i < 0) {\n                            uu = ~i;\n                        } else {\n                            uu = i;\n                        }\n                        nHdr++;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        if (uu <= 127) {\n                            if ((i & 1) == i && p->minWriteFileFormat >= 4) {\n                                pRec->uTemp = 8 + (u32)uu;\n                            } else {\n                                nData++;\n                                pRec->uTemp = 1;\n                            }\n                        } else if (uu <= 32767) {\n                            nData += 2;\n                            pRec->uTemp = 2;\n                        } else if (uu <= 8388607) {\n                            nData += 3;\n                            pRec->uTemp = 3;\n                        } else if (uu <= 2147483647) {\n                            nData += 4;\n                            pRec->uTemp = 4;\n                        } else if (uu <= 140737488355327LL) {\n                            nData += 6;\n                            pRec->uTemp = 5;\n                        } else {\n                            nData += 8;\n                            if (pRec->flags & 32) {\n                                pRec->u.r = (double)pRec->u.i;\n                                pRec->flags &= ~32;\n                                pRec->flags |= 8;\n                                pRec->uTemp = 7;\n                            } else {\n                                pRec->uTemp = 6;\n                            }\n                        }\n                    } else if (pRec->flags & 8) {\n                        nHdr++;\n                        nData += 8;\n                        pRec->uTemp = 7;\n                    } else {\n                        ((void)0);\n                        ((void)0);\n                        len = (u32)pRec->n;\n                        serial_type = (len * 2) + 12 + ((pRec->flags & 2) != 0);\n                        if (pRec->flags & 1024) {\n                            serial_type += pRec->u.nZero * 2;\n                            if (nData) {\n                                if (sqlite3VdbeMemExpandBlob(pRec))\n                                    goto no_mem;\n                                len += pRec->u.nZero;\n                            } else {\n                                nZero += pRec->u.nZero;\n                            }\n                        }\n                        nData += len;\n                        nHdr += sqlite3VarintLen(serial_type);\n                        pRec->uTemp = serial_type;\n                    }\n                    if (pRec == pData0)\n                        break;\n                    pRec--;\n                } while (1);\n                ;\n                ;\n                if (nHdr <= 126) {\n                    nHdr += 1;\n                } else {\n                    nVarint = sqlite3VarintLen(nHdr);\n                    nHdr += nVarint;\n                    if (nVarint < sqlite3VarintLen(nHdr))\n                        nHdr++;\n                }\n                nByte = nHdr + nData;\n                if (nByte + nZero <= pOut->szMalloc) {\n                    pOut->z = pOut->zMalloc;\n                } else {\n                    if (nByte + nZero > db->aLimit[0]) {\n                        goto too_big;\n                    }\n                    if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {\n                        goto no_mem;\n                    }\n                }\n                pOut->n = (int)nByte;\n                pOut->flags = 16;\n                if (nZero) {\n                    pOut->u.nZero = nZero;\n                    pOut->flags |= 1024;\n                }\n                ;\n                zHdr = (u8 *)pOut->z;\n                zPayload = zHdr + nHdr;\n                if (nHdr < 128) {\n                    *(zHdr++) = nHdr;\n                } else {\n                    zHdr += sqlite3PutVarint(zHdr, nHdr);\n                }\n                ((void)0);\n                pRec = pData0;\n                while (1)\n                    {\n                        serial_type = pRec->uTemp;\n                        if (serial_type <= 7) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type == 0) {\n                            } else {\n                                u64 v;\n                                u32 i;\n                                if (serial_type == 7) {\n                                    ((void)0);\n                                    __builtin___memcpy_chk(&v, &pRec->u.r, sizeof (v), __builtin_object_size(&v, 0));\n                                    ;\n                                } else {\n                                    v = pRec->u.i;\n                                }\n                                len = i = sqlite3SmallTypeSizes[serial_type];\n                                ((void)0);\n                                while (1)\n                                    {\n                                        zPayload[--i] = (u8)(v & 255);\n                                        if (i == 0)\n                                            break;\n                                        v >>= 8;\n                                    }\n                                zPayload += len;\n                            }\n                        } else if (serial_type < 128) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type >= 14 && pRec->n > 0) {\n                                ((void)0);\n                                __builtin___memcpy_chk(zPayload, pRec->z, pRec->n, __builtin_object_size(zPayload, 0));\n                                zPayload += pRec->n;\n                            }\n                        } else {\n                            zHdr += sqlite3PutVarint(zHdr, serial_type);\n                            if (pRec->n) {\n                                ((void)0);\n                                __builtin___memcpy_chk(zPayload, pRec->z, pRec->n, __builtin_object_size(zPayload, 0));\n                                zPayload += pRec->n;\n                            }\n                        }\n                        if (pRec == pLast)\n                            break;\n                        pRec++;\n                    }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                break;\n            }\n          case 98:\n            {\n                i64 nEntry;\n                BtCursor *pCrsr;\n                ((void)0);\n                pCrsr = p->apCsr[pOp->p1]->uc.pCursor;\n                ((void)0);\n                if (pOp->p3) {\n                    nEntry = sqlite3BtreeRowCountEst(pCrsr);\n                } else {\n                    nEntry = 0;\n                    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = nEntry;\n                goto check_for_interrupt;\n            }\n          case 0:\n            {\n                int p1;\n                char *zName;\n                int nName;\n                Savepoint *pNew;\n                Savepoint *pSavepoint;\n                Savepoint *pTmp;\n                int iSavepoint;\n                int ii;\n                p1 = pOp->p1;\n                zName = pOp->p4.z;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (p1 == 0) {\n                    if (db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot open savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        nName = sqlite3Strlen30(zName);\n                        ((void)0);\n                        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);\n                        if (pNew) {\n                            pNew->zName = (char *)&pNew[1];\n                            __builtin___memcpy_chk(pNew->zName, zName, nName + 1, __builtin_object_size(pNew->zName, 0));\n                            if (db->autoCommit) {\n                                db->autoCommit = 0;\n                                db->isTransactionSavepoint = 1;\n                            } else {\n                                db->nSavepoint++;\n                            }\n                            pNew->pNext = db->pSavepoint;\n                            db->pSavepoint = pNew;\n                            pNew->nDeferredCons = db->nDeferredCons;\n                            pNew->nDeferredImmCons = db->nDeferredImmCons;\n                        }\n                    }\n                } else {\n                    ((void)0);\n                    iSavepoint = 0;\n                    for (pSavepoint = db->pSavepoint; pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName); pSavepoint = pSavepoint->pNext) {\n                        iSavepoint++;\n                    }\n                    if (!pSavepoint) {\n                        sqlite3VdbeError(p, \"no such savepoint: %s\", zName);\n                        rc = 1;\n                    } else if (db->nVdbeWrite > 0 && p1 == 1) {\n                        sqlite3VdbeError(p, \"cannot release savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;\n                        if (isTransaction && p1 == 1) {\n                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                                goto vdbe_return;\n                            }\n                            db->autoCommit = 1;\n                            if (sqlite3VdbeHalt(p) == 5) {\n                                p->pc = (int)(pOp - aOp);\n                                db->autoCommit = 0;\n                                p->rc = rc = 5;\n                                goto vdbe_return;\n                            }\n                            rc = p->rc;\n                            if (rc) {\n                                db->autoCommit = 0;\n                            } else {\n                                db->isTransactionSavepoint = 0;\n                            }\n                        } else {\n                            int isSchemaChange;\n                            iSavepoint = db->nSavepoint - iSavepoint - 1;\n                            if (p1 == 2) {\n                                isSchemaChange = (db->mDbFlags & 1) != 0;\n                                for (ii = 0; ii < db->nDb; ii++) {\n                                    rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, (4 | (2 << 8)), isSchemaChange == 0);\n                                    if (rc != 0)\n                                        goto abort_due_to_error;\n                                }\n                            } else {\n                                ((void)0);\n                                isSchemaChange = 0;\n                            }\n                            for (ii = 0; ii < db->nDb; ii++) {\n                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);\n                                if (rc != 0) {\n                                    goto abort_due_to_error;\n                                }\n                            }\n                            if (isSchemaChange) {\n                                sqlite3ExpirePreparedStatements(db, 0);\n                                sqlite3ResetAllSchemasOfConnection(db);\n                                db->mDbFlags |= 1;\n                            }\n                        }\n                        if (rc)\n                            goto abort_due_to_error;\n                        while (db->pSavepoint != pSavepoint)\n                            {\n                                pTmp = db->pSavepoint;\n                                db->pSavepoint = pTmp->pNext;\n                                sqlite3DbFree(db, pTmp);\n                                db->nSavepoint--;\n                            }\n                        if (p1 == 1) {\n                            ((void)0);\n                            db->pSavepoint = pSavepoint->pNext;\n                            sqlite3DbFree(db, pSavepoint);\n                            if (!isTransaction) {\n                                db->nSavepoint--;\n                            }\n                        } else {\n                            ((void)0);\n                            db->nDeferredCons = pSavepoint->nDeferredCons;\n                            db->nDeferredImmCons = pSavepoint->nDeferredImmCons;\n                        }\n                        if (!isTransaction || p1 == 2) {\n                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                if (p->eVdbeState == 3) {\n                    rc = 101;\n                    goto vdbe_return;\n                }\n                break;\n            }\n          case 1:\n            {\n                int desiredAutoCommit;\n                int iRollback;\n                desiredAutoCommit = pOp->p1;\n                iRollback = pOp->p2;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (desiredAutoCommit != db->autoCommit) {\n                    if (iRollback) {\n                        ((void)0);\n                        sqlite3RollbackAll(db, (4 | (2 << 8)));\n                        db->autoCommit = 1;\n                    } else if (desiredAutoCommit && db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot commit transaction - SQL statements in progress\");\n                        rc = 5;\n                        goto abort_due_to_error;\n                    } else if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                        goto vdbe_return;\n                    } else {\n                        db->autoCommit = (u8)desiredAutoCommit;\n                    }\n                    if (sqlite3VdbeHalt(p) == 5) {\n                        p->pc = (int)(pOp - aOp);\n                        db->autoCommit = (u8)(1 - desiredAutoCommit);\n                        p->rc = rc = 5;\n                        goto vdbe_return;\n                    }\n                    sqlite3CloseSavepoints(db);\n                    if (p->rc == 0) {\n                        rc = 101;\n                    } else {\n                        rc = 1;\n                    }\n                    goto vdbe_return;\n                } else {\n                    sqlite3VdbeError(p, (!desiredAutoCommit) ? \"cannot start a transaction within a transaction\" : ((iRollback) ? \"cannot rollback - no transaction is active\" : \"cannot commit - no transaction is active\"));\n                    rc = 1;\n                    goto abort_due_to_error;\n                }\n                ((void)0);\n            }\n          case 2:\n            {\n                Btree *pBt;\n                Db *pDb;\n                int iMeta = 0;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pOp->p2 && (db->flags & (1048576 | ((u64)(2) << 32))) != 0) {\n                    if (db->flags & 1048576) {\n                        rc = 8;\n                    } else {\n                        rc = 11;\n                    }\n                    goto abort_due_to_error;\n                }\n                pDb = &db->aDb[pOp->p1];\n                pBt = pDb->pBt;\n                if (pBt) {\n                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);\n                    ;\n                    ;\n                    if (rc != 0) {\n                        if ((rc & 255) == 5) {\n                            p->pc = (int)(pOp - aOp);\n                            p->rc = rc;\n                            goto vdbe_return;\n                        }\n                        goto abort_due_to_error;\n                    }\n                    if (p->usesStmtJournal && pOp->p2 && (db->autoCommit == 0 || db->nVdbeRead > 1)) {\n                        ((void)0);\n                        if (p->iStatement == 0) {\n                            ((void)0);\n                            db->nStatement++;\n                            p->iStatement = db->nSavepoint + db->nStatement;\n                        }\n                        rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);\n                        }\n                        p->nStmtDefCons = db->nDeferredCons;\n                        p->nStmtDefImmCons = db->nDeferredImmCons;\n                    }\n                }\n                ((void)0);\n                if (rc == 0 && pOp->p5 && (iMeta != pOp->p3 || pDb->pSchema->iGeneration != pOp->p4.i)) {\n                    sqlite3DbFree(db, p->zErrMsg);\n                    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {\n                        sqlite3ResetOneSchema(db, pOp->p1);\n                    }\n                    p->expired = 1;\n                    rc = 17;\n                    p->changeCntOn = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 99:\n            {\n                int iMeta;\n                int iDb;\n                int iCookie;\n                ((void)0);\n                iDb = pOp->p1;\n                iCookie = pOp->p3;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = iMeta;\n                break;\n            }\n          case 100:\n            {\n                Db *pDb;\n                ;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[pOp->p1];\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);\n                if (pOp->p2 == 1) {\n                    *(u32 *)&pDb->pSchema->schema_cookie = *(u32 *)&pOp->p3 - pOp->p5;\n                    db->mDbFlags |= 1;\n                    sqlite3FkClearTriggerCache(db, pOp->p1);\n                } else if (pOp->p2 == 2) {\n                    pDb->pSchema->file_format = pOp->p3;\n                }\n                if (pOp->p1 == 1) {\n                    sqlite3ExpirePreparedStatements(db, 0);\n                    p->expired = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 101:\n            {\n                int nField;\n                KeyInfo *pKeyInfo;\n                u32 p2;\n                int iDb;\n                int wrFlag;\n                Btree *pX;\n                VdbeCursor *pCur;\n                Db *pDb;\n                ((void)0);\n                ((void)0);\n                pCur = p->apCsr[pOp->p1];\n                if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {\n                    ((void)0);\n                    ((void)0);\n                    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n                    goto open_cursor_set_hints;\n                }\n              case 112:\n              case 113:\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (p->expired == 1) {\n                    rc = (4 | (2 << 8));\n                    goto abort_due_to_error;\n                }\n                nField = 0;\n                pKeyInfo = 0;\n                p2 = (u32)pOp->p2;\n                iDb = pOp->p3;\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[iDb];\n                pX = pDb->pBt;\n                ((void)0);\n                if (pOp->opcode == 113) {\n                    ((void)0);\n                    wrFlag = 4 | (pOp->p5 & 8);\n                    ((void)0);\n                    if (pDb->pSchema->file_format < p->minWriteFileFormat) {\n                        p->minWriteFileFormat = pDb->pSchema->file_format;\n                    }\n                } else {\n                    wrFlag = 0;\n                }\n                if (pOp->p5 & 16) {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    pIn2 = &aMem[p2];\n                    ((void)0);\n                    ((void)0);\n                    sqlite3VdbeMemIntegerify(pIn2);\n                    p2 = (int)pIn2->u.i;\n                    ((void)0);\n                }\n                if (pOp->p4type == (-8)) {\n                    pKeyInfo = pOp->p4.pKeyInfo;\n                    ((void)0);\n                    ((void)0);\n                    nField = pKeyInfo->nAllField;\n                } else if (pOp->p4type == (-3)) {\n                    nField = pOp->p4.i;\n                }\n                ((void)0);\n                ((void)0);\n                ;\n                pCur = allocateCursor(p, pOp->p1, nField, 0);\n                if (pCur == 0)\n                    goto no_mem;\n                pCur->iDb = iDb;\n                pCur->nullRow = 1;\n                pCur->isOrdered = 1;\n                pCur->pgnoRoot = p2;\n                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);\n                pCur->pKeyInfo = pKeyInfo;\n                pCur->isTable = pOp->p4type != (-8);\n              open_cursor_set_hints:\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (pOp->p5 & (1 | 2)));\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 115:\n            {\n                VdbeCursor *pOrig;\n                VdbeCursor *pCx;\n                pOrig = p->apCsr[pOp->p2];\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->isEphemeral = 1;\n                pCx->pKeyInfo = pOrig->pKeyInfo;\n                pCx->isTable = pOrig->isTable;\n                pCx->pgnoRoot = pOrig->pgnoRoot;\n                pCx->isOrdered = pOrig->isOrdered;\n                pCx->ub.pBtx = pOrig->ub.pBtx;\n                pCx->noReuse = 1;\n                pOrig->noReuse = 1;\n                rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);\n                ((void)0);\n                break;\n            }\n          case 116:\n          case 118:\n            {\n                VdbeCursor *pCx;\n                KeyInfo *pKeyInfo;\n                static const int vfsFlags = 2 | 4 | 16 | 8 | 1024;\n                ((void)0);\n                ((void)0);\n                if (pOp->p3 > 0) {\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    aMem[pOp->p3].n = 0;\n                    aMem[pOp->p3].z = \"\";\n                }\n                pCx = p->apCsr[pOp->p1];\n                if (pCx && !pCx->noReuse && (pOp->p2 <= pCx->nField)) {\n                    ((void)0);\n                    pCx->seqCount = 0;\n                    pCx->cacheStatus = 0;\n                    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);\n                } else {\n                    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);\n                    if (pCx == 0)\n                        goto no_mem;\n                    pCx->isEphemeral = 1;\n                    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx, 1 | 4 | pOp->p5, vfsFlags);\n                    if (rc == 0) {\n                        rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);\n                        if (rc == 0) {\n                            if ((pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != 0) {\n                                ((void)0);\n                                rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot, 2 | pOp->p5);\n                                if (rc == 0) {\n                                    ((void)0);\n                                    ((void)0);\n                                    ((void)0);\n                                    rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pKeyInfo, pCx->uc.pCursor);\n                                }\n                                pCx->isTable = 0;\n                            } else {\n                                pCx->pgnoRoot = 1;\n                                rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 4, 0, pCx->uc.pCursor);\n                                pCx->isTable = 1;\n                            }\n                        }\n                        pCx->isOrdered = (pOp->p5 != 8);\n                        if (rc) {\n                            sqlite3BtreeClose(pCx->ub.pBtx);\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pCx->nullRow = 1;\n                break;\n            }\n          case 119:\n            {\n                VdbeCursor *pCx;\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->pKeyInfo = pOp->p4.pKeyInfo;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 120:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if ((pC->seqCount++) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 121:\n            {\n                VdbeCursor *pCx;\n                ((void)0);\n                ((void)0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->seekResult = pOp->p2;\n                pCx->isTable = 1;\n                pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                ((void)0);\n                break;\n            }\n          case 122:\n            {\n                ((void)0);\n                sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n                p->apCsr[pOp->p1] = 0;\n                break;\n            }\n          case 21:\n          case 22:\n          case 23:\n          case 24:\n            {\n                int res;\n                int oc;\n                VdbeCursor *pC;\n                UnpackedRecord r;\n                int nField;\n                i64 iKey;\n                int eqOnly;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                oc = pOp->opcode;\n                eqOnly = 0;\n                pC->nullRow = 0;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pC->isTable) {\n                    u16 flags3, newType;\n                    ((void)0);\n                    pIn3 = &aMem[pOp->p3];\n                    flags3 = pIn3->flags;\n                    if ((flags3 & (4 | 8 | 32 | 2)) == 2) {\n                        applyNumericAffinity(pIn3, 0);\n                    }\n                    iKey = sqlite3VdbeIntValue(pIn3);\n                    newType = pIn3->flags;\n                    pIn3->flags = flags3;\n                    if ((newType & (4 | 32)) == 0) {\n                        int c;\n                        if ((newType & 8) == 0) {\n                            if ((newType & 1) || oc >= 23) {\n                                ;\n                                goto jump_to_p2;\n                            } else {\n                                rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                                if (rc != 0)\n                                    goto abort_due_to_error;\n                                goto seek_not_found;\n                            }\n                        }\n                        c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n                        if (c > 0) {\n                            ((void)0);\n                            ((void)0);\n                            ((void)0);\n                            if ((oc & 1) == (24 & 1))\n                                oc--;\n                        } else if (c < 0) {\n                            ((void)0);\n                            ((void)0);\n                            ((void)0);\n                            if ((oc & 1) == (21 & 1))\n                                oc++;\n                        }\n                    }\n                    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n                    pC->movetoTarget = iKey;\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                } else {\n                    if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2)) {\n                        eqOnly = 1;\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                    }\n                    nField = pOp->p4.i;\n                    ((void)0);\n                    ((void)0);\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.nField = (u16)nField;\n                    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    r.aMem = &aMem[pOp->p3];\n                    r.eqSeen = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (eqOnly && r.eqSeen == 0) {\n                        ((void)0);\n                        goto seek_not_found;\n                    }\n                }\n                if (oc >= 23) {\n                    ((void)0);\n                    if (res < 0 || (res == 0 && oc == 24)) {\n                        res = 0;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = 0;\n                    }\n                } else {\n                    ((void)0);\n                    if (res > 0 || (res == 0 && oc == 21)) {\n                        res = 0;\n                        rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = sqlite3BtreeEof(pC->uc.pCursor);\n                    }\n                }\n              seek_not_found:\n                ((void)0);\n                ;\n                if (res) {\n                    goto jump_to_p2;\n                } else if (eqOnly) {\n                    ((void)0);\n                    pOp++;\n                }\n                break;\n            }\n          case 124:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nStep;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp[1].p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (!sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)) {\n                    break;\n                }\n                nStep = pOp->p1;\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp[1].p4.i;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp[1].p3];\n                res = 0;\n                while (1)\n                    {\n                        rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res > 0 && pOp->p5 == 0) {\n                          seekscan_search_fail:\n                            ;\n                            pOp++;\n                            goto jump_to_p2;\n                        }\n                        if (res >= 0) {\n                            ;\n                            goto jump_to_p2;\n                            break;\n                        }\n                        if (nStep <= 0) {\n                            ;\n                            break;\n                        }\n                        nStep--;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc) {\n                            if (rc == 101) {\n                                rc = 0;\n                                goto seekscan_search_fail;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    }\n                break;\n            }\n          case 125:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pC->seekHit < pOp->p2) {\n                    pC->seekHit = pOp->p2;\n                } else if (pC->seekHit > pOp->p3) {\n                    pC->seekHit = pOp->p3;\n                }\n                break;\n            }\n          case 25:\n            {\n                VdbeCursor *pCur;\n                ((void)0);\n                pCur = p->apCsr[pOp->p1];\n                ;\n                if (pCur == 0 || pCur->nullRow) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                break;\n            }\n          case 26:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if (pC->seekHit >= pOp->p4.i)\n                    break;\n            }\n          case 27:\n          case 28:\n          case 29:\n            {\n                int alreadyExists;\n                int ii;\n                VdbeCursor *pC;\n                UnpackedRecord *pIdxKey;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                r.aMem = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                r.nField = (u16)pOp->p4.i;\n                if (r.nField > 0) {\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = (((r.aMem)->flags & 1024) ? sqlite3VdbeMemExpandBlob(r.aMem) : 0);\n                    ((void)0);\n                    if (rc)\n                        goto no_mem;\n                    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);\n                    if (pIdxKey == 0)\n                        goto no_mem;\n                    sqlite3VdbeRecordUnpack(pC->pKeyInfo, r.aMem->n, r.aMem->z, pIdxKey);\n                    pIdxKey->default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);\n                    sqlite3DbFreeNN(db, pIdxKey);\n                }\n                if (rc != 0) {\n                    goto abort_due_to_error;\n                }\n                alreadyExists = (pC->seekResult == 0);\n                pC->nullRow = 1 - alreadyExists;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pOp->opcode == 29) {\n                    ;\n                    if (alreadyExists)\n                        goto jump_to_p2;\n                } else {\n                    if (!alreadyExists) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    if (pOp->opcode == 27) {\n                        for (ii = 0; ii < r.nField; ii++) {\n                            if (r.aMem[ii].flags & 1) {\n                                ;\n                                goto jump_to_p2;\n                            }\n                        }\n                    }\n                    ;\n                    if (pOp->opcode == 26) {\n                        pC->seekHit = pOp->p4.i;\n                    }\n                }\n                break;\n            }\n          case 30:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                u64 iKey;\n                pIn3 = &aMem[pOp->p3];\n                ;\n                ;\n                ;\n                ;\n                if ((pIn3->flags & (4 | 32)) == 0) {\n                    Mem x = pIn3[0];\n                    applyAffinity(&x, 67, encoding);\n                    if ((x.flags & 4) == 0)\n                        goto jump_to_p2;\n                    iKey = x.u.i;\n                    goto notExistsWithKey;\n                }\n              case 31:\n                pIn3 = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                iKey = pIn3->u.i;\n              notExistsWithKey:\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                res = 0;\n                rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n                ((void)0);\n                pC->movetoTarget = iKey;\n                pC->nullRow = 0;\n                pC->cacheStatus = 0;\n                pC->deferredMoveto = 0;\n                ;\n                pC->seekResult = res;\n                if (res != 0) {\n                    ((void)0);\n                    if (pOp->p2 == 0) {\n                        rc = sqlite3CorruptError(95494);\n                    } else {\n                        goto jump_to_p2;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 126:\n            {\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n                break;\n            }\n          case 127:\n            {\n                i64 v;\n                VdbeCursor *pC;\n                int res;\n                int cnt;\n                Mem *pMem;\n                VdbeFrame *pFrame;\n                v = 0;\n                res = 0;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                {\n                    ((void)0);\n                    if (!pC->useRandomRowid) {\n                        rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                        if (rc != 0) {\n                            goto abort_due_to_error;\n                        }\n                        if (res) {\n                            v = 1;\n                        } else {\n                            ((void)0);\n                            v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                            if (v >= (i64)((((u64)2147483647) << 32) | (u64)4294967295U)) {\n                                pC->useRandomRowid = 1;\n                            } else {\n                                v++;\n                            }\n                        }\n                    }\n                    if (pOp->p3) {\n                        ((void)0);\n                        if (p->pFrame) {\n                            for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                                ;\n                            ((void)0);\n                            pMem = &pFrame->aMem[pOp->p3];\n                        } else {\n                            ((void)0);\n                            pMem = &aMem[pOp->p3];\n                            ;\n                        }\n                        ((void)0);\n                        ;\n                        sqlite3VdbeMemIntegerify(pMem);\n                        ((void)0);\n                        if (pMem->u.i == (i64)((((u64)2147483647) << 32) | (u64)4294967295U) || pC->useRandomRowid) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        if (v < pMem->u.i + 1) {\n                            v = pMem->u.i + 1;\n                        }\n                        pMem->u.i = v;\n                    }\n                    if (pC->useRandomRowid) {\n                        ((void)0);\n                        cnt = 0;\n                        do {\n                            sqlite3_randomness(sizeof (v), &v);\n                            v &= ((i64)((((u64)2147483647) << 32) | (u64)4294967295U) >> 1);\n                            v++;\n                        } while (((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v, 0, &res)) == 0) && (res == 0) && (++cnt < 100));\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res == 0) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        ((void)0);\n                    }\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 128:\n            {\n                Mem *pData;\n                Mem *pKey;\n                VdbeCursor *pC;\n                int seekResult;\n                const char *zDb;\n                Table *pTab;\n                BtreePayload x;\n                pData = &aMem[pOp->p2];\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                pKey = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                ;\n                x.nKey = pKey->u.i;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    ((void)0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    ((void)0);\n                } else {\n                    pTab = 0;\n                    zDb = 0;\n                }\n                ((void)0);\n                if (pOp->p5 & 1) {\n                    p->nChange++;\n                    if (pOp->p5 & 32)\n                        db->lastRowid = x.nKey;\n                }\n                ((void)0);\n                x.pData = pData->z;\n                x.nData = pData->n;\n                seekResult = ((pOp->p5 & 16) ? pC->seekResult : 0);\n                if (pData->flags & 1024) {\n                    x.nZero = pData->u.nZero;\n                } else {\n                    x.nZero = 0;\n                }\n                x.pKey = 0;\n                ((void)0);\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), seekResult);\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pTab) {\n                    ((void)0);\n                    ((void)0);\n                    db->xUpdateCallback(db->pUpdateArg, (pOp->p5 & 4) ? 23 : 18, zDb, pTab->zName, x.nKey);\n                }\n                break;\n            }\n          case 129:\n            {\n                VdbeCursor *pDest;\n                VdbeCursor *pSrc;\n                i64 iKey;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDest = p->apCsr[pOp->p1];\n                pSrc = p->apCsr[pOp->p2];\n                iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n                rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 130:\n            {\n                VdbeCursor *pC;\n                const char *zDb;\n                Table *pTab;\n                int opflags;\n                opflags = pOp->p2;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    ((void)0);\n                    ((void)0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    if ((pOp->p5 & 2) != 0 && pC->isTable) {\n                        pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                    }\n                } else {\n                    zDb = 0;\n                    pTab = 0;\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (opflags & 1) {\n                    p->nChange++;\n                    if (db->xUpdateCallback && (pTab != 0) && (((pTab)->tabFlags & 128) == 0)) {\n                        db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName, pC->movetoTarget);\n                        ((void)0);\n                    }\n                }\n                break;\n            }\n          case 131:\n            {\n                sqlite3VdbeSetChanges(db, p->nChange);\n                p->nChange = 0;\n                break;\n            }\n          case 132:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nKeyCol;\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pIn3 = &aMem[pOp->p3];\n                nKeyCol = pOp->p4.i;\n                res = 0;\n                rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n            ;\n          case 133:\n            {\n                VdbeCursor *pC;\n                pOut = &aMem[pOp->p2];\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                rc = sqlite3VdbeSorterRowkey(pC, pOut);\n                ((void)0);\n                ((void)0);\n                if (rc)\n                    goto abort_due_to_error;\n                p->apCsr[pOp->p3]->cacheStatus = 0;\n                break;\n            }\n          case 134:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 n;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                ((void)0);\n                n = sqlite3BtreePayloadSize(pCrsr);\n                if (n > (u32)db->aLimit[0]) {\n                    goto too_big;\n                }\n                ;\n                rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);\n                if (rc)\n                    goto abort_due_to_error;\n                if (!pOp->p3)\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                ;\n                ;\n                ;\n                break;\n            }\n          case 135:\n            {\n                VdbeCursor *pC;\n                i64 v;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pC->nullRow) {\n                    pOut->flags = 1;\n                    break;\n                } else if (pC->deferredMoveto) {\n                    v = pC->movetoTarget;\n                } else if (pC->eCurType == 2) {\n                    ((void)0);\n                    pVtab = pC->uc.pVCur->pVtab;\n                    pModule = pVtab->pModule;\n                    ((void)0);\n                    rc = pModule->xRowid(pC->uc.pVCur, &v);\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3VdbeCursorRestore(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (pC->nullRow) {\n                        pOut->flags = 1;\n                        break;\n                    }\n                    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 136:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if (pC == 0) {\n                    pC = allocateCursor(p, pOp->p1, 1, 3);\n                    if (pC == 0)\n                        goto no_mem;\n                    pC->seekResult = 0;\n                    pC->isTable = 1;\n                    pC->noReuse = 1;\n                    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                }\n                pC->nullRow = 1;\n                pC->cacheStatus = 0;\n                if (pC->eCurType == 0) {\n                    ((void)0);\n                    sqlite3BtreeClearCursor(pC->uc.pCursor);\n                }\n                break;\n            }\n          case 137:\n          case 32:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                res = 0;\n                ((void)0);\n                if (pOp->opcode == 137) {\n                    ((void)0);\n                    pC->seekResult = -1;\n                    if (sqlite3BtreeCursorIsValidNN(pCrsr)) {\n                        break;\n                    }\n                }\n                rc = sqlite3BtreeLast(pCrsr, &res);\n                pC->nullRow = (u8)res;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 33:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                i64 sz;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                rc = sqlite3BtreeFirst(pCrsr, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    sz = sqlite3BtreeRowCountEst(pCrsr);\n                    if ((sz >= 0) && sqlite3LogEst((u64)sz) < pOp->p3)\n                        res = 1;\n                }\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 34:\n          case 35:\n            {\n                p->aCounter[2]++;\n            }\n          case 36:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                res = 1;\n                if (((pC)->eCurType == 1)) {\n                    rc = sqlite3VdbeSorterRewind(pC, &res);\n                } else {\n                    ((void)0);\n                    pCrsr = pC->uc.pCursor;\n                    ((void)0);\n                    rc = sqlite3BtreeFirst(pCrsr, &res);\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pC->nullRow = (u8)res;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 37:\n            {\n                VdbeCursor *pC;\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                rc = sqlite3VdbeSorterNext(db, pC);\n                goto next_tail;\n              case 38:\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);\n                goto next_tail;\n              case 39:\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);\n              next_tail:\n                pC->cacheStatus = 0;\n                ;\n                if (rc == 0) {\n                    pC->nullRow = 0;\n                    p->aCounter[pOp->p5]++;\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                if (rc != 101)\n                    goto abort_due_to_error;\n                rc = 0;\n                pC->nullRow = 1;\n                goto check_for_interrupt;\n            }\n          case 138:\n            {\n                VdbeCursor *pC;\n                BtreePayload x;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ;\n                ((void)0);\n                ((void)0);\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                ((void)0);\n                ((void)0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                x.nKey = pIn2->n;\n                x.pKey = pIn2->z;\n                x.aMem = aMem + pOp->p3;\n                x.nMem = (u16)pOp->p4.i;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), ((pOp->p5 & 16) ? pC->seekResult : 0));\n                ((void)0);\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 139:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ;\n                ((void)0);\n                ((void)0);\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                ((void)0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeSorterWrite(pC, pIn2);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 140:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                UnpackedRecord r;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ;\n                pCrsr = pC->uc.pCursor;\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p3;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp->p2];\n                rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    rc = sqlite3BtreeDelete(pCrsr, 4);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else if (pOp->p5 && !sqlite3WritableSchema(db)) {\n                    rc = sqlite3ReportError((11 | (3 << 8)), 96569, \"index corruption\");\n                    goto abort_due_to_error;\n                }\n                ((void)0);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                break;\n            }\n          case 141:\n          case 142:\n            {\n                VdbeCursor *pC;\n                VdbeCursor *pTabCur;\n                i64 rowid;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeCursorRestore(pC);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                if (!pC->nullRow) {\n                    rowid = 0;\n                    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (pOp->opcode == 141) {\n                        ((void)0);\n                        pTabCur = p->apCsr[pOp->p3];\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        ((void)0);\n                        pTabCur->nullRow = 0;\n                        pTabCur->movetoTarget = rowid;\n                        pTabCur->deferredMoveto = 1;\n                        pTabCur->cacheStatus = 0;\n                        ((void)0);\n                        ((void)0);\n                        pTabCur->ub.aAltMap = pOp->p4.ai;\n                        ((void)0);\n                        pTabCur->pAltCursor = pC;\n                    } else {\n                        pOut = out2Prerelease(p, pOp);\n                        pOut->u.i = rowid;\n                    }\n                } else {\n                    ((void)0);\n                    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);\n                }\n                break;\n            }\n          case 143:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                if (pC->deferredMoveto) {\n                    rc = sqlite3VdbeFinishMoveto(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 40:\n          case 41:\n          case 42:\n          case 45:\n            {\n                VdbeCursor *pC;\n                int res;\n                UnpackedRecord r;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p4.i;\n                if (pOp->opcode < 42) {\n                    ((void)0);\n                    r.default_rc = -1;\n                } else {\n                    ((void)0);\n                    r.default_rc = 0;\n                }\n                r.aMem = &aMem[pOp->p3];\n                {\n                    i64 nCellKey = 0;\n                    BtCursor *pCur;\n                    Mem m;\n                    ((void)0);\n                    pCur = pC->uc.pCursor;\n                    ((void)0);\n                    nCellKey = sqlite3BtreePayloadSize(pCur);\n                    if (nCellKey <= 0 || nCellKey > 2147483647) {\n                        rc = sqlite3CorruptError(96774);\n                        goto abort_due_to_error;\n                    }\n                    sqlite3VdbeMemInit(&m, db, 0);\n                    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n                    if (rc)\n                        goto abort_due_to_error;\n                    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n                    sqlite3VdbeMemReleaseMalloc(&m);\n                }\n                ((void)0);\n                if ((pOp->opcode & 1) == (42 & 1)) {\n                    ((void)0);\n                    res = -res;\n                } else {\n                    ((void)0);\n                    res++;\n                }\n                ;\n                ((void)0);\n                if (res > 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 144:\n            {\n                int iMoved;\n                int iDb;\n                ;\n                ((void)0);\n                ((void)0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                if (db->nVdbeRead > db->nVDestroy + 1) {\n                    rc = 6;\n                    p->errorAction = 2;\n                    goto abort_due_to_error;\n                } else {\n                    iDb = pOp->p3;\n                    ((void)0);\n                    iMoved = 0;\n                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);\n                    pOut->flags = 4;\n                    pOut->u.i = iMoved;\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (iMoved != 0) {\n                        sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);\n                        ((void)0);\n                        resetSchemaOnFault = iDb + 1;\n                    }\n                }\n                break;\n            }\n          case 145:\n            {\n                i64 nChange;\n                ;\n                nChange = 0;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n                if (pOp->p3) {\n                    p->nChange += nChange;\n                    if (pOp->p3 > 0) {\n                        ((void)0);\n                        ;\n                        aMem[pOp->p3].u.i += nChange;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 146:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                if (((pC)->eCurType == 1)) {\n                    sqlite3VdbeSorterReset(db, pC->uc.pSorter);\n                } else {\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 147:\n            {\n                Pgno pgno;\n                Db *pDb;\n                ;\n                pOut = out2Prerelease(p, pOp);\n                pgno = 0;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pDb = &db->aDb[pOp->p1];\n                ((void)0);\n                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);\n                if (rc)\n                    goto abort_due_to_error;\n                pOut->u.i = pgno;\n                break;\n            }\n          case 148:\n            {\n                ;\n                db->nSqlExec++;\n                rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n                db->nSqlExec--;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 149:\n            {\n                int iDb;\n                const char *zSchema;\n                char *zSql;\n                InitData initData;\n                iDb = pOp->p1;\n                ((void)0);\n                ((void)0);\n                if (pOp->p4.z == 0) {\n                    sqlite3SchemaClear(db->aDb[iDb].pSchema);\n                    db->mDbFlags &= ~16;\n                    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n                    db->mDbFlags |= 1;\n                    p->expired = 0;\n                } else {\n                    zSchema = \"sqlite_master\";\n                    initData.db = db;\n                    initData.iDb = iDb;\n                    initData.pzErrMsg = &p->zErrMsg;\n                    initData.mInitFlags = 0;\n                    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n                    zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n                    if (zSql == 0) {\n                        rc = 7;\n                    } else {\n                        ((void)0);\n                        db->init.busy = 1;\n                        initData.rc = 0;\n                        initData.nInitRow = 0;\n                        ((void)0);\n                        rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n                        if (rc == 0)\n                            rc = initData.rc;\n                        if (rc == 0 && initData.nInitRow == 0) {\n                            rc = sqlite3CorruptError(97026);\n                        }\n                        sqlite3DbFreeNN(db, zSql);\n                        db->init.busy = 0;\n                    }\n                }\n                if (rc) {\n                    sqlite3ResetAllSchemasOfConnection(db);\n                    if (rc == 7) {\n                        goto no_mem;\n                    }\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 150:\n            {\n                ((void)0);\n                rc = sqlite3AnalysisLoad(db, pOp->p1);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 151:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 152:\n            {\n                ;\n                sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 154:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 155:\n            {\n                int nRoot;\n                Pgno *aRoot;\n                int nErr;\n                char *z;\n                Mem *pnErr;\n                ((void)0);\n                nRoot = pOp->p2;\n                aRoot = pOp->p4.ai;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pnErr = &aMem[pOp->p3];\n                ((void)0);\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot, (int)pnErr->u.i + 1, &nErr, &z);\n                sqlite3VdbeMemSetNull(pIn1);\n                if (nErr == 0) {\n                    ((void)0);\n                } else if (rc) {\n                    sqlite3_free(z);\n                    goto abort_due_to_error;\n                } else {\n                    pnErr->u.i -= nErr - 1;\n                    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);\n                }\n                ;\n                sqlite3VdbeChangeEncoding(pIn1, encoding);\n                goto check_for_interrupt;\n            }\n          case 156:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                ((void)0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                ((void)0);\n                sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);\n                break;\n            }\n          case 46:\n            {\n                i64 val;\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                if ((pIn1->flags & 16) == 0 || sqlite3RowSetNext((RowSet *)pIn1->z, &val) == 0) {\n                    sqlite3VdbeMemSetNull(pIn1);\n                    ;\n                    goto jump_to_p2_and_check_for_interrupt;\n                } else {\n                    ;\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);\n                }\n                goto check_for_interrupt;\n            }\n          case 47:\n            {\n                int iSet;\n                int exists;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                iSet = pOp->p4.i;\n                ((void)0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (iSet) {\n                    exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);\n                    ;\n                    if (exists)\n                        goto jump_to_p2;\n                }\n                if (iSet >= 0) {\n                    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);\n                }\n                break;\n            }\n          case 48:\n            {\n                int nMem;\n                int nByte;\n                Mem *pRt;\n                Mem *pMem;\n                Mem *pEnd;\n                VdbeFrame *pFrame;\n                SubProgram *pProgram;\n                void *t;\n                pProgram = pOp->p4.pProgram;\n                pRt = &aMem[pOp->p3];\n                ((void)0);\n                if (pOp->p5) {\n                    t = pProgram->token;\n                    for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent)\n                        ;\n                    if (pFrame)\n                        break;\n                }\n                if (p->nFrame >= db->aLimit[10]) {\n                    rc = 1;\n                    sqlite3VdbeError(p, \"too many levels of trigger recursion\");\n                    goto abort_due_to_error;\n                }\n                if ((pRt->flags & 16) == 0) {\n                    nMem = pProgram->nMem + pProgram->nCsr;\n                    ((void)0);\n                    if (pProgram->nCsr == 0)\n                        nMem++;\n                    nByte = (((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(Mem) + pProgram->nCsr * sizeof(VdbeCursor *) + (pProgram->nOp + 7) / 8;\n                    pFrame = sqlite3DbMallocZero(db, nByte);\n                    if (!pFrame) {\n                        goto no_mem;\n                    }\n                    sqlite3VdbeMemRelease(pRt);\n                    pRt->flags = 16 | 4096;\n                    pRt->z = (char *)pFrame;\n                    pRt->n = nByte;\n                    pRt->xDel = sqlite3VdbeFrameMemDel;\n                    pFrame->v = p;\n                    pFrame->nChildMem = nMem;\n                    pFrame->nChildCsr = pProgram->nCsr;\n                    pFrame->pc = (int)(pOp - aOp);\n                    pFrame->aMem = p->aMem;\n                    pFrame->nMem = p->nMem;\n                    pFrame->apCsr = p->apCsr;\n                    pFrame->nCursor = p->nCursor;\n                    pFrame->aOp = p->aOp;\n                    pFrame->nOp = p->nOp;\n                    pFrame->token = pProgram->token;\n                    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)])[pFrame->nChildMem];\n                    for (pMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]); pMem != pEnd; pMem++) {\n                        pMem->flags = 0;\n                        pMem->db = db;\n                    }\n                } else {\n                    pFrame = (VdbeFrame *)pRt->z;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                }\n                p->nFrame++;\n                pFrame->pParent = p->pFrame;\n                pFrame->lastRowid = db->lastRowid;\n                pFrame->nChange = p->nChange;\n                pFrame->nDbChange = p->db->nChange;\n                ((void)0);\n                pFrame->pAuxData = p->pAuxData;\n                p->pAuxData = 0;\n                p->nChange = 0;\n                p->pFrame = pFrame;\n                p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]);\n                p->nMem = pFrame->nChildMem;\n                p->nCursor = (u16)pFrame->nChildCsr;\n                p->apCsr = (VdbeCursor **)&aMem[p->nMem];\n                pFrame->aOnce = (u8 *)&p->apCsr[pProgram->nCsr];\n                __builtin___memset_chk(pFrame->aOnce, 0, (pProgram->nOp + 7) / 8, __builtin_object_size(pFrame->aOnce, 0));\n                p->aOp = aOp = pProgram->aOp;\n                p->nOp = pProgram->nOp;\n                pOp = &aOp[-1];\n                goto check_for_interrupt;\n            }\n          case 157:\n            {\n                VdbeFrame *pFrame;\n                Mem *pIn;\n                pOut = out2Prerelease(p, pOp);\n                pFrame = p->pFrame;\n                pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];\n                sqlite3VdbeMemShallowCopy(pOut, pIn, 16384);\n                break;\n            }\n          case 158:\n            {\n                if (db->flags & 524288) {\n                    db->nDeferredImmCons += pOp->p2;\n                } else if (pOp->p1) {\n                    db->nDeferredCons += pOp->p2;\n                } else {\n                    p->nFkConstraint += pOp->p2;\n                }\n                break;\n            }\n          case 49:\n            {\n                if (pOp->p1) {\n                    ;\n                    if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                } else {\n                    ;\n                    if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 159:\n            {\n                VdbeFrame *pFrame;\n                if (p->pFrame) {\n                    for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                        ;\n                    pIn1 = &pFrame->aMem[pOp->p1];\n                } else {\n                    pIn1 = &aMem[pOp->p1];\n                }\n                ((void)0);\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn2 = &aMem[pOp->p2];\n                sqlite3VdbeMemIntegerify(pIn2);\n                if (pIn1->u.i < pIn2->u.i) {\n                    pIn1->u.i = pIn2->u.i;\n                }\n                break;\n            }\n          case 59:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                if (pIn1->u.i > 0) {\n                    pIn1->u.i -= pOp->p3;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 160:\n            {\n                i64 x;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                ((void)0);\n                ((void)0);\n                x = pIn1->u.i;\n                if (x <= 0 || sqlite3AddInt64(&x, pIn3->u.i > 0 ? pIn3->u.i : 0)) {\n                    pOut->u.i = -1;\n                } else {\n                    pOut->u.i = x;\n                }\n                break;\n            }\n          case 60:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ;\n                if (pIn1->u.i) {\n                    if (pIn1->u.i > 0)\n                        pIn1->u.i--;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 61:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                if (pIn1->u.i > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                    pIn1->u.i--;\n                ;\n                if (pIn1->u.i == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 161:\n          case 162:\n            {\n                int n;\n                sqlite3_context *pCtx;\n                ((void)0);\n                n = pOp->p5;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pCtx = sqlite3DbMallocRawNN(db, n * sizeof(sqlite3_value *) + (sizeof (pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value *)));\n                if (pCtx == 0)\n                    goto no_mem;\n                pCtx->pMem = 0;\n                pCtx->pOut = (Mem *)&(pCtx->argv[n]);\n                sqlite3VdbeMemInit(pCtx->pOut, db, 1);\n                pCtx->pFunc = pOp->p4.pFunc;\n                pCtx->iOp = (int)(pOp - aOp);\n                pCtx->pVdbe = p;\n                pCtx->skipFlag = 0;\n                pCtx->isError = 0;\n                pCtx->enc = encoding;\n                pCtx->argc = n;\n                pOp->p4type = (-15);\n                pOp->p4.pCtx = pCtx;\n                ((void)0);\n                pOp->opcode = 163;\n            }\n          case 163:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                Mem *pMem;\n                ((void)0);\n                pCtx = pOp->p4.pCtx;\n                pMem = &aMem[pOp->p3];\n                if (pCtx->pMem != pMem) {\n                    pCtx->pMem = pMem;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                pMem->n++;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                if (pOp->p1) {\n                    (pCtx->pFunc->xInverse)(pCtx, pCtx->argc, pCtx->argv);\n                } else\n                    (pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pCtx->pOut));\n                        rc = pCtx->isError;\n                    }\n                    if (pCtx->skipFlag) {\n                        ((void)0);\n                        i = pOp[-1].p1;\n                        if (i)\n                            sqlite3VdbeMemSetInt64(&aMem[i], 1);\n                        pCtx->skipFlag = 0;\n                    }\n                    sqlite3VdbeMemRelease(pCtx->pOut);\n                    pCtx->pOut->flags = 1;\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                ((void)0);\n                ((void)0);\n                break;\n            }\n          case 164:\n          case 165:\n            {\n                Mem *pMem;\n                ((void)0);\n                ((void)0);\n                pMem = &aMem[pOp->p1];\n                ((void)0);\n                if (pOp->p3) {\n                    ;\n                    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);\n                    pMem = &aMem[pOp->p3];\n                } else {\n                    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);\n                }\n                if (rc) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pMem));\n                    goto abort_due_to_error;\n                }\n                sqlite3VdbeChangeEncoding(pMem, encoding);\n                ;\n                break;\n            }\n          case 3:\n            {\n                int i;\n                int aRes[3];\n                Mem *pMem;\n                ((void)0);\n                aRes[0] = 0;\n                aRes[1] = aRes[2] = -1;\n                ((void)0);\n                rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);\n                if (rc) {\n                    if (rc != 5)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    aRes[0] = 1;\n                }\n                for (i = 0 , pMem = &aMem[pOp->p3]; i < 3; i++ , pMem++) {\n                    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);\n                }\n                break;\n            }\n            ;\n          case 4:\n            {\n                Btree *pBt;\n                Pager *pPager;\n                int eNew;\n                int eOld;\n                const char *zFilename;\n                pOut = out2Prerelease(p, pOp);\n                eNew = pOp->p3;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pBt = db->aDb[pOp->p1].pBt;\n                pPager = sqlite3BtreePager(pBt);\n                eOld = sqlite3PagerGetJournalMode(pPager);\n                if (eNew == (-1))\n                    eNew = eOld;\n                ((void)0);\n                if (!sqlite3PagerOkToChangeJournalMode(pPager))\n                    eNew = eOld;\n                zFilename = sqlite3PagerFilename(pPager, 1);\n                if (eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !sqlite3PagerWalSupported(pPager))) {\n                    eNew = eOld;\n                }\n                if ((eNew != eOld) && (eOld == 5 || eNew == 5)) {\n                    if (!db->autoCommit || db->nVdbeRead > 1) {\n                        rc = 1;\n                        sqlite3VdbeError(p, \"cannot change %s wal mode from within a transaction\", (eNew == 5 ? \"into\" : \"out of\"));\n                        goto abort_due_to_error;\n                    } else {\n                        if (eOld == 5) {\n                            rc = sqlite3PagerCloseWal(pPager, db);\n                            if (rc == 0) {\n                                sqlite3PagerSetJournalMode(pPager, eNew);\n                            }\n                        } else if (eOld == 4) {\n                            sqlite3PagerSetJournalMode(pPager, 2);\n                        }\n                        ((void)0);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeSetVersion(pBt, (eNew == 5 ? 2 : 1));\n                        }\n                    }\n                }\n                if (rc)\n                    eNew = eOld;\n                eNew = sqlite3PagerSetJournalMode(pPager, eNew);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = (char *)sqlite3JournalModename(eNew);\n                pOut->n = sqlite3Strlen30(pOut->z);\n                pOut->enc = 1;\n                sqlite3VdbeChangeEncoding(pOut, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 5:\n            {\n                ((void)0);\n                rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p2 ? &aMem[pOp->p2] : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 62:\n            {\n                Btree *pBt;\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                pBt = db->aDb[pOp->p1].pBt;\n                rc = sqlite3BtreeIncrVacuum(pBt);\n                ;\n                if (rc) {\n                    if (rc != 101)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 166:\n            {\n                ((void)0);\n                if (!pOp->p1) {\n                    sqlite3ExpirePreparedStatements(db, pOp->p2);\n                } else {\n                    p->expired = pOp->p2 + 1;\n                }\n                break;\n            }\n          case 167:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeCursorPin(pC->uc.pCursor);\n                break;\n            }\n          case 168:\n            {\n                VdbeCursor *pC;\n                ((void)0);\n                pC = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                sqlite3BtreeCursorUnpin(pC->uc.pCursor);\n                break;\n            }\n          case 169:\n            {\n                u8 isWriteLock = (u8)pOp->p3;\n                if (isWriteLock || 0 == (db->flags & 1024)) {\n                    int p1 = pOp->p1;\n                    ((void)0);\n                    ((void)0);\n                    ((void)0);\n                    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n                    if (rc) {\n                        if ((rc & 255) == 6) {\n                            const char *z = pOp->p4.z;\n                            sqlite3VdbeError(p, \"database table is locked: %s\", z);\n                        }\n                        goto abort_due_to_error;\n                    }\n                }\n                break;\n            }\n          case 170:\n            {\n                VTable *pVTab;\n                pVTab = pOp->p4.pVtab;\n                rc = sqlite3VtabBegin(db, pVTab);\n                if (pVTab)\n                    sqlite3VtabImportErrmsg(p, pVTab->pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 171:\n            {\n                Mem sMem;\n                const char *zTab;\n                __builtin___memset_chk(&sMem, 0, sizeof (sMem), __builtin_object_size(&sMem, 0));\n                sMem.db = db;\n                ((void)0);\n                ((void)0);\n                rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);\n                ((void)0);\n                zTab = (const char *)sqlite3_value_text(&sMem);\n                ((void)0);\n                if (zTab) {\n                    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);\n                }\n                sqlite3VdbeMemRelease(&sMem);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 172:\n            {\n                db->nVDestroy++;\n                rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n                db->nVDestroy--;\n                ((void)0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 173:\n            {\n                VdbeCursor *pCur;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                ((void)0);\n                pCur = 0;\n                pVCur = 0;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                rc = pModule->xOpen(pVtab, &pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                pVCur->pVtab = pVtab;\n                pCur = allocateCursor(p, pOp->p1, 0, 2);\n                if (pCur) {\n                    pCur->uc.pVCur = pVCur;\n                    pVtab->nRef++;\n                } else {\n                    ((void)0);\n                    pModule->xClose(pVCur);\n                    goto no_mem;\n                }\n                break;\n            }\n          case 174:\n            {\n                VdbeCursor *pC;\n                ValueList *pRhs;\n                pC = p->apCsr[pOp->p1];\n                pRhs = sqlite3_malloc64(sizeof (*pRhs));\n                if (pRhs == 0)\n                    goto no_mem;\n                pRhs->pCsr = pC->uc.pCursor;\n                pRhs->pOut = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n                break;\n            }\n          case 6:\n            {\n                int nArg;\n                int iQuery;\n                const sqlite3_module *pModule;\n                Mem *pQuery;\n                Mem *pArgc;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                VdbeCursor *pCur;\n                int res;\n                int i;\n                Mem **apArg;\n                pQuery = &aMem[pOp->p3];\n                pArgc = &pQuery[1];\n                pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ;\n                ((void)0);\n                ((void)0);\n                pVCur = pCur->uc.pVCur;\n                pVtab = pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                nArg = (int)pArgc->u.i;\n                iQuery = (int)pQuery->u.i;\n                apArg = p->apArg;\n                for (i = 0; i < nArg; i++) {\n                    apArg[i] = &pArgc[i + 1];\n                }\n                rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pVCur);\n                pCur->nullRow = 0;\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 175:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                Mem *pDest;\n                sqlite3_context sContext;\n                VdbeCursor *pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                pDest = &aMem[pOp->p3];\n                ;\n                if (pCur->nullRow) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    break;\n                }\n                ((void)0);\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                __builtin___memset_chk(&sContext, 0, sizeof (sContext), __builtin_object_size(&sContext, 0));\n                sContext.pOut = pDest;\n                sContext.enc = encoding;\n                ((void)0);\n                if (pOp->p5 & 1) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    pDest->flags = 1 | 1024;\n                    pDest->u.nZero = 0;\n                } else {\n                    ((pDest)->flags = ((pDest)->flags & ~(3519 | 1024)) | 1);\n                }\n                rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (sContext.isError > 0) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pDest));\n                    rc = sContext.isError;\n                }\n                sqlite3VdbeChangeEncoding(pDest, encoding);\n                ;\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 63:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int res;\n                VdbeCursor *pCur;\n                pCur = p->apCsr[pOp->p1];\n                ((void)0);\n                ((void)0);\n                if (pCur->nullRow) {\n                    break;\n                }\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                ((void)0);\n                rc = pModule->xNext(pCur->uc.pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pCur->uc.pVCur);\n                ;\n                if (!res) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                goto check_for_interrupt;\n            }\n          case 176:\n            {\n                sqlite3_vtab *pVtab;\n                Mem *pName;\n                int isLegacy;\n                isLegacy = (db->flags & 67108864);\n                db->flags |= 67108864;\n                pVtab = pOp->p4.pVtab->pVtab;\n                pName = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                ((void)0);\n                ;\n                ((void)0);\n                ;\n                ;\n                ;\n                rc = sqlite3VdbeChangeEncoding(pName, 1);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = pVtab->pModule->xRename(pVtab, pName->z);\n                if (isLegacy == 0)\n                    db->flags &= ~(u64)67108864;\n                sqlite3VtabImportErrmsg(p, pVtab);\n                p->expired = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 7:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int nArg;\n                int i;\n                sqlite_int64 rowid = 0;\n                Mem **apArg;\n                Mem *pX;\n                ((void)0);\n                ((void)0);\n                if (db->mallocFailed)\n                    goto no_mem;\n                ;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                nArg = pOp->p2;\n                ((void)0);\n                if ((pModule->xUpdate)) {\n                    u8 vtabOnConflict = db->vtabOnConflict;\n                    apArg = p->apArg;\n                    pX = &aMem[pOp->p3];\n                    for (i = 0; i < nArg; i++) {\n                        ((void)0);\n                        ;\n                        apArg[i] = pX;\n                        pX++;\n                    }\n                    db->vtabOnConflict = pOp->p5;\n                    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);\n                    db->vtabOnConflict = vtabOnConflict;\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc == 0 && pOp->p1) {\n                        ((void)0);\n                        db->lastRowid = rowid;\n                    }\n                    if ((rc & 255) == 19 && pOp->p4.pVtab->bConstraint) {\n                        if (pOp->p5 == 4) {\n                            rc = 0;\n                        } else {\n                            p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5);\n                        }\n                    } else {\n                        p->nChange++;\n                    }\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 177:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n                break;\n            }\n          case 178:\n            {\n                unsigned int newMax;\n                Btree *pBt;\n                pOut = out2Prerelease(p, pOp);\n                pBt = db->aDb[pOp->p1].pBt;\n                newMax = 0;\n                if (pOp->p3) {\n                    newMax = sqlite3BtreeLastPage(pBt);\n                    if (newMax < (unsigned int)pOp->p3)\n                        newMax = (unsigned int)pOp->p3;\n                }\n                pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n                break;\n            }\n          case 65:\n          case 66:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                ((void)0);\n                pCtx = pOp->p4.pCtx;\n                pOut = &aMem[pOp->p3];\n                if (pCtx->pOut != pOut) {\n                    pCtx->pVdbe = p;\n                    pCtx->pOut = pOut;\n                    pCtx->enc = encoding;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                ((void)0);\n                ;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                ((void)0);\n                (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pOut));\n                        rc = pCtx->isError;\n                    }\n                    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                ((void)0);\n                ((void)0);\n                ;\n                ;\n                break;\n            }\n          case 179:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn1->flags &= ~2048;\n                break;\n            }\n          case 180:\n            {\n                u64 h;\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                pIn1->z[h / 8] |= 1 << (h & 7);\n                break;\n            }\n          case 64:\n            {\n                u64 h;\n                ((void)0);\n                pIn1 = &aMem[pOp->p1];\n                ((void)0);\n                ((void)0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                if ((pIn1->z[h / 8] & (1 << (h & 7))) == 0) {\n                    ;\n                    p->aCounter[8]++;\n                    goto jump_to_p2;\n                } else {\n                    p->aCounter[7]++;\n                    ;\n                }\n                break;\n            }\n          case 181:\n          case 8:\n            {\n                int i;\n                char *zTrace;\n                ((void)0);\n                ((void)0);\n                if ((db->mTrace & (1 | 64)) != 0 && p->minWriteFileFormat != 254 && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0) {\n                    if (db->mTrace & 64) {\n                        char *z = sqlite3VdbeExpandSql(p, zTrace);\n                        db->trace.xLegacy(db->pTraceArg, z);\n                        sqlite3_free(z);\n                    } else if (db->nVdbeExec > 1) {\n                        char *z = sqlite3MPrintf(db, \"-- %s\", zTrace);\n                        (void)db->trace.xV2(1, db->pTraceArg, p, z);\n                        sqlite3DbFree(db, z);\n                    } else {\n                        (void)db->trace.xV2(1, db->pTraceArg, p, zTrace);\n                    }\n                }\n                ((void)0);\n                if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {\n                    if (pOp->opcode == 181)\n                        break;\n                    for (i = 1; i < p->nOp; i++) {\n                        if (p->aOp[i].opcode == 15)\n                            p->aOp[i].p1 = 0;\n                    }\n                    pOp->p1 = 0;\n                }\n                pOp->p1++;\n                p->aCounter[6]++;\n                goto jump_to_p2;\n            }\n          default:\n            {\n                ((void)0);\n                break;\n            }\n        }\n    }\n  abort_due_to_error:\n    if (db->mallocFailed) {\n        rc = 7;\n    } else if (rc == (10 | (33 << 8))) {\n        rc = sqlite3CorruptError(98965);\n    }\n    ((void)0);\n    if (p->zErrMsg == 0 && rc != (10 | (12 << 8))) {\n        sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n    }\n    p->rc = rc;\n    sqlite3SystemError(db, rc);\n    ;\n    sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", (int)(pOp - aOp), p->zSql, p->zErrMsg);\n    if (p->eVdbeState == 2)\n        sqlite3VdbeHalt(p);\n    if (rc == (10 | (12 << 8)))\n        sqlite3OomFault(db);\n    if (rc == 11 && db->autoCommit == 0) {\n        db->flags |= ((u64)(2) << 32);\n    }\n    rc = 1;\n    if (resetSchemaOnFault > 0) {\n        sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);\n    }\n  vdbe_return:\n    while (nVmStep >= nProgressLimit && db->xProgress != 0)\n        {\n            nProgressLimit += db->nProgressOps;\n            if (db->xProgress(db->pProgressArg)) {\n                nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                rc = 9;\n                goto abort_due_to_error;\n            }\n        }\n    p->aCounter[4] += (int)nVmStep;\n    if (((p->lockMask) != 0)) {\n        sqlite3VdbeLeave(p);\n    }\n    ((void)0);\n    return rc;\n  too_big:\n    sqlite3VdbeError(p, \"string or blob too big\");\n    rc = 18;\n    goto abort_due_to_error;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3VdbeError(p, \"out of memory\");\n    rc = 7;\n    goto abort_due_to_error;\n  abort_due_to_interrupt:\n    ((void)0);\n    rc = 9;\n    goto abort_due_to_error;\n}\n"
  },
  {
    "id": "#23:25#sqlite3GenerateConstraintChecks",
    "nobreaks": 3,
    "body": "{\n    Vdbe *v;\n    Index *pIdx;\n    Index *pPk = 0;\n    sqlite3 *db;\n    int i;\n    int ix;\n    int nCol;\n    int onError;\n    int seenReplace = 0;\n    int nPkField;\n    Upsert *pUpsertClause = 0;\n    u8 isUpdate;\n    u8 bAffinityDone = 0;\n    int upsertIpkReturn = 0;\n    int upsertIpkDelay = 0;\n    int ipkTop = 0;\n    int ipkBottom = 0;\n    int regTrigCnt;\n    int addrRecheck = 0;\n    int lblRecheckOk = 0;\n    Trigger *pTrigger;\n    int nReplaceTrig = 0;\n    IndexIterator sIdxIter;\n    isUpdate = regOldData != 0;\n    db = pParse->db;\n    v = pParse->pVdbe;\n    ((void)0);\n    ((void)0);\n    nCol = pTab->nCol;\n    if ((((pTab)->tabFlags & 128) == 0)) {\n        pPk = 0;\n        nPkField = 1;\n    } else {\n        pPk = sqlite3PrimaryKeyIndex(pTab);\n        nPkField = pPk->nKeyCol;\n    }\n    ;\n    if (pTab->tabFlags & 2048) {\n        int b2ndPass = 0;\n        int nSeenReplace = 0;\n        int nGenerated = 0;\n        while (1)\n            {\n                for (i = 0; i < nCol; i++) {\n                    int iReg;\n                    Column *pCol = &pTab->aCol[i];\n                    int isGenerated;\n                    onError = pCol->notNull;\n                    if (onError == 0)\n                        continue;\n                    if (i == pTab->iPKey) {\n                        continue;\n                    }\n                    isGenerated = pCol->colFlags & 96;\n                    if (isGenerated && !b2ndPass) {\n                        nGenerated++;\n                        continue;\n                    }\n                    if (aiChng && aiChng[i] < 0 && !isGenerated) {\n                        continue;\n                    }\n                    if (overrideError != 11) {\n                        onError = overrideError;\n                    } else if (onError == 11) {\n                        onError = 2;\n                    }\n                    if (onError == 5) {\n                        if (b2ndPass || pCol->iDflt == 0) {\n                            ;\n                            ;\n                            ;\n                            onError = 2;\n                        } else {\n                            ((void)0);\n                        }\n                    } else if (b2ndPass && !isGenerated) {\n                        continue;\n                    }\n                    ((void)0);\n                    ;\n                    iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;\n                    switch (onError) {\n                      case 5:\n                        {\n                            int addr1 = sqlite3VdbeAddOp1(v, 51, iReg);\n                            ;\n                            ((void)0);\n                            nSeenReplace++;\n                            sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), iReg);\n                            sqlite3VdbeJumpHere(v, addr1);\n                            break;\n                        }\n                      case 2:\n                        sqlite3MayAbort(pParse);\n                      case 1:\n                      case 3:\n                        {\n                            char *zMsg = sqlite3MPrintf(db, \"%s.%s\", pTab->zName, pCol->zCnName);\n                            ;\n                            sqlite3VdbeAddOp3(v, 69, (19 | (5 << 8)), onError, iReg);\n                            sqlite3VdbeAppendP4(v, zMsg, (-6));\n                            sqlite3VdbeChangeP5(v, 1);\n                            ;\n                            break;\n                        }\n                      default:\n                        {\n                            ((void)0);\n                            sqlite3VdbeAddOp2(v, 50, iReg, ignoreDest);\n                            ;\n                            break;\n                        }\n                    }\n                }\n                if (nGenerated == 0 && nSeenReplace == 0) {\n                    break;\n                }\n                if (b2ndPass)\n                    break;\n                b2ndPass = 1;\n                if (nSeenReplace > 0 && (pTab->tabFlags & 96) != 0) {\n                    sqlite3ComputeGeneratedColumns(pParse, regNewData + 1, pTab);\n                }\n            }\n    }\n    if (pTab->pCheck && (db->flags & 512) == 0) {\n        ExprList *pCheck = pTab->pCheck;\n        pParse->iSelfTab = -(regNewData + 1);\n        onError = overrideError != 11 ? overrideError : 2;\n        for (i = 0; i < pCheck->nExpr; i++) {\n            int allOk;\n            Expr *pCopy;\n            Expr *pExpr = pCheck->a[i].pExpr;\n            if (aiChng && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)) {\n                continue;\n            }\n            if (bAffinityDone == 0) {\n                sqlite3TableAffinity(v, pTab, regNewData + 1);\n                bAffinityDone = 1;\n            }\n            allOk = sqlite3VdbeMakeLabel(pParse);\n            ;\n            pCopy = sqlite3ExprDup(db, pExpr, 0);\n            if (!db->mallocFailed) {\n                sqlite3ExprIfTrue(pParse, pCopy, allOk, 16);\n            }\n            sqlite3ExprDelete(db, pCopy);\n            if (onError == 4) {\n                sqlite3VdbeGoto(v, ignoreDest);\n            } else {\n                char *zName = pCheck->a[i].zEName;\n                ((void)0);\n                if (onError == 5)\n                    onError = 2;\n                sqlite3HaltConstraint(pParse, (19 | (1 << 8)), onError, zName, 0, 3);\n            }\n            sqlite3VdbeResolveLabel(v, allOk);\n        }\n        pParse->iSelfTab = 0;\n    }\n    sIdxIter.eType = 0;\n    sIdxIter.i = 0;\n    sIdxIter.u.ax.aIdx = 0;\n    sIdxIter.u.lx.pIdx = pTab->pIndex;\n    if (pUpsert) {\n        if (pUpsert->pUpsertTarget == 0) {\n            ((void)0);\n            if (pUpsert->isDoUpdate == 0) {\n                overrideError = 4;\n                pUpsert = 0;\n            } else {\n                overrideError = 6;\n            }\n        } else if (pTab->pIndex != 0) {\n            int nIdx, jj;\n            u64 nByte;\n            Upsert *pTerm;\n            u8 *bUsed;\n            for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n                ((void)0);\n            }\n            sIdxIter.eType = 1;\n            sIdxIter.u.ax.nIdx = nIdx;\n            nByte = (sizeof(IndexListTerm) + 1) * nIdx + nIdx;\n            sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);\n            if (sIdxIter.u.ax.aIdx == 0)\n                return;\n            bUsed = (u8 *)&sIdxIter.u.ax.aIdx[nIdx];\n            pUpsert->pToFree = sIdxIter.u.ax.aIdx;\n            for (i = 0 , pTerm = pUpsert; pTerm; pTerm = pTerm->pNextUpsert) {\n                if (pTerm->pUpsertTarget == 0)\n                    break;\n                if (pTerm->pUpsertIdx == 0)\n                    continue;\n                jj = 0;\n                pIdx = pTab->pIndex;\n                while ((pIdx != 0) && pIdx != pTerm->pUpsertIdx)\n                    {\n                        pIdx = pIdx->pNext;\n                        jj++;\n                    }\n                if (bUsed[jj])\n                    continue;\n                bUsed[jj] = 1;\n                sIdxIter.u.ax.aIdx[i].p = pIdx;\n                sIdxIter.u.ax.aIdx[i].ix = jj;\n                i++;\n            }\n            for (jj = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , jj++) {\n                if (bUsed[jj])\n                    continue;\n                sIdxIter.u.ax.aIdx[i].p = pIdx;\n                sIdxIter.u.ax.aIdx[i].ix = jj;\n                i++;\n            }\n            ((void)0);\n        }\n    }\n    if ((db->flags & (8192 | 16384)) == 0) {\n        pTrigger = 0;\n        regTrigCnt = 0;\n    } else {\n        if (db->flags & 8192) {\n            pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, 0);\n            regTrigCnt = pTrigger != 0 || sqlite3FkRequired(pParse, pTab, 0, 0);\n        } else {\n            pTrigger = 0;\n            regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);\n        }\n        if (regTrigCnt) {\n            regTrigCnt = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 71, 0, regTrigCnt);\n            ;\n            lblRecheckOk = sqlite3VdbeMakeLabel(pParse);\n            addrRecheck = lblRecheckOk;\n        }\n    }\n    if (pkChng && pPk == 0) {\n        int addrRowidOk = sqlite3VdbeMakeLabel(pParse);\n        onError = pTab->keyConf;\n        if (overrideError != 11) {\n            onError = overrideError;\n        } else if (onError == 11) {\n            onError = 2;\n        }\n        if (pUpsert) {\n            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, 0);\n            if (pUpsertClause != 0) {\n                if (pUpsertClause->isDoUpdate == 0) {\n                    onError = 4;\n                } else {\n                    onError = 6;\n                }\n            }\n            if (pUpsertClause != pUpsert) {\n                upsertIpkDelay = sqlite3VdbeAddOp0(v, 9);\n            }\n        }\n        if (onError == 5 && onError != overrideError && pTab->pIndex && !upsertIpkDelay) {\n            ipkTop = sqlite3VdbeAddOp0(v, 9) + 1;\n            ;\n        }\n        if (isUpdate) {\n            sqlite3VdbeAddOp3(v, 53, regNewData, addrRowidOk, regOldData);\n            sqlite3VdbeChangeP5(v, 144);\n            ;\n        }\n        ;\n        ;\n        sqlite3VdbeAddOp3(v, 31, iDataCur, addrRowidOk, regNewData);\n        ;\n        switch (onError) {\n          default:\n            {\n                onError = 2;\n            }\n          case 1:\n          case 2:\n          case 3:\n            {\n                ;\n                ;\n                ;\n                sqlite3RowidConstraint(pParse, onError, pTab);\n                break;\n            }\n          case 5:\n            {\n                if (regTrigCnt) {\n                    sqlite3MultiWrite(pParse);\n                    sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regNewData, 1, 0, 5, 1, -1);\n                    sqlite3VdbeAddOp2(v, 86, regTrigCnt, 1);\n                    nReplaceTrig++;\n                } else {\n                    if (pTab->pIndex) {\n                        sqlite3MultiWrite(pParse);\n                        sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0, -1);\n                    }\n                }\n                seenReplace = 1;\n                break;\n            }\n          case 6:\n            {\n                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);\n            }\n          case 4:\n            {\n                ;\n                sqlite3VdbeGoto(v, ignoreDest);\n                break;\n            }\n        }\n        sqlite3VdbeResolveLabel(v, addrRowidOk);\n        if (pUpsert && pUpsertClause != pUpsert) {\n            upsertIpkReturn = sqlite3VdbeAddOp0(v, 9);\n        } else if (ipkTop) {\n            ipkBottom = sqlite3VdbeAddOp0(v, 9);\n            sqlite3VdbeJumpHere(v, ipkTop - 1);\n        }\n    }\n    for (pIdx = indexIteratorFirst(&sIdxIter, &ix); pIdx; pIdx = indexIteratorNext(&sIdxIter, &ix)) {\n        int regIdx;\n        int regR;\n        int iThisCur;\n        int addrUniqueOk;\n        int addrConflictCk;\n        if (aRegIdx[ix] == 0)\n            continue;\n        if (pUpsert) {\n            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);\n            if (upsertIpkDelay && pUpsertClause == pUpsert) {\n                sqlite3VdbeJumpHere(v, upsertIpkDelay);\n            }\n        }\n        addrUniqueOk = sqlite3VdbeMakeLabel(pParse);\n        if (bAffinityDone == 0) {\n            sqlite3TableAffinity(v, pTab, regNewData + 1);\n            bAffinityDone = 1;\n        }\n        ;\n        iThisCur = iIdxCur + ix;\n        if (pIdx->pPartIdxWhere) {\n            sqlite3VdbeAddOp2(v, 75, 0, aRegIdx[ix]);\n            pParse->iSelfTab = -(regNewData + 1);\n            sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk, 16);\n            pParse->iSelfTab = 0;\n        }\n        regIdx = aRegIdx[ix] + 1;\n        for (i = 0; i < pIdx->nColumn; i++) {\n            int iField = pIdx->aiColumn[i];\n            int x;\n            if (iField == (-2)) {\n                pParse->iSelfTab = -(regNewData + 1);\n                sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx + i);\n                pParse->iSelfTab = 0;\n                ;\n            } else if (iField == (-1) || iField == pTab->iPKey) {\n                x = regNewData;\n                sqlite3VdbeAddOp2(v, 82, x, regIdx + i);\n                ;\n            } else {\n                ;\n                x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;\n                sqlite3VdbeAddOp2(v, 81, x, regIdx + i);\n                ;\n            }\n        }\n        sqlite3VdbeAddOp3(v, 97, regIdx, pIdx->nColumn, aRegIdx[ix]);\n        ;\n        ;\n        if (isUpdate && pPk == pIdx && pkChng == 0) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        onError = pIdx->onError;\n        if (onError == 0) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        if (overrideError != 11) {\n            onError = overrideError;\n        } else if (onError == 11) {\n            onError = 2;\n        }\n        if (pUpsertClause) {\n            if (pUpsertClause->isDoUpdate == 0) {\n                onError = 4;\n            } else {\n                onError = 6;\n            }\n        }\n        ((void)0);\n        if ((ix == 0 && pIdx->pNext == 0) && pPk == pIdx && onError == 5 && (0 == (db->flags & 8192) || 0 == sqlite3TriggersExist(pParse, pTab, 128, 0, 0)) && (0 == (db->flags & 16384) || (0 == pTab->u.tab.pFKey && 0 == sqlite3FkReferences(pTab)))) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        ;\n        addrConflictCk = sqlite3VdbeAddOp4Int(v, 27, iThisCur, addrUniqueOk, regIdx, pIdx->nKeyCol);\n        ;\n        regR = pIdx == pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);\n        if (isUpdate || onError == 5) {\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                sqlite3VdbeAddOp2(v, 142, iThisCur, regR);\n                if (isUpdate) {\n                    sqlite3VdbeAddOp3(v, 53, regR, addrUniqueOk, regOldData);\n                    sqlite3VdbeChangeP5(v, 144);\n                    ;\n                }\n            } else {\n                int x;\n                if (pIdx != pPk) {\n                    for (i = 0; i < pPk->nKeyCol; i++) {\n                        ((void)0);\n                        x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);\n                        sqlite3VdbeAddOp3(v, 94, iThisCur, x, regR + i);\n                        ;\n                    }\n                }\n                if (isUpdate) {\n                    int addrJump = sqlite3VdbeCurrentAddr(v) + pPk->nKeyCol;\n                    int op = 52;\n                    int regCmp = (((pIdx)->idxType == 2) ? regIdx : regR);\n                    for (i = 0; i < pPk->nKeyCol; i++) {\n                        char *p4 = (char *)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);\n                        x = pPk->aiColumn[i];\n                        ((void)0);\n                        if (i == (pPk->nKeyCol - 1)) {\n                            addrJump = addrUniqueOk;\n                            op = 53;\n                        }\n                        x = sqlite3TableColumnToStorage(pTab, x);\n                        sqlite3VdbeAddOp4(v, op, regOldData + 1 + x, addrJump, regCmp + i, p4, (-2));\n                        sqlite3VdbeChangeP5(v, 144);\n                        ;\n                        ;\n                    }\n                }\n            }\n        }\n        ((void)0);\n        switch (onError) {\n          case 1:\n          case 2:\n          case 3:\n            {\n                ;\n                ;\n                ;\n                sqlite3UniqueConstraint(pParse, onError, pIdx);\n                break;\n            }\n          case 6:\n            {\n                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur + ix);\n            }\n          case 4:\n            {\n                ;\n                sqlite3VdbeGoto(v, ignoreDest);\n                break;\n            }\n          default:\n            {\n                int nConflictCk;\n                ((void)0);\n                nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;\n                ((void)0);\n                ;\n                ;\n                if (regTrigCnt) {\n                    sqlite3MultiWrite(pParse);\n                    nReplaceTrig++;\n                }\n                if (pTrigger && isUpdate) {\n                    sqlite3VdbeAddOp1(v, 167, iDataCur);\n                }\n                sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regR, nPkField, 0, 5, (pIdx == pPk ? 1 : 0), iThisCur);\n                if (pTrigger && isUpdate) {\n                    sqlite3VdbeAddOp1(v, 168, iDataCur);\n                }\n                if (regTrigCnt) {\n                    int addrBypass;\n                    sqlite3VdbeAddOp2(v, 86, regTrigCnt, 1);\n                    addrBypass = sqlite3VdbeAddOp0(v, 9);\n                    ;\n                    sqlite3VdbeResolveLabel(v, lblRecheckOk);\n                    lblRecheckOk = sqlite3VdbeMakeLabel(pParse);\n                    if (pIdx->pPartIdxWhere) {\n                        sqlite3VdbeAddOp2(v, 50, regIdx - 1, lblRecheckOk);\n                        ;\n                    }\n                    while (nConflictCk > 0)\n                        {\n                            VdbeOp x;\n                            x = *sqlite3VdbeGetOp(v, addrConflictCk);\n                            if (x.opcode != 142) {\n                                int p2;\n                                const char *zP4;\n                                if (sqlite3OpcodeProperty[x.opcode] & 1) {\n                                    p2 = lblRecheckOk;\n                                } else {\n                                    p2 = x.p2;\n                                }\n                                zP4 = x.p4type == (-3) ? ((void *)(intptr_t)(x.p4.i)) : x.p4.z;\n                                sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);\n                                sqlite3VdbeChangeP5(v, x.p5);\n                                ;\n                            }\n                            nConflictCk--;\n                            addrConflictCk++;\n                        }\n                    sqlite3UniqueConstraint(pParse, 2, pIdx);\n                    sqlite3VdbeJumpHere(v, addrBypass);\n                }\n                seenReplace = 1;\n                break;\n            }\n        }\n        sqlite3VdbeResolveLabel(v, addrUniqueOk);\n        if (regR != regIdx)\n            sqlite3ReleaseTempRange(pParse, regR, nPkField);\n        if (pUpsertClause && upsertIpkReturn && sqlite3UpsertNextIsIPK(pUpsertClause)) {\n            sqlite3VdbeGoto(v, upsertIpkDelay + 1);\n            sqlite3VdbeJumpHere(v, upsertIpkReturn);\n            upsertIpkReturn = 0;\n        }\n    }\n    if (ipkTop) {\n        sqlite3VdbeGoto(v, ipkTop);\n        ;\n        ((void)0);\n        sqlite3VdbeJumpHere(v, ipkBottom);\n    }\n    ;\n    ((void)0);\n    if (nReplaceTrig) {\n        sqlite3VdbeAddOp2(v, 17, regTrigCnt, lblRecheckOk);\n        ;\n        if (!pPk) {\n            if (isUpdate) {\n                sqlite3VdbeAddOp3(v, 53, regNewData, addrRecheck, regOldData);\n                sqlite3VdbeChangeP5(v, 144);\n                ;\n            }\n            sqlite3VdbeAddOp3(v, 31, iDataCur, addrRecheck, regNewData);\n            ;\n            sqlite3RowidConstraint(pParse, 2, pTab);\n        } else {\n            sqlite3VdbeGoto(v, addrRecheck);\n        }\n        sqlite3VdbeResolveLabel(v, lblRecheckOk);\n    }\n    if ((((pTab)->tabFlags & 128) == 0)) {\n        int regRec = aRegIdx[ix];\n        sqlite3VdbeAddOp3(v, 97, regNewData + 1, pTab->nNVCol, regRec);\n        ;\n        if (!bAffinityDone) {\n            sqlite3TableAffinity(v, pTab, 0);\n        }\n    }\n    *pbMayReplace = seenReplace;\n    ;\n}\n"
  },
  {
    "id": "sqlite3.c#83133:1#resolveP2Values",
    "nobreaks": 1,
    "body": "{\n    int nMaxArgs = *pMaxFuncArgs;\n    Op *pOp;\n    Parse *pParse = p->pParse;\n    int *aLabel = pParse->aLabel;\n    p->readOnly = 1;\n    p->bIsReader = 0;\n    pOp = &p->aOp[p->nOp - 1];\n    ((void)0);\n    while (1)\n        {\n            if (pOp->opcode <= 64) {\n                switch (pOp->opcode) {\n                  case 2:\n                    {\n                        if (pOp->p2 != 0)\n                            p->readOnly = 0;\n                    }\n                  case 1:\n                  case 0:\n                    {\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 3:\n                  case 5:\n                  case 4:\n                    {\n                        p->readOnly = 0;\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 8:\n                    {\n                        ((void)0);\n                        goto resolve_p2_values_loop_exit;\n                    }\n                  case 7:\n                    {\n                        if (pOp->p2 > nMaxArgs)\n                            nMaxArgs = pOp->p2;\n                        break;\n                    }\n                  case 6:\n                    {\n                        int n;\n                        ((void)0);\n                        ((void)0);\n                        n = pOp[-1].p1;\n                        if (n > nMaxArgs)\n                            nMaxArgs = n;\n                    }\n                  default:\n                    {\n                        if (pOp->p2 < 0) {\n                            ((void)0);\n                            ((void)0);\n                            pOp->p2 = aLabel[(~(pOp->p2))];\n                        }\n                        break;\n                    }\n                }\n                ((void)0);\n            }\n            ((void)0);\n            pOp--;\n        }\n  resolve_p2_values_loop_exit:\n    if (aLabel) {\n        sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n        pParse->aLabel = 0;\n    }\n    pParse->nLabel = 0;\n    *pMaxFuncArgs = nMaxArgs;\n    ((void)0);\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfTrue",
    "nobreaks": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    ((void)0);\n    if ((v == 0))\n        return;\n    if ((pExpr == 0))\n        return;\n    ((void)0);\n    op = pExpr->op;\n    switch (op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n            } else if (op == 44) {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            } else {\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            } else {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (op == 45) ? 53 : 52;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            ((void)0);\n            ;\n            ((void)0);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = jumpIfNull ? dest : destIfFalse;\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeGoto(v, dest);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "sqlite3.c#170061:1#yy_reduce",
    "nobreaks": 1,
    "body": "{\n    int yygoto;\n    unsigned short yyact;\n    yyStackEntry *yymsp;\n    int yysize;\n    (void)yyLookahead;\n    (void)yyLookaheadToken;\n    yymsp = yypParser->yytos;\n    switch (yyruleno) {\n        YYMINORTYPE yylhsminor;\n      case 0:\n        {\n            pParse->explain = 1;\n        }\n        break;\n      case 1:\n        {\n            pParse->explain = 2;\n        }\n        break;\n      case 2:\n        {\n            sqlite3FinishCoding(pParse);\n        }\n        break;\n      case 3:\n        {\n            sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 4:\n        {\n            yymsp[1].minor.yy394 = 7;\n        }\n        break;\n      case 5:\n      case 6:\n        ;\n      case 7:\n        ;\n      case 323:\n        ;\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 8:\n      case 9:\n        ;\n        {\n            sqlite3EndTransaction(pParse, yymsp[-1].major);\n        }\n        break;\n      case 10:\n        {\n            sqlite3Savepoint(pParse, 0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 11:\n        {\n            sqlite3Savepoint(pParse, 1, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 12:\n        {\n            sqlite3Savepoint(pParse, 2, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 13:\n        {\n            sqlite3StartTable(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy394, 0, 0, yymsp[-2].minor.yy394);\n        }\n        break;\n      case 14:\n        {\n            disableLookaside(pParse);\n        }\n        break;\n      case 15:\n      case 18:\n        ;\n      case 47:\n        ;\n      case 62:\n        ;\n      case 72:\n        ;\n      case 81:\n        ;\n      case 98:\n        ;\n      case 244:\n        ;\n        {\n            yymsp[1].minor.yy394 = 0;\n        }\n        break;\n      case 16:\n        {\n            yymsp[-2].minor.yy394 = 1;\n        }\n        break;\n      case 17:\n        {\n            yymsp[0].minor.yy394 = pParse->db->init.busy == 0;\n        }\n        break;\n      case 19:\n        {\n            sqlite3EndTable(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, yymsp[0].minor.yy285, 0);\n        }\n        break;\n      case 20:\n        {\n            sqlite3EndTable(pParse, 0, 0, 0, yymsp[0].minor.yy47);\n            sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n        }\n        break;\n      case 21:\n        {\n            yymsp[1].minor.yy285 = 0;\n        }\n        break;\n      case 22:\n        {\n            yylhsminor.yy285 = yymsp[-2].minor.yy285 | yymsp[0].minor.yy285;\n        }\n        yymsp[-2].minor.yy285 = yylhsminor.yy285;\n        break;\n      case 23:\n        {\n            if (yymsp[0].minor.yy0.n == 5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z, \"rowid\", 5) == 0) {\n                yymsp[-1].minor.yy285 = 128 | 512;\n            } else {\n                yymsp[-1].minor.yy285 = 0;\n                sqlite3ErrorMsg(pParse, \"unknown table option: %.*s\", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n            }\n        }\n        break;\n      case 24:\n        {\n            if (yymsp[0].minor.yy0.n == 6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z, \"strict\", 6) == 0) {\n                yylhsminor.yy285 = 65536;\n            } else {\n                yylhsminor.yy285 = 0;\n                sqlite3ErrorMsg(pParse, \"unknown table option: %.*s\", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n            }\n        }\n        yymsp[0].minor.yy285 = yylhsminor.yy285;\n        break;\n      case 25:\n        {\n            sqlite3AddColumn(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);\n        }\n        break;\n      case 26:\n      case 65:\n        ;\n      case 104:\n        ;\n        {\n            yymsp[1].minor.yy0.n = 0;\n            yymsp[1].minor.yy0.z = 0;\n        }\n        break;\n      case 27:\n        {\n            yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);\n        }\n        break;\n      case 28:\n        {\n            yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);\n        }\n        break;\n      case 29:\n        {\n            yymsp[-1].minor.yy0.n = yymsp[0].minor.yy0.n + (int)(yymsp[0].minor.yy0.z - yymsp[-1].minor.yy0.z);\n        }\n        break;\n      case 30:\n        {\n            ((void)0);\n            yymsp[1].minor.yy522 = yyLookaheadToken.z;\n        }\n        break;\n      case 31:\n        {\n            ((void)0);\n            yymsp[1].minor.yy0 = yyLookaheadToken;\n        }\n        break;\n      case 32:\n      case 67:\n        ;\n        {\n            pParse->constraintName = yymsp[0].minor.yy0;\n        }\n        break;\n      case 33:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy528, yymsp[-1].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 34:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[-1].minor.yy528, yymsp[-2].minor.yy0.z + 1, yymsp[0].minor.yy0.z);\n        }\n        break;\n      case 35:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy528, yymsp[-2].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 36:\n        {\n            Expr *p = sqlite3PExpr(pParse, 173, yymsp[0].minor.yy528, 0);\n            sqlite3AddDefaultValue(pParse, p, yymsp[-2].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 37:\n        {\n            Expr *p = tokenExpr(pParse, 117, yymsp[0].minor.yy0);\n            if (p) {\n                sqlite3ExprIdToTrueFalse(p);\n                ;\n            }\n            sqlite3AddDefaultValue(pParse, p, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.z + yymsp[0].minor.yy0.n);\n        }\n        break;\n      case 38:\n        {\n            sqlite3AddNotNull(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 39:\n        {\n            sqlite3AddPrimaryKey(pParse, 0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394, yymsp[-2].minor.yy394);\n        }\n        break;\n      case 40:\n        {\n            sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy394, 0, 0, 0, 0, 1);\n        }\n        break;\n      case 41:\n        {\n            sqlite3AddCheckConstraint(pParse, yymsp[-1].minor.yy528, yymsp[-2].minor.yy0.z, yymsp[0].minor.yy0.z);\n        }\n        break;\n      case 42:\n        {\n            sqlite3CreateForeignKey(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy394);\n        }\n        break;\n      case 43:\n        {\n            sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 44:\n        {\n            sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 45:\n        {\n            sqlite3AddGenerated(pParse, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 46:\n        {\n            sqlite3AddGenerated(pParse, yymsp[-2].minor.yy528, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 48:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 49:\n        {\n            yymsp[1].minor.yy394 = 0 * 257;\n        }\n        break;\n      case 50:\n        {\n            yymsp[-1].minor.yy394 = (yymsp[-1].minor.yy394 & ~yymsp[0].minor.yy231.mask) | yymsp[0].minor.yy231.value;\n        }\n        break;\n      case 51:\n        {\n            yymsp[-1].minor.yy231.value = 0;\n            yymsp[-1].minor.yy231.mask = 0;\n        }\n        break;\n      case 52:\n        {\n            yymsp[-2].minor.yy231.value = 0;\n            yymsp[-2].minor.yy231.mask = 0;\n        }\n        break;\n      case 53:\n        {\n            yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394;\n            yymsp[-2].minor.yy231.mask = 255;\n        }\n        break;\n      case 54:\n        {\n            yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394 << 8;\n            yymsp[-2].minor.yy231.mask = 65280;\n        }\n        break;\n      case 55:\n        {\n            yymsp[-1].minor.yy394 = 8;\n        }\n        break;\n      case 56:\n        {\n            yymsp[-1].minor.yy394 = 9;\n        }\n        break;\n      case 57:\n        {\n            yymsp[0].minor.yy394 = 10;\n        }\n        break;\n      case 58:\n        {\n            yymsp[0].minor.yy394 = 7;\n        }\n        break;\n      case 59:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 60:\n        {\n            yymsp[-2].minor.yy394 = 0;\n        }\n        break;\n      case 61:\n      case 76:\n        ;\n      case 171:\n        ;\n        {\n            yymsp[-1].minor.yy394 = yymsp[0].minor.yy394;\n        }\n        break;\n      case 63:\n      case 80:\n        ;\n      case 216:\n        ;\n      case 219:\n        ;\n      case 245:\n        ;\n        {\n            yymsp[-1].minor.yy394 = 1;\n        }\n        break;\n      case 64:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 66:\n        {\n            pParse->constraintName.n = 0;\n        }\n        break;\n      case 68:\n        {\n            sqlite3AddPrimaryKey(pParse, yymsp[-3].minor.yy322, yymsp[0].minor.yy394, yymsp[-2].minor.yy394, 0);\n        }\n        break;\n      case 69:\n        {\n            sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[-2].minor.yy322, yymsp[0].minor.yy394, 0, 0, 0, 0, 1);\n        }\n        break;\n      case 70:\n        {\n            sqlite3AddCheckConstraint(pParse, yymsp[-2].minor.yy528, yymsp[-3].minor.yy0.z, yymsp[-1].minor.yy0.z);\n        }\n        break;\n      case 71:\n        {\n            sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy394);\n            sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 73:\n      case 75:\n        ;\n        {\n            yymsp[1].minor.yy394 = 11;\n        }\n        break;\n      case 74:\n        {\n            yymsp[-2].minor.yy394 = yymsp[0].minor.yy394;\n        }\n        break;\n      case 77:\n        {\n            yymsp[0].minor.yy394 = 4;\n        }\n        break;\n      case 78:\n      case 172:\n        ;\n        {\n            yymsp[0].minor.yy394 = 5;\n        }\n        break;\n      case 79:\n        {\n            sqlite3DropTable(pParse, yymsp[0].minor.yy131, 0, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 82:\n        {\n            sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[0].minor.yy47, yymsp[-7].minor.yy394, yymsp[-5].minor.yy394);\n        }\n        break;\n      case 83:\n        {\n            sqlite3DropTable(pParse, yymsp[0].minor.yy131, 1, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 84:\n        {\n            SelectDest dest = {9, 0, 0, 0, 0, 0, 0};\n            sqlite3Select(pParse, yymsp[0].minor.yy47, &dest);\n            sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n        }\n        break;\n      case 85:\n        {\n            yymsp[-2].minor.yy47 = attachWithToSelect(pParse, yymsp[0].minor.yy47, yymsp[-1].minor.yy521);\n        }\n        break;\n      case 86:\n        {\n            yymsp[-3].minor.yy47 = attachWithToSelect(pParse, yymsp[0].minor.yy47, yymsp[-1].minor.yy521);\n        }\n        break;\n      case 87:\n        {\n            Select *p = yymsp[0].minor.yy47;\n            if (p) {\n                parserDoubleLinkSelect(pParse, p);\n            }\n            yymsp[0].minor.yy47 = p;\n        }\n        break;\n      case 88:\n        {\n            Select *pRhs = yymsp[0].minor.yy47;\n            Select *pLhs = yymsp[-2].minor.yy47;\n            if (pRhs && pRhs->pPrior) {\n                SrcList *pFrom;\n                Token x;\n                x.n = 0;\n                parserDoubleLinkSelect(pParse, pRhs);\n                pFrom = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &x, pRhs, 0);\n                pRhs = sqlite3SelectNew(pParse, 0, pFrom, 0, 0, 0, 0, 0, 0);\n            }\n            if (pRhs) {\n                pRhs->op = (u8)yymsp[-1].minor.yy394;\n                pRhs->pPrior = pLhs;\n                if ((pLhs))\n                    pLhs->selFlags &= ~1024;\n                pRhs->selFlags &= ~1024;\n                if (yymsp[-1].minor.yy394 != 135)\n                    pParse->hasCompound = 1;\n            } else {\n                sqlite3SelectDelete(pParse->db, pLhs);\n            }\n            yymsp[-2].minor.yy47 = pRhs;\n        }\n        break;\n      case 89:\n      case 91:\n        ;\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 90:\n        {\n            yymsp[-1].minor.yy394 = 135;\n        }\n        break;\n      case 92:\n        {\n            yymsp[-8].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-6].minor.yy322, yymsp[-5].minor.yy131, yymsp[-4].minor.yy528, yymsp[-3].minor.yy322, yymsp[-2].minor.yy528, yymsp[-1].minor.yy322, yymsp[-7].minor.yy394, yymsp[0].minor.yy528);\n        }\n        break;\n      case 93:\n        {\n            yymsp[-9].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-7].minor.yy322, yymsp[-6].minor.yy131, yymsp[-5].minor.yy528, yymsp[-4].minor.yy322, yymsp[-3].minor.yy528, yymsp[-1].minor.yy322, yymsp[-8].minor.yy394, yymsp[0].minor.yy528);\n            if (yymsp[-9].minor.yy47) {\n                yymsp[-9].minor.yy47->pWinDefn = yymsp[-2].minor.yy41;\n            } else {\n                sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy41);\n            }\n        }\n        break;\n      case 94:\n        {\n            yymsp[-3].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-1].minor.yy322, 0, 0, 0, 0, 0, 512, 0);\n        }\n        break;\n      case 95:\n        {\n            Select *pRight, *pLeft = yymsp[-4].minor.yy47;\n            pRight = sqlite3SelectNew(pParse, yymsp[-1].minor.yy322, 0, 0, 0, 0, 0, 512 | 1024, 0);\n            if ((pLeft))\n                pLeft->selFlags &= ~1024;\n            if (pRight) {\n                pRight->op = 135;\n                pRight->pPrior = pLeft;\n                yymsp[-4].minor.yy47 = pRight;\n            } else {\n                yymsp[-4].minor.yy47 = pLeft;\n            }\n        }\n        break;\n      case 96:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 97:\n        {\n            yymsp[0].minor.yy394 = 2;\n        }\n        break;\n      case 99:\n      case 132:\n        ;\n      case 142:\n        ;\n      case 232:\n        ;\n      case 235:\n        ;\n      case 240:\n        ;\n        {\n            yymsp[1].minor.yy322 = 0;\n        }\n        break;\n      case 100:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            if (yymsp[0].minor.yy0.n > 0)\n                sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[0].minor.yy0, 1);\n            sqlite3ExprListSetSpan(pParse, yymsp[-4].minor.yy322, yymsp[-3].minor.yy522, yymsp[-1].minor.yy522);\n        }\n        break;\n      case 101:\n        {\n            Expr *p = sqlite3Expr(pParse->db, 180, 0);\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, p);\n        }\n        break;\n      case 102:\n        {\n            Expr *pRight = sqlite3PExpr(pParse, 180, 0, 0);\n            Expr *pLeft = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *pDot = sqlite3PExpr(pParse, 141, pLeft, pRight);\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, pDot);\n        }\n        break;\n      case 103:\n      case 115:\n        ;\n      case 256:\n        ;\n      case 257:\n        ;\n        {\n            yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;\n        }\n        break;\n      case 105:\n      case 108:\n        ;\n        {\n            yymsp[1].minor.yy131 = 0;\n        }\n        break;\n      case 106:\n        {\n            yymsp[-1].minor.yy131 = yymsp[0].minor.yy131;\n            sqlite3SrcListShiftJoinType(pParse, yymsp[-1].minor.yy131);\n        }\n        break;\n      case 107:\n        {\n            if ((yymsp[-1].minor.yy131 && yymsp[-1].minor.yy131->nSrc > 0))\n                yymsp[-1].minor.yy131->a[yymsp[-1].minor.yy131->nSrc - 1].fg.jointype = (u8)yymsp[0].minor.yy394;\n        }\n        break;\n      case 109:\n        {\n            yymsp[-4].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-4].minor.yy131, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n        }\n        break;\n      case 110:\n        {\n            yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, 0, &yymsp[0].minor.yy561);\n            sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 111:\n        {\n            yymsp[-7].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-7].minor.yy131, &yymsp[-6].minor.yy0, &yymsp[-5].minor.yy0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n            sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy131, yymsp[-3].minor.yy322);\n        }\n        break;\n      case 112:\n        {\n            yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, yymsp[-3].minor.yy47, &yymsp[0].minor.yy561);\n        }\n        break;\n      case 113:\n        {\n            if (yymsp[-5].minor.yy131 == 0 && yymsp[-1].minor.yy0.n == 0 && yymsp[0].minor.yy561.pOn == 0 && yymsp[0].minor.yy561.pUsing == 0) {\n                yymsp[-5].minor.yy131 = yymsp[-3].minor.yy131;\n            } else if (yymsp[-3].minor.yy131->nSrc == 1) {\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n                if (yymsp[-5].minor.yy131) {\n                    SrcItem *pNew = &yymsp[-5].minor.yy131->a[yymsp[-5].minor.yy131->nSrc - 1];\n                    SrcItem *pOld = yymsp[-3].minor.yy131->a;\n                    pNew->zName = pOld->zName;\n                    pNew->zDatabase = pOld->zDatabase;\n                    pNew->pSelect = pOld->pSelect;\n                    if (pNew->pSelect && (pNew->pSelect->selFlags & 2048) != 0) {\n                        pNew->fg.isNestedFrom = 1;\n                    }\n                    if (pOld->fg.isTabFunc) {\n                        pNew->u1.pFuncArg = pOld->u1.pFuncArg;\n                        pOld->u1.pFuncArg = 0;\n                        pOld->fg.isTabFunc = 0;\n                        pNew->fg.isTabFunc = 1;\n                    }\n                    pOld->zName = pOld->zDatabase = 0;\n                    pOld->pSelect = 0;\n                }\n                sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy131);\n            } else {\n                Select *pSubquery;\n                sqlite3SrcListShiftJoinType(pParse, yymsp[-3].minor.yy131);\n                pSubquery = sqlite3SelectNew(pParse, 0, yymsp[-3].minor.yy131, 0, 0, 0, 0, 2048, 0);\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, pSubquery, &yymsp[0].minor.yy561);\n            }\n        }\n        break;\n      case 114:\n      case 129:\n        ;\n        {\n            yymsp[1].minor.yy0.z = 0;\n            yymsp[1].minor.yy0.n = 0;\n        }\n        break;\n      case 116:\n        {\n            yylhsminor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[0].minor.yy0, 0);\n            if ((pParse->eParseMode >= 2) && yylhsminor.yy131)\n                sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n        }\n        yymsp[0].minor.yy131 = yylhsminor.yy131;\n        break;\n      case 117:\n        {\n            yylhsminor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n            if ((pParse->eParseMode >= 2) && yylhsminor.yy131)\n                sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n        }\n        yymsp[-2].minor.yy131 = yylhsminor.yy131;\n        break;\n      case 118:\n        {\n            yymsp[0].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[0].minor.yy0, 0);\n        }\n        break;\n      case 119:\n        {\n            yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 120:\n        {\n            yymsp[-4].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-4].minor.yy0, &yymsp[-2].minor.yy0);\n            if (yymsp[-4].minor.yy131)\n                yymsp[-4].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 121:\n        {\n            yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, 0);\n            if (yymsp[-2].minor.yy131)\n                yymsp[-2].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 122:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 123:\n        {\n            yymsp[-1].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-1].minor.yy0, 0, 0);\n        }\n        break;\n      case 124:\n        {\n            yymsp[-2].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, 0);\n        }\n        break;\n      case 125:\n        {\n            yymsp[-3].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 126:\n        {\n            yymsp[-1].minor.yy561.pOn = yymsp[0].minor.yy528;\n            yymsp[-1].minor.yy561.pUsing = 0;\n        }\n        break;\n      case 127:\n        {\n            yymsp[-3].minor.yy561.pOn = 0;\n            yymsp[-3].minor.yy561.pUsing = yymsp[-1].minor.yy254;\n        }\n        break;\n      case 128:\n        {\n            yymsp[1].minor.yy561.pOn = 0;\n            yymsp[1].minor.yy561.pUsing = 0;\n        }\n        break;\n      case 130:\n        {\n            yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;\n        }\n        break;\n      case 131:\n        {\n            yymsp[-1].minor.yy0.z = 0;\n            yymsp[-1].minor.yy0.n = 1;\n        }\n        break;\n      case 133:\n      case 143:\n        ;\n        {\n            yymsp[-2].minor.yy322 = yymsp[0].minor.yy322;\n        }\n        break;\n      case 134:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy322, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 135:\n        {\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy322, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 136:\n        {\n            yymsp[0].minor.yy394 = 0;\n        }\n        break;\n      case 137:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 138:\n      case 141:\n        ;\n        {\n            yymsp[1].minor.yy394 = -1;\n        }\n        break;\n      case 139:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 140:\n        {\n            yymsp[-1].minor.yy394 = 1;\n        }\n        break;\n      case 144:\n      case 146:\n        ;\n      case 151:\n        ;\n      case 153:\n        ;\n      case 229:\n        ;\n      case 231:\n        ;\n      case 250:\n        ;\n        {\n            yymsp[1].minor.yy528 = 0;\n        }\n        break;\n      case 145:\n      case 152:\n        ;\n      case 154:\n        ;\n      case 228:\n        ;\n      case 249:\n        ;\n        {\n            yymsp[-1].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 147:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 148:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 149:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[0].minor.yy528, yymsp[-2].minor.yy528);\n        }\n        break;\n      case 150:\n        {\n            sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy131, &yymsp[-1].minor.yy0);\n            sqlite3DeleteFrom(pParse, yymsp[-2].minor.yy131, yymsp[0].minor.yy528, 0, 0);\n        }\n        break;\n      case 155:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n            yymsp[-1].minor.yy528 = 0;\n        }\n        break;\n      case 156:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n            yymsp[-3].minor.yy528 = yymsp[-2].minor.yy528;\n        }\n        break;\n      case 157:\n        {\n            sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-4].minor.yy0);\n            sqlite3ExprListCheckLength(pParse, yymsp[-2].minor.yy322, \"set list\");\n            if (yymsp[-1].minor.yy131) {\n                SrcList *pFromClause = yymsp[-1].minor.yy131;\n                if (pFromClause->nSrc > 1) {\n                    Select *pSubquery;\n                    Token as;\n                    pSubquery = sqlite3SelectNew(pParse, 0, pFromClause, 0, 0, 0, 0, 2048, 0);\n                    as.n = 0;\n                    as.z = 0;\n                    pFromClause = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &as, pSubquery, 0);\n                }\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy131, pFromClause);\n            }\n            sqlite3Update(pParse, yymsp[-5].minor.yy131, yymsp[-2].minor.yy322, yymsp[0].minor.yy528, yymsp[-6].minor.yy394, 0, 0, 0);\n        }\n        break;\n      case 158:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n            sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, 1);\n        }\n        break;\n      case 159:\n        {\n            yymsp[-6].minor.yy322 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy322, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n        }\n        break;\n      case 160:\n        {\n            yylhsminor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n            sqlite3ExprListSetName(pParse, yylhsminor.yy322, &yymsp[-2].minor.yy0, 1);\n        }\n        yymsp[-2].minor.yy322 = yylhsminor.yy322;\n        break;\n      case 161:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n        }\n        break;\n      case 162:\n        {\n            sqlite3Insert(pParse, yymsp[-3].minor.yy131, yymsp[-1].minor.yy47, yymsp[-2].minor.yy254, yymsp[-5].minor.yy394, yymsp[0].minor.yy444);\n        }\n        break;\n      case 163:\n        {\n            sqlite3Insert(pParse, yymsp[-4].minor.yy131, 0, yymsp[-3].minor.yy254, yymsp[-6].minor.yy394, 0);\n        }\n        break;\n      case 164:\n        {\n            yymsp[1].minor.yy444 = 0;\n        }\n        break;\n      case 165:\n        {\n            yymsp[-1].minor.yy444 = 0;\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n        }\n        break;\n      case 166:\n        {\n            yymsp[-11].minor.yy444 = sqlite3UpsertNew(pParse->db, yymsp[-8].minor.yy322, yymsp[-6].minor.yy528, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528, yymsp[0].minor.yy444);\n        }\n        break;\n      case 167:\n        {\n            yymsp[-8].minor.yy444 = sqlite3UpsertNew(pParse->db, yymsp[-5].minor.yy322, yymsp[-3].minor.yy528, 0, 0, yymsp[0].minor.yy444);\n        }\n        break;\n      case 168:\n        {\n            yymsp[-4].minor.yy444 = sqlite3UpsertNew(pParse->db, 0, 0, 0, 0, 0);\n        }\n        break;\n      case 169:\n        {\n            yymsp[-7].minor.yy444 = sqlite3UpsertNew(pParse->db, 0, 0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 170:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n        }\n        break;\n      case 173:\n        {\n            yymsp[1].minor.yy254 = 0;\n        }\n        break;\n      case 174:\n        {\n            yymsp[-2].minor.yy254 = yymsp[-1].minor.yy254;\n        }\n        break;\n      case 175:\n        {\n            yymsp[-2].minor.yy254 = sqlite3IdListAppend(pParse, yymsp[-2].minor.yy254, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 176:\n        {\n            yymsp[0].minor.yy254 = sqlite3IdListAppend(pParse, 0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 177:\n        {\n            yymsp[-2].minor.yy528 = yymsp[-1].minor.yy528;\n        }\n        break;\n      case 178:\n      case 179:\n        ;\n        {\n            yymsp[0].minor.yy528 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n        }\n        break;\n      case 180:\n        {\n            Expr *temp1 = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *temp2 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n            yylhsminor.yy528 = sqlite3PExpr(pParse, 141, temp1, temp2);\n        }\n        yymsp[-2].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 181:\n        {\n            Expr *temp1 = tokenExpr(pParse, 59, yymsp[-4].minor.yy0);\n            Expr *temp2 = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *temp3 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n            Expr *temp4 = sqlite3PExpr(pParse, 141, temp2, temp3);\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, 0, temp1);\n            }\n            yylhsminor.yy528 = sqlite3PExpr(pParse, 141, temp1, temp4);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 182:\n      case 183:\n        ;\n        {\n            yymsp[0].minor.yy528 = tokenExpr(pParse, yymsp[0].major, yymsp[0].minor.yy0);\n        }\n        break;\n      case 184:\n        {\n            yylhsminor.yy528 = sqlite3ExprAlloc(pParse->db, 155, &yymsp[0].minor.yy0, 1);\n            if (yylhsminor.yy528)\n                yylhsminor.yy528->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);\n        }\n        yymsp[0].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 185:\n        {\n            if (!(yymsp[0].minor.yy0.z[0] == '#' && (sqlite3CtypeMap[(unsigned char)(yymsp[0].minor.yy0.z[1])] & 4))) {\n                u32 n = yymsp[0].minor.yy0.n;\n                yymsp[0].minor.yy528 = tokenExpr(pParse, 156, yymsp[0].minor.yy0);\n                sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy528, n);\n            } else {\n                Token t = yymsp[0].minor.yy0;\n                ((void)0);\n                if (pParse->nested == 0) {\n                    sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &t);\n                    yymsp[0].minor.yy528 = 0;\n                } else {\n                    yymsp[0].minor.yy528 = sqlite3PExpr(pParse, 176, 0, 0);\n                    if (yymsp[0].minor.yy528)\n                        sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy528->iTable);\n                }\n            }\n        }\n        break;\n      case 186:\n        {\n            yymsp[-2].minor.yy528 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy528, &yymsp[0].minor.yy0, 1);\n        }\n        break;\n      case 187:\n        {\n            yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, 36, &yymsp[-1].minor.yy0, 1);\n            sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy528, yymsp[-3].minor.yy528, 0);\n        }\n        break;\n      case 188:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy394);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 189:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n        }\n        yymsp[-3].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 190:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy322, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy394);\n            sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n        }\n        yymsp[-5].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 191:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n            sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 192:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n        }\n        yymsp[0].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 193:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 177, 0, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = pList;\n                if ((pList->nExpr)) {\n                    yymsp[-4].minor.yy528->flags |= pList->a[0].pExpr->flags & (512 | 4194304 | 8);\n                }\n            } else {\n                sqlite3ExprListDelete(pParse->db, pList);\n            }\n        }\n        break;\n      case 194:\n        {\n            yymsp[-2].minor.yy528 = sqlite3ExprAnd(pParse, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 195:\n      case 196:\n        ;\n      case 197:\n        ;\n      case 198:\n        ;\n      case 199:\n        ;\n      case 200:\n        ;\n      case 201:\n        ;\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 202:\n        {\n            yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;\n            yymsp[-1].minor.yy0.n |= 2147483648U;\n        }\n        break;\n      case 203:\n        {\n            ExprList *pList;\n            int bNot = yymsp[-1].minor.yy0.n & 2147483648U;\n            yymsp[-1].minor.yy0.n &= 2147483647;\n            pList = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[-2].minor.yy528);\n            yymsp[-2].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n            if (bNot)\n                yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-2].minor.yy528, 0);\n            if (yymsp[-2].minor.yy528)\n                yymsp[-2].minor.yy528->flags |= 256;\n        }\n        break;\n      case 204:\n        {\n            ExprList *pList;\n            int bNot = yymsp[-3].minor.yy0.n & 2147483648U;\n            yymsp[-3].minor.yy0.n &= 2147483647;\n            pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[-4].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n            if (bNot)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528)\n                yymsp[-4].minor.yy528->flags |= 256;\n        }\n        break;\n      case 205:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[0].major, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 206:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 51, yymsp[-2].minor.yy528, 0);\n        }\n        break;\n      case 207:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 45, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-2].minor.yy528, 50);\n        }\n        break;\n      case 208:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 171, yymsp[-3].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-3].minor.yy528, 51);\n        }\n        break;\n      case 209:\n        {\n            yymsp[-5].minor.yy528 = sqlite3PExpr(pParse, 45, yymsp[-5].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-5].minor.yy528, 50);\n        }\n        break;\n      case 210:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 171, yymsp[-4].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-4].minor.yy528, 51);\n        }\n        break;\n      case 211:\n      case 212:\n        ;\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 213:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major == 106 ? 174 : 173, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 214:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n        }\n        yymsp[-2].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 215:\n      case 218:\n        ;\n        {\n            yymsp[0].minor.yy394 = 0;\n        }\n        break;\n      case 217:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 48, yymsp[-4].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = pList;\n            } else {\n                sqlite3ExprListDelete(pParse->db, pList);\n            }\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 220:\n        {\n            if (yymsp[-1].minor.yy322 == 0) {\n                sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy528);\n                yymsp[-4].minor.yy528 = sqlite3Expr(pParse->db, 117, yymsp[-3].minor.yy394 ? \"true\" : \"false\");\n                if (yymsp[-4].minor.yy528)\n                    sqlite3ExprIdToTrueFalse(yymsp[-4].minor.yy528);\n            } else {\n                Expr *pRHS = yymsp[-1].minor.yy322->a[0].pExpr;\n                if (yymsp[-1].minor.yy322->nExpr == 1 && sqlite3ExprIsConstant(pRHS) && yymsp[-4].minor.yy528->op != 177) {\n                    yymsp[-1].minor.yy322->a[0].pExpr = 0;\n                    sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n                    pRHS = sqlite3PExpr(pParse, 174, pRHS, 0);\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 53, yymsp[-4].minor.yy528, pRHS);\n                } else {\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n                    if (yymsp[-4].minor.yy528 == 0) {\n                        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n                    } else if (yymsp[-4].minor.yy528->pLeft->op == 177) {\n                        int nExpr = yymsp[-4].minor.yy528->pLeft->x.pList->nExpr;\n                        Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy322);\n                        if (pSelectRHS) {\n                            parserDoubleLinkSelect(pParse, pSelectRHS);\n                            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelectRHS);\n                        }\n                    } else {\n                        yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy322;\n                        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n                    }\n                }\n                if (yymsp[-3].minor.yy394)\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n            }\n        }\n        break;\n      case 221:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 138, 0, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy528, yymsp[-1].minor.yy47);\n        }\n        break;\n      case 222:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, yymsp[-1].minor.yy47);\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 223:\n        {\n            SrcList *pSrc = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);\n            Select *pSelect = sqlite3SelectNew(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0);\n            if (yymsp[0].minor.yy322)\n                sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy322);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelect);\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 224:\n        {\n            Expr *p;\n            p = yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 20, 0, 0);\n            sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy47);\n        }\n        break;\n      case 225:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 157, yymsp[-3].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy528 ? sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528) : yymsp[-2].minor.yy322;\n                sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n            } else {\n                sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy322);\n                sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n            }\n        }\n        break;\n      case 226:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 227:\n        {\n            yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 230:\n        {\n            yymsp[0].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 233:\n        {\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 234:\n        {\n            yymsp[0].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 236:\n      case 241:\n        ;\n        {\n            yymsp[-2].minor.yy322 = yymsp[-1].minor.yy322;\n        }\n        break;\n      case 237:\n        {\n            sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, sqlite3SrcListAppend(pParse, 0, &yymsp[-4].minor.yy0, 0), yymsp[-2].minor.yy322, yymsp[-10].minor.yy394, &yymsp[-11].minor.yy0, yymsp[0].minor.yy528, 0, yymsp[-8].minor.yy394, 0);\n            if ((pParse->eParseMode >= 2) && pParse->pNewIndex) {\n                sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);\n            }\n        }\n        break;\n      case 238:\n      case 280:\n        ;\n        {\n            yymsp[0].minor.yy394 = 2;\n        }\n        break;\n      case 239:\n        {\n            yymsp[1].minor.yy394 = 0;\n        }\n        break;\n      case 242:\n        {\n            yymsp[-4].minor.yy322 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 243:\n        {\n            yymsp[-2].minor.yy322 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 246:\n        {\n            sqlite3DropIndex(pParse, yymsp[0].minor.yy131, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 247:\n        {\n            sqlite3Vacuum(pParse, 0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 248:\n        {\n            sqlite3Vacuum(pParse, &yymsp[-1].minor.yy0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 251:\n        {\n            sqlite3Pragma(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, 0, 0);\n        }\n        break;\n      case 252:\n        {\n            sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 0);\n        }\n        break;\n      case 253:\n        {\n            sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 0);\n        }\n        break;\n      case 254:\n        {\n            sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 1);\n        }\n        break;\n      case 255:\n        {\n            sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 1);\n        }\n        break;\n      case 258:\n        {\n            Token all;\n            all.z = yymsp[-3].minor.yy0.z;\n            all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;\n            sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy33, &all);\n        }\n        break;\n      case 259:\n        {\n            sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy394, yymsp[-4].minor.yy180.a, yymsp[-4].minor.yy180.b, yymsp[-2].minor.yy131, yymsp[0].minor.yy528, yymsp[-10].minor.yy394, yymsp[-8].minor.yy394);\n            yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n == 0 ? yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0);\n        }\n        break;\n      case 260:\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 261:\n        {\n            yymsp[-1].minor.yy394 = 65;\n        }\n        break;\n      case 262:\n        {\n            yymsp[1].minor.yy394 = 33;\n        }\n        break;\n      case 263:\n      case 264:\n        ;\n        {\n            yymsp[0].minor.yy180.a = yymsp[0].major;\n            yymsp[0].minor.yy180.b = 0;\n        }\n        break;\n      case 265:\n        {\n            yymsp[-2].minor.yy180.a = 129;\n            yymsp[-2].minor.yy180.b = yymsp[0].minor.yy254;\n        }\n        break;\n      case 266:\n      case 285:\n        ;\n        {\n            yymsp[1].minor.yy528 = 0;\n        }\n        break;\n      case 267:\n      case 286:\n        ;\n        {\n            yymsp[-1].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 268:\n        {\n            ((void)0);\n            yymsp[-2].minor.yy33->pLast->pNext = yymsp[-1].minor.yy33;\n            yymsp[-2].minor.yy33->pLast = yymsp[-1].minor.yy33;\n        }\n        break;\n      case 269:\n        {\n            ((void)0);\n            yymsp[-1].minor.yy33->pLast = yymsp[-1].minor.yy33;\n        }\n        break;\n      case 270:\n        {\n            yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;\n            sqlite3ErrorMsg(pParse, \"qualified table names are not allowed on INSERT, UPDATE, and DELETE statements within triggers\");\n        }\n        break;\n      case 271:\n        {\n            sqlite3ErrorMsg(pParse, \"the INDEXED BY clause is not allowed on UPDATE or DELETE statements within triggers\");\n        }\n        break;\n      case 272:\n        {\n            sqlite3ErrorMsg(pParse, \"the NOT INDEXED clause is not allowed on UPDATE or DELETE statements within triggers\");\n        }\n        break;\n      case 273:\n        {\n            yylhsminor.yy33 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy131, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528, yymsp[-7].minor.yy394, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy522);\n        }\n        yymsp[-8].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 274:\n        {\n            yylhsminor.yy33 = sqlite3TriggerInsertStep(pParse, &yymsp[-4].minor.yy0, yymsp[-3].minor.yy254, yymsp[-2].minor.yy47, yymsp[-6].minor.yy394, yymsp[-1].minor.yy444, yymsp[-7].minor.yy522, yymsp[0].minor.yy522);\n        }\n        yymsp[-7].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 275:\n        {\n            yylhsminor.yy33 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy528, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy522);\n        }\n        yymsp[-5].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 276:\n        {\n            yylhsminor.yy33 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy47, yymsp[-2].minor.yy522, yymsp[0].minor.yy522);\n        }\n        yymsp[-2].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 277:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 71, 0, 0);\n            if (yymsp[-3].minor.yy528) {\n                yymsp[-3].minor.yy528->affExpr = 4;\n            }\n        }\n        break;\n      case 278:\n        {\n            yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, 71, &yymsp[-1].minor.yy0, 1);\n            if (yymsp[-5].minor.yy528) {\n                yymsp[-5].minor.yy528->affExpr = (char)yymsp[-3].minor.yy394;\n            }\n        }\n        break;\n      case 279:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 281:\n        {\n            yymsp[0].minor.yy394 = 3;\n        }\n        break;\n      case 282:\n        {\n            sqlite3DropTrigger(pParse, yymsp[0].minor.yy131, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 283:\n        {\n            sqlite3Attach(pParse, yymsp[-3].minor.yy528, yymsp[-1].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 284:\n        {\n            sqlite3Detach(pParse, yymsp[0].minor.yy528);\n        }\n        break;\n      case 287:\n        {\n            sqlite3Reindex(pParse, 0, 0);\n        }\n        break;\n      case 288:\n        {\n            sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 289:\n        {\n            sqlite3Analyze(pParse, 0, 0);\n        }\n        break;\n      case 290:\n        {\n            sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 291:\n        {\n            sqlite3AlterRenameTable(pParse, yymsp[-3].minor.yy131, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 292:\n        {\n            yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z - yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;\n            sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 293:\n        {\n            sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy131, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 294:\n        {\n            disableLookaside(pParse);\n            sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy131);\n        }\n        break;\n      case 295:\n        {\n            sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy131, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 296:\n        {\n            sqlite3VtabFinishParse(pParse, 0);\n        }\n        break;\n      case 297:\n        {\n            sqlite3VtabFinishParse(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 298:\n        {\n            sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy394);\n        }\n        break;\n      case 299:\n        {\n            sqlite3VtabArgInit(pParse);\n        }\n        break;\n      case 300:\n      case 301:\n        ;\n      case 302:\n        ;\n        {\n            sqlite3VtabArgExtend(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 303:\n      case 304:\n        ;\n        {\n            sqlite3WithPush(pParse, yymsp[0].minor.yy521, 1);\n        }\n        break;\n      case 305:\n        {\n            yymsp[0].minor.yy516 = 1;\n        }\n        break;\n      case 306:\n        {\n            yymsp[-1].minor.yy516 = 0;\n        }\n        break;\n      case 307:\n        {\n            yymsp[-2].minor.yy516 = 2;\n        }\n        break;\n      case 308:\n        {\n            yymsp[-5].minor.yy385 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy322, yymsp[-1].minor.yy47, yymsp[-3].minor.yy516);\n        }\n        break;\n      case 309:\n        {\n            yymsp[0].minor.yy521 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy385);\n        }\n        break;\n      case 310:\n        {\n            yymsp[-2].minor.yy521 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy521, yymsp[0].minor.yy385);\n        }\n        break;\n      case 311:\n        {\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 312:\n        {\n            ((void)0);\n            sqlite3WindowChain(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy41);\n            yymsp[0].minor.yy41->pNextWin = yymsp[-2].minor.yy41;\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[-2].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 313:\n        {\n            if ((yymsp[-1].minor.yy41)) {\n                yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n            }\n            yylhsminor.yy41 = yymsp[-1].minor.yy41;\n        }\n        yymsp[-4].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 314:\n        {\n            yymsp[-4].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, 0);\n        }\n        break;\n      case 315:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, &yymsp[-5].minor.yy0);\n        }\n        yymsp[-5].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 316:\n        {\n            yymsp[-3].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, 0);\n        }\n        break;\n      case 317:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0);\n        }\n        yymsp[-4].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 318:\n      case 337:\n        ;\n        {\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 319:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, 0, &yymsp[-1].minor.yy0);\n        }\n        yymsp[-1].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 320:\n        {\n            yymsp[1].minor.yy41 = sqlite3WindowAlloc(pParse, 0, 90, 0, 85, 0, 0);\n        }\n        break;\n      case 321:\n        {\n            yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy394, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, 85, 0, yymsp[0].minor.yy516);\n        }\n        yymsp[-2].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 322:\n        {\n            yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy394, yymsp[-3].minor.yy595.eType, yymsp[-3].minor.yy595.pExpr, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, yymsp[0].minor.yy516);\n        }\n        yymsp[-5].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 324:\n      case 326:\n        ;\n        {\n            yylhsminor.yy595 = yymsp[0].minor.yy595;\n        }\n        yymsp[0].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 325:\n      case 327:\n        ;\n      case 329:\n        ;\n        {\n            yylhsminor.yy595.eType = yymsp[-1].major;\n            yylhsminor.yy595.pExpr = 0;\n        }\n        yymsp[-1].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 328:\n        {\n            yylhsminor.yy595.eType = yymsp[0].major;\n            yylhsminor.yy595.pExpr = yymsp[-1].minor.yy528;\n        }\n        yymsp[-1].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 330:\n        {\n            yymsp[1].minor.yy516 = 0;\n        }\n        break;\n      case 331:\n        {\n            yymsp[-1].minor.yy516 = yymsp[0].minor.yy516;\n        }\n        break;\n      case 332:\n      case 333:\n        ;\n        {\n            yymsp[-1].minor.yy516 = yymsp[-1].major;\n        }\n        break;\n      case 334:\n        {\n            yymsp[0].minor.yy516 = yymsp[0].major;\n        }\n        break;\n      case 335:\n        {\n            yymsp[-1].minor.yy41 = yymsp[0].minor.yy41;\n        }\n        break;\n      case 336:\n        {\n            if (yymsp[0].minor.yy41) {\n                yymsp[0].minor.yy41->pFilter = yymsp[-1].minor.yy528;\n            } else {\n                sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n            }\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[-1].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 338:\n        {\n            yylhsminor.yy41 = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n            if (yylhsminor.yy41) {\n                yylhsminor.yy41->eFrmType = 166;\n                yylhsminor.yy41->pFilter = yymsp[0].minor.yy528;\n            } else {\n                sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy528);\n            }\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 339:\n        {\n            yymsp[-3].minor.yy41 = yymsp[-1].minor.yy41;\n            ((void)0);\n        }\n        break;\n      case 340:\n        {\n            yymsp[-1].minor.yy41 = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n            if (yymsp[-1].minor.yy41) {\n                yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n            }\n        }\n        break;\n      case 341:\n        {\n            yymsp[-4].minor.yy528 = yymsp[-1].minor.yy528;\n        }\n        break;\n      default:\n        ;\n        ;\n        ((void)0);\n        ;\n        ;\n        ((void)0);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ((void)0);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ((void)0);\n        ((void)0);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ((void)0);\n        ;\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        ;\n        ;\n        ;\n        ((void)0);\n        ;\n        ((void)0);\n        ;\n        ;\n        ((void)0);\n        ((void)0);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        break;\n    }\n    ;\n    ((void)0);\n    yygoto = yyRuleInfoLhs[yyruleno];\n    yysize = yyRuleInfoNRhs[yyruleno];\n    yyact = yy_find_reduce_action(yymsp[yysize].stateno, (unsigned short)yygoto);\n    ((void)0);\n    ((void)0);\n    yymsp += yysize + 1;\n    yypParser->yytos = yymsp;\n    yymsp->stateno = (unsigned short)yyact;\n    yymsp->major = (unsigned short)yygoto;\n    ;\n    return yyact;\n}\n"
  },
  {
    "id": "sqlite3.c#23281:12#sqlite3_db_status",
    "nobreaks": 1,
    "body": "{\n    int rc = 0;\n    sqlite3_mutex_enter(db->mutex);\n    switch (op) {\n      case 0:\n        {\n            *pCurrent = sqlite3LookasideUsed(db, pHighwater);\n            if (resetFlag) {\n                LookasideSlot *p = db->lookaside.pFree;\n                if (p) {\n                    while (p->pNext)\n                        p = p->pNext;\n                    p->pNext = db->lookaside.pInit;\n                    db->lookaside.pInit = db->lookaside.pFree;\n                    db->lookaside.pFree = 0;\n                }\n                p = db->lookaside.pSmallFree;\n                if (p) {\n                    while (p->pNext)\n                        p = p->pNext;\n                    p->pNext = db->lookaside.pSmallInit;\n                    db->lookaside.pSmallInit = db->lookaside.pSmallFree;\n                    db->lookaside.pSmallFree = 0;\n                }\n            }\n            break;\n        }\n      case 4:\n      case 5:\n      case 6:\n        {\n            ;\n            ;\n            ;\n            ((void)0);\n            ((void)0);\n            *pCurrent = 0;\n            *pHighwater = db->lookaside.anStat[op - 4];\n            if (resetFlag) {\n                db->lookaside.anStat[op - 4] = 0;\n            }\n            break;\n        }\n      case 11:\n      case 1:\n        {\n            int totalUsed = 0;\n            int i;\n            sqlite3BtreeEnterAll(db);\n            for (i = 0; i < db->nDb; i++) {\n                Btree *pBt = db->aDb[i].pBt;\n                if (pBt) {\n                    Pager *pPager = sqlite3BtreePager(pBt);\n                    int nByte = sqlite3PagerMemUsed(pPager);\n                    if (op == 11) {\n                        nByte = nByte / sqlite3BtreeConnectionCount(pBt);\n                    }\n                    totalUsed += nByte;\n                }\n            }\n            sqlite3BtreeLeaveAll(db);\n            *pCurrent = totalUsed;\n            *pHighwater = 0;\n            break;\n        }\n      case 2:\n        {\n            int i;\n            int nByte = 0;\n            sqlite3BtreeEnterAll(db);\n            db->pnBytesFreed = &nByte;\n            ((void)0);\n            db->lookaside.pEnd = db->lookaside.pStart;\n            for (i = 0; i < db->nDb; i++) {\n                Schema *pSchema = db->aDb[i].pSchema;\n                if ((pSchema != 0)) {\n                    HashElem *p;\n                    nByte += sqlite3Config.m.xRoundup(sizeof(HashElem)) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count);\n                    nByte += sqlite3_msize(pSchema->tblHash.ht);\n                    nByte += sqlite3_msize(pSchema->trigHash.ht);\n                    nByte += sqlite3_msize(pSchema->idxHash.ht);\n                    nByte += sqlite3_msize(pSchema->fkeyHash.ht);\n                    for (p = ((&pSchema->trigHash)->first); p; p = ((p)->next)) {\n                        sqlite3DeleteTrigger(db, (Trigger *)((p)->data));\n                    }\n                    for (p = ((&pSchema->tblHash)->first); p; p = ((p)->next)) {\n                        sqlite3DeleteTable(db, (Table *)((p)->data));\n                    }\n                }\n            }\n            db->pnBytesFreed = 0;\n            db->lookaside.pEnd = db->lookaside.pTrueEnd;\n            sqlite3BtreeLeaveAll(db);\n            *pHighwater = 0;\n            *pCurrent = nByte;\n            break;\n        }\n      case 3:\n        {\n            struct Vdbe *pVdbe;\n            int nByte = 0;\n            db->pnBytesFreed = &nByte;\n            ((void)0);\n            db->lookaside.pEnd = db->lookaside.pStart;\n            for (pVdbe = db->pVdbe; pVdbe; pVdbe = pVdbe->pVNext) {\n                sqlite3VdbeDelete(pVdbe);\n            }\n            db->lookaside.pEnd = db->lookaside.pTrueEnd;\n            db->pnBytesFreed = 0;\n            *pHighwater = 0;\n            *pCurrent = nByte;\n            break;\n        }\n      case 12:\n        op = 9 + 1;\n      case 7:\n      case 8:\n      case 9:\n        {\n            int i;\n            int nRet = 0;\n            ((void)0);\n            ((void)0);\n            for (i = 0; i < db->nDb; i++) {\n                if (db->aDb[i].pBt) {\n                    Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);\n                    sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);\n                }\n            }\n            *pHighwater = 0;\n            *pCurrent = nRet;\n            break;\n        }\n      case 10:\n        {\n            *pHighwater = 0;\n            *pCurrent = db->nDeferredImmCons > 0 || db->nDeferredCons > 0;\n            break;\n        }\n      default:\n        {\n            rc = 1;\n        }\n    }\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#30134:12#sqlite3_str_vappendf",
    "nobreaks": 1,
    "body": "{\n    int c;\n    char *bufpt;\n    int precision;\n    int length;\n    int idx;\n    int width;\n    etByte flag_leftjustify;\n    etByte flag_prefix;\n    etByte flag_alternateform;\n    etByte flag_altform2;\n    etByte flag_zeropad;\n    etByte flag_long;\n    etByte done;\n    etByte cThousand;\n    etByte xtype = 17;\n    u8 bArgList;\n    char prefix;\n    sqlite_uint64 longvalue;\n    long double realvalue;\n    const et_info *infop;\n    char *zOut;\n    int nOut;\n    char *zExtra = 0;\n    int exp, e2;\n    int nsd;\n    double rounder;\n    etByte flag_dp;\n    etByte flag_rtz;\n    PrintfArguments *pArgList = 0;\n    char buf[70];\n    ((void)0);\n    bufpt = 0;\n    if ((pAccum->printfFlags & 2) != 0) {\n        pArgList = __builtin_va_arg(ap, PrintfArguments *);\n        bArgList = 1;\n    } else {\n        bArgList = 0;\n    }\n    for (; (c = (*fmt)) != 0; ++fmt) {\n        if (c != '%') {\n            bufpt = (char *)fmt;\n            do {\n                fmt++;\n            } while (*fmt && *fmt != '%');\n            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n            if (*fmt == 0)\n                break;\n        }\n        if ((c = (*++fmt)) == 0) {\n            sqlite3_str_append(pAccum, \"%\", 1);\n            break;\n        }\n        flag_leftjustify = flag_prefix = cThousand = flag_alternateform = flag_altform2 = flag_zeropad = 0;\n        done = 0;\n        width = 0;\n        flag_long = 0;\n        precision = -1;\n        do {\n            switch (c) {\n              case '-':\n                flag_leftjustify = 1;\n                break;\n              case '+':\n                flag_prefix = '+';\n                break;\n              case ' ':\n                flag_prefix = ' ';\n                break;\n              case '#':\n                flag_alternateform = 1;\n                break;\n              case '!':\n                flag_altform2 = 1;\n                break;\n              case '0':\n                flag_zeropad = 1;\n                break;\n              case ',':\n                cThousand = ',';\n                break;\n              default:\n                done = 1;\n                break;\n              case 'l':\n                {\n                    flag_long = 1;\n                    c = *++fmt;\n                    if (c == 'l') {\n                        c = *++fmt;\n                        flag_long = 2;\n                    }\n                    done = 1;\n                    break;\n                }\n              case '1':\n              case '2':\n              case '3':\n              case '4':\n              case '5':\n              case '6':\n              case '7':\n              case '8':\n              case '9':\n                {\n                    unsigned int wx = c - '0';\n                    while ((c = *++fmt) >= '0' && c <= '9')\n                        {\n                            wx = wx * 10 + c - '0';\n                        }\n                    ;\n                    width = wx & 2147483647;\n                    if (c != '.' && c != 'l') {\n                        done = 1;\n                    } else {\n                        fmt--;\n                    }\n                    break;\n                }\n              case '*':\n                {\n                    if (bArgList) {\n                        width = (int)getIntArg(pArgList);\n                    } else {\n                        width = __builtin_va_arg(ap, int);\n                    }\n                    if (width < 0) {\n                        flag_leftjustify = 1;\n                        width = width >= -2147483647 ? -width : 0;\n                    }\n                    if ((c = fmt[1]) != '.' && c != 'l') {\n                        c = *++fmt;\n                        done = 1;\n                    }\n                    break;\n                }\n              case '.':\n                {\n                    c = *++fmt;\n                    if (c == '*') {\n                        if (bArgList) {\n                            precision = (int)getIntArg(pArgList);\n                        } else {\n                            precision = __builtin_va_arg(ap, int);\n                        }\n                        if (precision < 0) {\n                            precision = precision >= -2147483647 ? -precision : -1;\n                        }\n                        c = *++fmt;\n                    } else {\n                        unsigned int px = 0;\n                        while (c >= '0' && c <= '9')\n                            {\n                                px = px * 10 + c - '0';\n                                c = *++fmt;\n                            }\n                        ;\n                        precision = px & 2147483647;\n                    }\n                    if (c == 'l') {\n                        --fmt;\n                    } else {\n                        done = 1;\n                    }\n                    break;\n                }\n            }\n        } while (!done && (c = (*++fmt)) != 0);\n        infop = &fmtinfo[0];\n        xtype = 17;\n        for (idx = 0; idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0]))); idx++) {\n            if (c == fmtinfo[idx].fmttype) {\n                infop = &fmtinfo[idx];\n                xtype = infop->type;\n                break;\n            }\n        }\n        ((void)0);\n        ((void)0);\n        switch (xtype) {\n          case 13:\n            flag_long = sizeof(char *) == sizeof(i64) ? 2 : sizeof(char *) == sizeof(long) ? 1 : 0;\n          case 15:\n          case 0:\n            cThousand = 0;\n          case 16:\n            if (infop->flags & 1) {\n                i64 v;\n                if (bArgList) {\n                    v = getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        v = __builtin_va_arg(ap, i64);\n                    } else {\n                        v = __builtin_va_arg(ap, long);\n                    }\n                } else {\n                    v = __builtin_va_arg(ap, int);\n                }\n                if (v < 0) {\n                    ;\n                    ;\n                    longvalue = ~v;\n                    longvalue++;\n                    prefix = '-';\n                } else {\n                    longvalue = v;\n                    prefix = flag_prefix;\n                }\n            } else {\n                if (bArgList) {\n                    longvalue = (u64)getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        longvalue = __builtin_va_arg(ap, u64);\n                    } else {\n                        longvalue = __builtin_va_arg(ap, unsigned long);\n                    }\n                } else {\n                    longvalue = __builtin_va_arg(ap, unsigned int);\n                }\n                prefix = 0;\n            }\n            if (longvalue == 0)\n                flag_alternateform = 0;\n            if (flag_zeropad && precision < width - (prefix != 0)) {\n                precision = width - (prefix != 0);\n            }\n            if (precision < 70 - 10 - 70 / 3) {\n                nOut = 70;\n                zOut = buf;\n            } else {\n                u64 n;\n                n = (u64)precision + 10;\n                if (cThousand)\n                    n += precision / 3;\n                zOut = zExtra = printfTempBuf(pAccum, n);\n                if (zOut == 0)\n                    return;\n                nOut = (int)n;\n            }\n            bufpt = &zOut[nOut - 1];\n            if (xtype == 15) {\n                static const char zOrd[] = \"thstndrd\";\n                int x = (int)(longvalue % 10);\n                if (x >= 4 || (longvalue / 10) % 10 == 1) {\n                    x = 0;\n                }\n                *(--bufpt) = zOrd[x * 2 + 1];\n                *(--bufpt) = zOrd[x * 2];\n            }\n            {\n                const char *cset = &aDigits[infop->charset];\n                u8 base = infop->base;\n                do {\n                    *(--bufpt) = cset[longvalue % base];\n                    longvalue = longvalue / base;\n                } while (longvalue > 0);\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            while (precision > length)\n                {\n                    *(--bufpt) = '0';\n                    length++;\n                }\n            if (cThousand) {\n                int nn = (length - 1) / 3;\n                int ix = (length - 1) % 3 + 1;\n                bufpt -= nn;\n                for (idx = 0; nn > 0; idx++) {\n                    bufpt[idx] = bufpt[idx + nn];\n                    ix--;\n                    if (ix == 0) {\n                        bufpt[++idx] = cThousand;\n                        nn--;\n                        ix = 3;\n                    }\n                }\n            }\n            if (prefix)\n                *(--bufpt) = prefix;\n            if (flag_alternateform && infop->prefix) {\n                const char *pre;\n                char x;\n                pre = &aPrefix[infop->prefix];\n                for (; (x = (*pre)) != 0; pre++)\n                    *(--bufpt) = x;\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            break;\n          case 1:\n          case 2:\n          case 3:\n            if (bArgList) {\n                realvalue = getDoubleArg(pArgList);\n            } else {\n                realvalue = __builtin_va_arg(ap, double);\n            }\n            if (precision < 0)\n                precision = 6;\n            if (precision > 100000000) {\n                precision = 100000000;\n            }\n            if (realvalue < 0.) {\n                realvalue = -realvalue;\n                prefix = '-';\n            } else {\n                prefix = flag_prefix;\n            }\n            if (xtype == 3 && precision > 0)\n                precision--;\n            ;\n            idx = precision & 4095;\n            rounder = arRound[idx % 10];\n            while (idx >= 10)\n                {\n                    rounder *= 1.0E-10;\n                    idx -= 10;\n                }\n            if (xtype == 1) {\n                double rx = (double)realvalue;\n                sqlite3_uint64 u;\n                int ex;\n                __builtin___memcpy_chk(&u, &rx, sizeof (u), __builtin_object_size(&u, 0));\n                ex = -1023 + (int)((u >> 52) & 2047);\n                if (precision + (ex / 3) < 15)\n                    rounder += realvalue * 2.9999999999999999E-16;\n                realvalue += rounder;\n            }\n            exp = 0;\n            if (sqlite3IsNaN((double)realvalue)) {\n                bufpt = \"NaN\";\n                length = 3;\n                break;\n            }\n            if (realvalue > 0.) {\n                long double scale = 1.;\n                while (realvalue >= 1.0E+100 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+100;\n                        exp += 100;\n                    }\n                while (realvalue >= 1.0E+10 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+10;\n                        exp += 10;\n                    }\n                while (realvalue >= 10. * scale && exp <= 350)\n                    {\n                        scale *= 10.;\n                        exp++;\n                    }\n                realvalue /= scale;\n                while (realvalue < 1.0E-8)\n                    {\n                        realvalue *= 1.0E+8;\n                        exp -= 8;\n                    }\n                while (realvalue < 1.)\n                    {\n                        realvalue *= 10.;\n                        exp--;\n                    }\n                if (exp > 350) {\n                    bufpt = buf;\n                    buf[0] = prefix;\n                    __builtin___memcpy_chk(buf + (prefix != 0), \"Inf\", 4, __builtin_object_size(buf + (prefix != 0), 0));\n                    length = 3 + (prefix != 0);\n                    break;\n                }\n            }\n            bufpt = buf;\n            if (xtype != 1) {\n                realvalue += rounder;\n                if (realvalue >= 10.) {\n                    realvalue *= 0.10000000000000001;\n                    exp++;\n                }\n            }\n            if (xtype == 3) {\n                flag_rtz = !flag_alternateform;\n                if (exp < -4 || exp > precision) {\n                    xtype = 2;\n                } else {\n                    precision = precision - exp;\n                    xtype = 1;\n                }\n            } else {\n                flag_rtz = flag_altform2;\n            }\n            if (xtype == 2) {\n                e2 = 0;\n            } else {\n                e2 = exp;\n            }\n            {\n                i64 szBufNeeded;\n                szBufNeeded = ((e2) > (0) ? (e2) : (0)) + (i64)precision + (i64)width + 15;\n                if (szBufNeeded > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n                    if (bufpt == 0)\n                        return;\n                }\n            }\n            zOut = bufpt;\n            nsd = 16 + flag_altform2 * 10;\n            flag_dp = (precision > 0 ? 1 : 0) | flag_alternateform | flag_altform2;\n            if (prefix) {\n                *(bufpt++) = prefix;\n            }\n            if (e2 < 0) {\n                *(bufpt++) = '0';\n            } else {\n                for (; e2 >= 0; e2--) {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            }\n            if (flag_dp) {\n                *(bufpt++) = '.';\n            }\n            for (e2++; e2 < 0; precision-- , e2++) {\n                ((void)0);\n                *(bufpt++) = '0';\n            }\n            while ((precision--) > 0)\n                {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            if (flag_rtz && flag_dp) {\n                while (bufpt[-1] == '0')\n                    *(--bufpt) = 0;\n                ((void)0);\n                if (bufpt[-1] == '.') {\n                    if (flag_altform2) {\n                        *(bufpt++) = '0';\n                    } else {\n                        *(--bufpt) = 0;\n                    }\n                }\n            }\n            if (xtype == 2) {\n                *(bufpt++) = aDigits[infop->charset];\n                if (exp < 0) {\n                    *(bufpt++) = '-';\n                    exp = -exp;\n                } else {\n                    *(bufpt++) = '+';\n                }\n                if (exp >= 100) {\n                    *(bufpt++) = (char)((exp / 100) + '0');\n                    exp %= 100;\n                }\n                *(bufpt++) = (char)(exp / 10 + '0');\n                *(bufpt++) = (char)(exp % 10 + '0');\n            }\n            *bufpt = 0;\n            length = (int)(bufpt - zOut);\n            bufpt = zOut;\n            if (flag_zeropad && !flag_leftjustify && length < width) {\n                int i;\n                int nPad = width - length;\n                for (i = width; i >= nPad; i--) {\n                    bufpt[i] = bufpt[i - nPad];\n                }\n                i = prefix != 0;\n                while (nPad--)\n                    bufpt[i++] = '0';\n                length = width;\n            }\n            break;\n          case 4:\n            if (!bArgList) {\n                *(__builtin_va_arg(ap, int *)) = pAccum->nChar;\n            }\n            length = width = 0;\n            break;\n          case 7:\n            buf[0] = '%';\n            bufpt = buf;\n            length = 1;\n            break;\n          case 8:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                length = 1;\n                if (bufpt) {\n                    buf[0] = c = *(bufpt++);\n                    if ((c & 192) == 192) {\n                        while (length < 4 && (bufpt[0] & 192) == 128)\n                            {\n                                buf[length++] = *(bufpt++);\n                            }\n                    }\n                } else {\n                    buf[0] = 0;\n                }\n            } else {\n                unsigned int ch = __builtin_va_arg(ap, unsigned int);\n                if (ch < 128) {\n                    buf[0] = ch & 255;\n                    length = 1;\n                } else if (ch < 2048) {\n                    buf[0] = 192 + (u8)((ch >> 6) & 31);\n                    buf[1] = 128 + (u8)(ch & 63);\n                    length = 2;\n                } else if (ch < 65536) {\n                    buf[0] = 224 + (u8)((ch >> 12) & 15);\n                    buf[1] = 128 + (u8)((ch >> 6) & 63);\n                    buf[2] = 128 + (u8)(ch & 63);\n                    length = 3;\n                } else {\n                    buf[0] = 240 + (u8)((ch >> 18) & 7);\n                    buf[1] = 128 + (u8)((ch >> 12) & 63);\n                    buf[2] = 128 + (u8)((ch >> 6) & 63);\n                    buf[3] = 128 + (u8)(ch & 63);\n                    length = 4;\n                }\n            }\n            if (precision > 1) {\n                i64 nPrior = 1;\n                width -= precision - 1;\n                if (width > 1 && !flag_leftjustify) {\n                    sqlite3_str_appendchar(pAccum, width - 1, ' ');\n                    width = 0;\n                }\n                sqlite3_str_append(pAccum, buf, length);\n                precision--;\n                while (precision > 1)\n                    {\n                        i64 nCopyBytes;\n                        if (nPrior > precision - 1)\n                            nPrior = precision - 1;\n                        nCopyBytes = length * nPrior;\n                        if (nCopyBytes + pAccum->nChar >= pAccum->nAlloc) {\n                            sqlite3StrAccumEnlarge(pAccum, nCopyBytes);\n                        }\n                        if (pAccum->accError)\n                            break;\n                        sqlite3_str_append(pAccum, &pAccum->zText[pAccum->nChar - nCopyBytes], nCopyBytes);\n                        precision -= nPrior;\n                        nPrior *= 2;\n                    }\n            }\n            bufpt = buf;\n            flag_altform2 = 1;\n            goto adjust_width_for_utf8;\n          case 5:\n          case 6:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                xtype = 5;\n            } else {\n                bufpt = __builtin_va_arg(ap, char *);\n            }\n            if (bufpt == 0) {\n                bufpt = \"\";\n            } else if (xtype == 6) {\n                if (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0) {\n                    ((void)0);\n                    pAccum->zText = bufpt;\n                    pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n                    pAccum->nChar = 2147483647 & (int)strlen(bufpt);\n                    pAccum->printfFlags |= 4;\n                    length = 0;\n                    break;\n                }\n                zExtra = bufpt;\n            }\n            if (precision >= 0) {\n                if (flag_altform2) {\n                    unsigned char *z = (unsigned char *)bufpt;\n                    while (precision-- > 0 && z[0])\n                        {\n                            {\n                                if ((*(z++)) >= 192) {\n                                    while ((*z & 192) == 128)\n                                        {\n                                            z++;\n                                        }\n                                }\n                            }\n                            ;\n                        }\n                    length = (int)(z - (unsigned char *)bufpt);\n                } else {\n                    for (length = 0; length < precision && bufpt[length]; length++) {\n                    }\n                }\n            } else {\n                length = 2147483647 & (int)strlen(bufpt);\n            }\n          adjust_width_for_utf8:\n            if (flag_altform2 && width > 0) {\n                int ii = length - 1;\n                while (ii >= 0)\n                    if ((bufpt[ii--] & 192) == 128)\n                        width++;\n            }\n            break;\n          case 9:\n          case 10:\n          case 14:\n            {\n                i64 i, j, k, n;\n                int needQuote, isnull;\n                char ch;\n                char q = ((xtype == 14) ? '\"' : '\\'');\n                char *escarg;\n                if (bArgList) {\n                    escarg = getTextArg(pArgList);\n                } else {\n                    escarg = __builtin_va_arg(ap, char *);\n                }\n                isnull = escarg == 0;\n                if (isnull)\n                    escarg = (xtype == 10 ? \"NULL\" : \"(NULL)\");\n                k = precision;\n                for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++ , k--) {\n                    if (ch == q)\n                        n++;\n                    if (flag_altform2 && (ch & 192) == 192) {\n                        while ((escarg[i + 1] & 192) == 128)\n                            {\n                                i++;\n                            }\n                    }\n                }\n                needQuote = !isnull && xtype == 10;\n                n += i + 3;\n                if (n > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, n);\n                    if (bufpt == 0)\n                        return;\n                } else {\n                    bufpt = buf;\n                }\n                j = 0;\n                if (needQuote)\n                    bufpt[j++] = q;\n                k = i;\n                for (i = 0; i < k; i++) {\n                    bufpt[j++] = ch = escarg[i];\n                    if (ch == q)\n                        bufpt[j++] = ch;\n                }\n                if (needQuote)\n                    bufpt[j++] = q;\n                bufpt[j] = 0;\n                length = j;\n                goto adjust_width_for_utf8;\n            }\n          case 11:\n            {\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                if (flag_alternateform) {\n                    Expr *pExpr = __builtin_va_arg(ap, Expr *);\n                    if ((pExpr) && (!(((pExpr)->flags & (2048)) != 0))) {\n                        sqlite3_str_appendall(pAccum, (const char *)pExpr->u.zToken);\n                        sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n                    }\n                } else {\n                    Token *pToken = __builtin_va_arg(ap, Token *);\n                    ((void)0);\n                    if (pToken && pToken->n) {\n                        sqlite3_str_append(pAccum, (const char *)pToken->z, pToken->n);\n                        sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          case 12:\n            {\n                SrcItem *pItem;\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                pItem = __builtin_va_arg(ap, SrcItem *);\n                ((void)0);\n                if (pItem->zAlias && !flag_altform2) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else if (pItem->zName) {\n                    if (pItem->zDatabase) {\n                        sqlite3_str_appendall(pAccum, pItem->zDatabase);\n                        sqlite3_str_append(pAccum, \".\", 1);\n                    }\n                    sqlite3_str_appendall(pAccum, pItem->zName);\n                } else if (pItem->zAlias) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else {\n                    Select *pSel = pItem->pSelect;\n                    ((void)0);\n                    if (pSel->selFlags & 2048) {\n                        sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n                    } else {\n                        sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          default:\n            {\n                ((void)0);\n                return;\n            }\n        }\n        width -= length;\n        if (width > 0) {\n            if (!flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n            sqlite3_str_append(pAccum, bufpt, length);\n            if (flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n        } else {\n            sqlite3_str_append(pAccum, bufpt, length);\n        }\n        if (zExtra) {\n            sqlite3DbFree(pAccum->db, zExtra);\n            zExtra = 0;\n        }\n    }\n}\n"
  },
  {
    "id": "sqlite3.c#164146:1#selectWindowRewriteExprCb",
    "nobreaks": 1,
    "body": "{\n    struct WindowRewrite *p = pWalker->u.pRewrite;\n    Parse *pParse = pWalker->pParse;\n    ((void)0);\n    ((void)0);\n    if (p->pSubSelect) {\n        if (pExpr->op != 167) {\n            return 0;\n        } else {\n            int nSrc = p->pSrc->nSrc;\n            int i;\n            for (i = 0; i < nSrc; i++) {\n                if (pExpr->iTable == p->pSrc->a[i].iCursor)\n                    break;\n            }\n            if (i == nSrc)\n                return 0;\n        }\n    }\n    switch (pExpr->op) {\n      case 172:\n        if (!(((pExpr)->flags & (16777216)) != 0)) {\n            break;\n        } else {\n            Window *pWin;\n            for (pWin = p->pWin; pWin; pWin = pWin->pNextWin) {\n                if (pExpr->y.pWin == pWin) {\n                    ((void)0);\n                    return 1;\n                }\n            }\n        }\n      case 168:\n      case 167:\n        {\n            int iCol = -1;\n            if (pParse->db->mallocFailed)\n                return 2;\n            if (p->pSub) {\n                int i;\n                for (i = 0; i < p->pSub->nExpr; i++) {\n                    if (0 == sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1)) {\n                        iCol = i;\n                        break;\n                    }\n                }\n            }\n            if (iCol < 0) {\n                Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);\n                if (pDup && pDup->op == 168)\n                    pDup->op = 172;\n                p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);\n            }\n            if (p->pSub) {\n                int f = pExpr->flags & 512;\n                ((void)0);\n                (pExpr)->flags |= (134217728);\n                sqlite3ExprDelete(pParse->db, pExpr);\n                (pExpr)->flags &= ~(134217728);\n                __builtin___memset_chk(pExpr, 0, sizeof(Expr), __builtin_object_size(pExpr, 0));\n                pExpr->op = 167;\n                pExpr->iColumn = (iCol < 0 ? p->pSub->nExpr - 1 : iCol);\n                pExpr->iTable = p->pWin->iEphCsr;\n                pExpr->y.pTab = p->pTab;\n                pExpr->flags = f;\n            }\n            if (pParse->db->mallocFailed)\n                return 2;\n            break;\n        }\n      default:\n        break;\n    }\n    return 0;\n}\n"
  },
  {
    "id": "sqlite3.c#51577:1#memdbLock",
    "nobreaks": 1,
    "body": "{\n    MemFile *pThis = (MemFile *)pFile;\n    MemStore *p = pThis->pStore;\n    int rc = 0;\n    if (eLock <= pThis->eLock)\n        return 0;\n    memdbEnter(p);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    if (eLock > 1 && (p->mFlags & 4)) {\n        rc = 8;\n    } else {\n        switch (eLock) {\n          case 1:\n            {\n                ((void)0);\n                if (p->nWrLock > 0) {\n                    rc = 5;\n                } else {\n                    p->nRdLock++;\n                }\n                break;\n            }\n            ;\n          case 2:\n          case 3:\n            {\n                ((void)0);\n                if ((pThis->eLock == 1)) {\n                    if (p->nWrLock > 0) {\n                        rc = 5;\n                    } else {\n                        p->nWrLock = 1;\n                    }\n                }\n                break;\n            }\n          default:\n            {\n                ((void)0);\n                ((void)0);\n                if (p->nRdLock > 1) {\n                    rc = 5;\n                } else if (pThis->eLock == 1) {\n                    p->nWrLock = 1;\n                }\n                break;\n            }\n        }\n    }\n    if (rc == 0)\n        pThis->eLock = eLock;\n    memdbLeave(p);\n    return rc;\n}\n"
  },
  {
    "id": "sqlite3.c#198857:1#jsonRenderNode",
    "nobreaks": 1,
    "body": "{\n    ((void)0);\n    if (pNode->jnFlags & (8 | 16)) {\n        if ((pNode->jnFlags & 8) != 0 && (aReplace != 0)) {\n            ((void)0);\n            jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);\n            return;\n        }\n        ((void)0);\n        pNode = pNode->u.pPatch;\n    }\n    switch (pNode->eType) {\n      default:\n        {\n            ((void)0);\n            jsonAppendRaw(pOut, \"null\", 4);\n            break;\n        }\n      case 1:\n        {\n            jsonAppendRaw(pOut, \"true\", 4);\n            break;\n        }\n      case 2:\n        {\n            jsonAppendRaw(pOut, \"false\", 5);\n            break;\n        }\n      case 5:\n        {\n            if (pNode->jnFlags & 1) {\n                ((void)0);\n                jsonAppendString(pOut, pNode->u.zJContent, pNode->n);\n                break;\n            }\n        }\n      case 4:\n      case 3:\n        {\n            ((void)0);\n            jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);\n            break;\n        }\n      case 6:\n        {\n            u32 j = 1;\n            jsonAppendChar(pOut, '[');\n            for (;;) {\n                while (j <= pNode->n)\n                    {\n                        if ((pNode[j].jnFlags & 4) == 0) {\n                            jsonAppendSeparator(pOut);\n                            jsonRenderNode(&pNode[j], pOut, aReplace);\n                        }\n                        j += jsonNodeSize(&pNode[j]);\n                    }\n                if ((pNode->jnFlags & 32) == 0)\n                    break;\n                ((void)0);\n                pNode = &pNode[pNode->u.iAppend];\n                j = 1;\n            }\n            jsonAppendChar(pOut, ']');\n            break;\n        }\n      case 7:\n        {\n            u32 j = 1;\n            jsonAppendChar(pOut, '{');\n            for (;;) {\n                while (j <= pNode->n)\n                    {\n                        if ((pNode[j + 1].jnFlags & 4) == 0) {\n                            jsonAppendSeparator(pOut);\n                            jsonRenderNode(&pNode[j], pOut, aReplace);\n                            jsonAppendChar(pOut, ':');\n                            jsonRenderNode(&pNode[j + 1], pOut, aReplace);\n                        }\n                        j += 1 + jsonNodeSize(&pNode[j + 1]);\n                    }\n                if ((pNode->jnFlags & 32) == 0)\n                    break;\n                ((void)0);\n                pNode = &pNode[pNode->u.iAppend];\n                j = 1;\n            }\n            jsonAppendChar(pOut, '}');\n            break;\n        }\n    }\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfFalse",
    "nobreaks": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    ((void)0);\n    if ((v == 0))\n        return;\n    if (pExpr == 0)\n        return;\n    ((void)0);\n    op = ((pExpr->op + (50 & 1)) ^ 1) - (50 & 1);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    ((void)0);\n    switch (pExpr->op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n            } else if (pExpr->op == 44) {\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n            } else {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            } else {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (pExpr->op == 45) ? 52 : 53;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ((void)0);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            if (jumpIfNull) {\n                sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n            } else {\n                int destIfNull = sqlite3VdbeMakeLabel(pParse);\n                sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n                sqlite3VdbeResolveLabel(v, destIfNull);\n            }\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "sqlite3.c#107875:1#exprNodeIsConstant",
    "nobreaks": 1,
    "body": "{\n    if (pWalker->eCode == 2 && (((pExpr)->flags & (1)) != 0)) {\n        pWalker->eCode = 0;\n        return 2;\n    }\n    switch (pExpr->op) {\n      case 172:\n        if ((pWalker->eCode >= 4 || (((pExpr)->flags & (1048576)) != 0)) && !(((pExpr)->flags & (16777216)) != 0)) {\n            if (pWalker->eCode == 5)\n                (pExpr)->flags |= (1073741824);\n            return 0;\n        } else {\n            pWalker->eCode = 0;\n            return 2;\n        }\n      case 59:\n        if (sqlite3ExprIdToTrueFalse(pExpr)) {\n            return 1;\n        }\n      case 167:\n      case 168:\n      case 169:\n        ;\n        ;\n        ;\n        ;\n        if ((((pExpr)->flags & (32)) != 0) && pWalker->eCode != 2) {\n            return 0;\n        }\n        if (pWalker->eCode == 3 && pExpr->iTable == pWalker->u.iCur) {\n            return 0;\n        }\n      case 179:\n      case 176:\n      case 141:\n        ;\n        ;\n        ;\n        pWalker->eCode = 0;\n        return 2;\n      case 156:\n        if (pWalker->eCode == 5) {\n            pExpr->op = 121;\n        } else if (pWalker->eCode == 4) {\n            pWalker->eCode = 0;\n            return 2;\n        }\n      default:\n        ;\n        ;\n        return 0;\n    }\n}\n"
  }
]
[
  {
    "id": "shell.c#26308:1#quickscan",
    "nobreaks": 2,
    "body": "{\n    char cin;\n    char cWait = (char)qss;\n    if (cWait == 0) {\n      PlainScan:\n        ((void)0);\n        while ((cin = *zLine++) != 0)\n            {\n                if (isspace((unsigned char)cin))\n                    continue;\n                switch (cin) {\n                  case '-':\n                    if (*zLine != '-')\n                        break;\n                    while ((cin = *++zLine) != 0)\n                        if (cin == '\\n')\n                            goto PlainScan;\n                    return qss;\n                  case ';':\n                    qss |= QSS_EndingSemi;\n                    continue;\n                  case '/':\n                    if (*zLine == '*') {\n                        ++zLine;\n                        cWait = '*';\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, \"/*\", 0);\n                        qss = ((cWait) | ((qss) & QSS_ScanMask));\n                        goto TermScan;\n                    }\n                    break;\n                  case '[':\n                    cin = ']';\n                    ;\n                  case '`':\n                  case '\\'':\n                  case '\"':\n                    cWait = cin;\n                    qss = QSS_HasDark | cWait;\n                    if (pst && stdin_is_interactive)\n                        setLexemeOpen(pst, 0, cin);\n                    goto TermScan;\n                  case '(':\n                    if (pst && stdin_is_interactive)\n                        (trackParenLevel(pst, 1));\n                    break;\n                  case ')':\n                    if (pst && stdin_is_interactive)\n                        (trackParenLevel(pst, -1));\n                    break;\n                  default:\n                    break;\n                }\n                qss = (qss & ~QSS_EndingSemi) | QSS_HasDark;\n            }\n    } else {\n      TermScan:\n        while ((cin = *zLine++) != 0)\n            {\n                if (cin == cWait) {\n                    switch (cWait) {\n                      case '*':\n                        if (*zLine != '/')\n                            continue;\n                        ++zLine;\n                        cWait = 0;\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, 0, 0);\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      case '`':\n                      case '\\'':\n                      case '\"':\n                        if (*zLine == cWait) {\n                            ++zLine;\n                            continue;\n                        }\n                        ;\n                      case ']':\n                        cWait = 0;\n                        if (pst && stdin_is_interactive)\n                            setLexemeOpen(pst, 0, 0);\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      default:\n                        ((void)0);\n                    }\n                }\n            }\n    }\n    return qss;\n}\n"
  },
  {
    "id": "shell.c#4801:1#sqlite3re_match",
    "nobreaks": 1,
    "body": "{\n    ReStateSet aStateSet[2], *pThis, *pNext;\n    ReStateNumber aSpace[100];\n    ReStateNumber *pToFree;\n    unsigned int i = 0;\n    unsigned int iSwap = 0;\n    int c = 268435455;\n    int cPrev = 0;\n    int rc = 0;\n    ReInput in;\n    in.z = zIn;\n    in.i = 0;\n    in.mx = nIn >= 0 ? nIn : (int)strlen((const char *)zIn);\n    if (pRe->nInit) {\n        unsigned char x = pRe->zInit[0];\n        while (in.i + pRe->nInit <= in.mx && (zIn[in.i] != x || strncmp((const char *)zIn + in.i, (const char *)pRe->zInit, pRe->nInit) != 0))\n            {\n                in.i++;\n            }\n        if (in.i + pRe->nInit > in.mx)\n            return 0;\n        c = 268435455 - 1;\n    }\n    if (pRe->nState <= (sizeof (aSpace) / (sizeof (aSpace[0]) * 2))) {\n        pToFree = 0;\n        aStateSet[0].aState = aSpace;\n    } else {\n        pToFree = sqlite3_malloc64(sizeof(ReStateNumber) * 2 * pRe->nState);\n        if (pToFree == 0)\n            return -1;\n        aStateSet[0].aState = pToFree;\n    }\n    aStateSet[1].aState = &aStateSet[0].aState[pRe->nState];\n    pNext = &aStateSet[1];\n    pNext->nState = 0;\n    re_add_state(pNext, 0);\n    while (c != 0 && pNext->nState > 0)\n        {\n            cPrev = c;\n            c = pRe->xNextChar(&in);\n            pThis = pNext;\n            pNext = &aStateSet[iSwap];\n            iSwap = 1 - iSwap;\n            pNext->nState = 0;\n            for (i = 0; i < pThis->nState; i++) {\n                int x = pThis->aState[i];\n                switch (pRe->aOp[x]) {\n                  case 1:\n                    {\n                        if (pRe->aArg[x] == c)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 18:\n                    {\n                        if (cPrev == 268435455)\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 2:\n                    {\n                        if (c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 11:\n                    {\n                        if (re_word_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 12:\n                    {\n                        if (!re_word_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 13:\n                    {\n                        if (re_digit_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 14:\n                    {\n                        if (!re_digit_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 15:\n                    {\n                        if (re_space_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 16:\n                    {\n                        if (!re_space_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 17:\n                    {\n                        if (re_word_char(c) != re_word_char(cPrev))\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 3:\n                    {\n                        re_add_state(pNext, x);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 4:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 5:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        break;\n                    }\n                  case 6:\n                    {\n                        rc = 1;\n                        goto re_match_end;\n                    }\n                  case 8:\n                    {\n                        if (c == 0)\n                            break;\n                        goto re_op_cc_inc;\n                    }\n                  case 7:\n                  re_op_cc_inc:\n                    {\n                        int j = 1;\n                        int n = pRe->aArg[x];\n                        int hit = 0;\n                        for (j = 1; j > 0 && j < n; j++) {\n                            if (pRe->aOp[x + j] == 9) {\n                                if (pRe->aArg[x + j] == c) {\n                                    hit = 1;\n                                    j = -1;\n                                }\n                            } else {\n                                if (pRe->aArg[x + j] <= c && pRe->aArg[x + j + 1] >= c) {\n                                    hit = 1;\n                                    j = -1;\n                                } else {\n                                    j++;\n                                }\n                            }\n                        }\n                        if (pRe->aOp[x] == 8)\n                            hit = !hit;\n                        if (hit)\n                            re_add_state(pNext, x + n);\n                        break;\n                    }\n                }\n            }\n        }\n    for (i = 0; i < pNext->nState; i++) {\n        int x = pNext->aState[i];\n        while (pRe->aOp[x] == 5)\n            x += pRe->aArg[x];\n        if (pRe->aOp[x] == 6) {\n            rc = 1;\n            break;\n        }\n    }\n  re_match_end:\n    sqlite3_free(pToFree);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#8710:1#zipfileColumn",
    "nobreaks": 1,
    "body": "{\n    ZipfileCsr *pCsr = (ZipfileCsr *)cur;\n    ZipfileCDS *pCDS = &pCsr->pCurrent->cds;\n    int rc = 0;\n    switch (i) {\n      case 0:\n        sqlite3_result_text(ctx, pCDS->zFile, -1, ((sqlite3_destructor_type)-1));\n        break;\n      case 1:\n        sqlite3_result_int(ctx, pCDS->iExternalAttr >> 16);\n        break;\n      case 2:\n        {\n            sqlite3_result_int64(ctx, pCsr->pCurrent->mUnixTime);\n            break;\n        }\n      case 3:\n        {\n            if (sqlite3_vtab_nochange(ctx) == 0) {\n                sqlite3_result_int64(ctx, pCDS->szUncompressed);\n            }\n            break;\n        }\n      case 4:\n        if (sqlite3_vtab_nochange(ctx))\n            break;\n      case 5:\n        {\n            if (i == 4 || pCDS->iCompression == 0 || pCDS->iCompression == 8) {\n                int sz = pCDS->szCompressed;\n                int szFinal = pCDS->szUncompressed;\n                if (szFinal > 0) {\n                    u8 *aBuf;\n                    u8 *aFree = 0;\n                    if (pCsr->pCurrent->aData) {\n                        aBuf = pCsr->pCurrent->aData;\n                    } else {\n                        aBuf = aFree = sqlite3_malloc64(sz);\n                        if (aBuf == 0) {\n                            rc = 7;\n                        } else {\n                            FILE *pFile = pCsr->pFile;\n                            if (pFile == 0) {\n                                pFile = ((ZipfileTab *)(pCsr->base.pVtab))->pWriteFd;\n                            }\n                            rc = zipfileReadData(pFile, aBuf, sz, pCsr->pCurrent->iDataOff, &pCsr->base.pVtab->zErrMsg);\n                        }\n                    }\n                    if (rc == 0) {\n                        if (i == 5 && pCDS->iCompression) {\n                            zipfileInflate(ctx, aBuf, sz, szFinal);\n                        } else {\n                            sqlite3_result_blob(ctx, aBuf, sz, ((sqlite3_destructor_type)-1));\n                        }\n                    }\n                    sqlite3_free(aFree);\n                } else {\n                    u32 mode = pCDS->iExternalAttr >> 16;\n                    if (!(mode & 16384) && pCDS->zFile[pCDS->nFile - 1] != '/') {\n                        sqlite3_result_blob(ctx, \"\", 0, ((sqlite3_destructor_type)0));\n                    }\n                }\n            }\n            break;\n        }\n      case 6:\n        sqlite3_result_int(ctx, pCDS->iCompression);\n        break;\n      default:\n        ((void)0);\n        sqlite3_result_int64(ctx, pCsr->iId);\n        break;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#21986:1#arProcessSwitch",
    "nobreaks": 1,
    "body": "{\n    switch (eSwitch) {\n      case 1:\n      case 4:\n      case 5:\n      case 7:\n      case 2:\n      case 3:\n      case 6:\n        if (pAr->eCmd) {\n            return arErrorMsg(pAr, \"multiple command options\");\n        }\n        pAr->eCmd = eSwitch;\n        break;\n      case 12:\n        pAr->bDryRun = 1;\n        break;\n      case 13:\n        pAr->bGlob = 1;\n        break;\n      case 8:\n        pAr->bVerbose = 1;\n        break;\n      case 11:\n        pAr->bAppend = 1;\n        ;\n      case 9:\n        pAr->zFile = zArg;\n        break;\n      case 10:\n        pAr->zDir = zArg;\n        break;\n    }\n    return 0;\n}\n"
  },
  {
    "id": "shell.c#6213:1#fsdirColumn",
    "nobreaks": 1,
    "body": "{\n    fsdir_cursor *pCur = (fsdir_cursor *)cur;\n    switch (i) {\n      case 0:\n        {\n            sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, ((sqlite3_destructor_type)-1));\n            break;\n        }\n      case 1:\n        sqlite3_result_int64(ctx, pCur->sStat.st_mode);\n        break;\n      case 2:\n        sqlite3_result_int64(ctx, pCur->sStat.st_mtimespec.tv_sec);\n        break;\n      case 3:\n        {\n            mode_t m = pCur->sStat.st_mode;\n            if ((((m) & 61440) == 16384)) {\n                sqlite3_result_null(ctx);\n            } else if ((((m) & 61440) == 40960)) {\n                char aStatic[64];\n                char *aBuf = aStatic;\n                sqlite3_int64 nBuf = 64;\n                int n;\n                while (1)\n                    {\n                        n = readlink(pCur->zPath, aBuf, nBuf);\n                        if (n < nBuf)\n                            break;\n                        if (aBuf != aStatic)\n                            sqlite3_free(aBuf);\n                        nBuf = nBuf * 2;\n                        aBuf = sqlite3_malloc64(nBuf);\n                        if (aBuf == 0) {\n                            sqlite3_result_error_nomem(ctx);\n                            return 7;\n                        }\n                    }\n                sqlite3_result_text(ctx, aBuf, n, ((sqlite3_destructor_type)-1));\n                if (aBuf != aStatic)\n                    sqlite3_free(aBuf);\n            } else {\n                readFileContents(ctx, pCur->zPath);\n            }\n        }\n      case 4:\n      default:\n        {\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "id": "shell.c#3590:1#fromBase85",
    "nobreaks": 1,
    "body": "{\n    if (ncIn > 0 && pIn[ncIn - 1] == '\\n')\n        --ncIn;\n    while (ncIn > 0)\n        {\n            static signed char nboi[] = {0, 0, 1, 2, 3, 4};\n            char *pUse = skipNonB85(pIn);\n            unsigned long qv = 0L;\n            int nti, nbo;\n            ncIn -= (pUse - pIn);\n            pIn = pUse;\n            nti = (ncIn > 5) ? 5 : ncIn;\n            nbo = nboi[nti];\n            if (nbo == 0)\n                break;\n            while (nti > 0)\n                {\n                    char c = *pIn++;\n                    u8 cdo = b85_cOffset[(((c) >= '#') + ((c) > '&') + ((c) >= '*') + ((c) > 'z'))];\n                    --ncIn;\n                    if (cdo == 0)\n                        break;\n                    qv = 85 * qv + (c - cdo);\n                    --nti;\n                }\n            nbo -= nti;\n            switch (nbo) {\n              case 4:\n                *pOut++ = (qv >> 24) & 255;\n              case 3:\n                *pOut++ = (qv >> 16) & 255;\n              case 2:\n                *pOut++ = (qv >> 8) & 255;\n              case 1:\n                *pOut++ = qv & 255;\n              case 0:\n                break;\n            }\n        }\n    return pOut;\n}\n"
  },
  {
    "id": "shell.c#3254:1#fromBase64",
    "nobreaks": 2,
    "body": "{\n    if (ncIn > 0 && pIn[ncIn - 1] == '\\n')\n        --ncIn;\n    while (ncIn > 0 && *pIn != '=')\n        {\n            static signed char nboi[] = {0, 0, 1, 2, 3};\n            char *pUse = skipNonB64(pIn);\n            unsigned long qv = 0L;\n            int nti, nbo, nac;\n            ncIn -= (pUse - pIn);\n            pIn = pUse;\n            nti = (ncIn > 4) ? 4 : ncIn;\n            ncIn -= nti;\n            nbo = nboi[nti];\n            if (nbo == 0)\n                break;\n            for (nac = 0; nac < 4; ++nac) {\n                char c = (nac < nti) ? *pIn++ : b64Numerals[0];\n                u8 bdp = ((((u8)(c)) < 128) ? (u8)(b64DigitValues[(u8)(c)]) : 128);\n                switch (bdp) {\n                  case 130:\n                    ncIn = 0;\n                    ;\n                  case 129:\n                    nti = nac;\n                    ;\n                  case 128:\n                    bdp = 0;\n                    --nbo;\n                    ;\n                  default:\n                    qv = qv << 6 | bdp;\n                    break;\n                }\n            }\n            switch (nbo) {\n              case 3:\n                pOut[2] = (qv) & 255;\n              case 2:\n                pOut[1] = (qv >> 8) & 255;\n              case 1:\n                pOut[0] = (qv >> 16) & 255;\n            }\n            pOut += nbo;\n        }\n    return pOut;\n}\n"
  },
  {
    "id": "shell.c#9222:1#zipfileUpdate",
    "nobreaks": 1,
    "body": "{\n    ZipfileTab *pTab = (ZipfileTab *)pVtab;\n    int rc = 0;\n    ZipfileEntry *pNew = 0;\n    u32 mode = 0;\n    u32 mTime = 0;\n    i64 sz = 0;\n    const char *zPath = 0;\n    int nPath = 0;\n    const u8 *pData = 0;\n    int nData = 0;\n    int iMethod = 0;\n    u8 *pFree = 0;\n    char *zFree = 0;\n    ZipfileEntry *pOld = 0;\n    ZipfileEntry *pOld2 = 0;\n    int bUpdate = 0;\n    int bIsDir = 0;\n    u32 iCrc32 = 0;\n    (void)pRowid;\n    if (pTab->pWriteFd == 0) {\n        rc = zipfileBegin(pVtab);\n        if (rc != 0)\n            return rc;\n    }\n    if (sqlite3_value_type(apVal[0]) != 5) {\n        const char *zDelete = (const char *)sqlite3_value_text(apVal[0]);\n        int nDelete = (int)strlen(zDelete);\n        if (nVal > 1) {\n            const char *zUpdate = (const char *)sqlite3_value_text(apVal[1]);\n            if (zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete) != 0) {\n                bUpdate = 1;\n            }\n        }\n        for (pOld = pTab->pFirstEntry; 1; pOld = pOld->pNext) {\n            if (zipfileComparePath(pOld->cds.zFile, zDelete, nDelete) == 0) {\n                break;\n            }\n            ((void)0);\n        }\n    }\n    if (nVal > 1) {\n        if (sqlite3_value_type(apVal[5]) != 5) {\n            zipfileTableErr(pTab, \"sz must be NULL\");\n            rc = 19;\n        }\n        if (sqlite3_value_type(apVal[6]) != 5) {\n            zipfileTableErr(pTab, \"rawdata must be NULL\");\n            rc = 19;\n        }\n        if (rc == 0) {\n            if (sqlite3_value_type(apVal[7]) == 5) {\n                bIsDir = 1;\n            } else {\n                const u8 *aIn = sqlite3_value_blob(apVal[7]);\n                int nIn = sqlite3_value_bytes(apVal[7]);\n                int bAuto = sqlite3_value_type(apVal[8]) == 5;\n                iMethod = sqlite3_value_int(apVal[8]);\n                sz = nIn;\n                pData = aIn;\n                nData = nIn;\n                if (iMethod != 0 && iMethod != 8) {\n                    zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n                    rc = 19;\n                } else {\n                    if (bAuto || iMethod) {\n                        int nCmp;\n                        rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n                        if (rc == 0) {\n                            if (iMethod || nCmp < nIn) {\n                                iMethod = 8;\n                                pData = pFree;\n                                nData = nCmp;\n                            }\n                        }\n                    }\n                    iCrc32 = crc32(0, aIn, nIn);\n                }\n            }\n        }\n        if (rc == 0) {\n            rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n        }\n        if (rc == 0) {\n            zPath = (const char *)sqlite3_value_text(apVal[2]);\n            if (zPath == 0)\n                zPath = \"\";\n            nPath = (int)strlen(zPath);\n            mTime = zipfileGetTime(apVal[4]);\n        }\n        if (rc == 0 && bIsDir) {\n            if (nPath <= 0 || zPath[nPath - 1] != '/') {\n                zFree = sqlite3_mprintf(\"%s/\", zPath);\n                zPath = (const char *)zFree;\n                if (zFree == 0) {\n                    rc = 7;\n                    nPath = 0;\n                } else {\n                    nPath = (int)strlen(zPath);\n                }\n            }\n        }\n        if ((pOld == 0 || bUpdate) && rc == 0) {\n            ZipfileEntry *p;\n            for (p = pTab->pFirstEntry; p; p = p->pNext) {\n                if (zipfileComparePath(p->cds.zFile, zPath, nPath) == 0) {\n                    switch (sqlite3_vtab_on_conflict(pTab->db)) {\n                      case 2:\n                        {\n                            goto zipfile_update_done;\n                        }\n                      case 5:\n                        {\n                            pOld2 = p;\n                            break;\n                        }\n                      default:\n                        {\n                            zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n                            rc = 19;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        if (rc == 0) {\n            pNew = zipfileNewEntry(zPath);\n            if (pNew == 0) {\n                rc = 7;\n            } else {\n                pNew->cds.iVersionMadeBy = ((3 << 8) + 30);\n                pNew->cds.iVersionExtract = 20;\n                pNew->cds.flags = 2048;\n                pNew->cds.iCompression = (u16)iMethod;\n                zipfileMtimeToDos(&pNew->cds, mTime);\n                pNew->cds.crc32 = iCrc32;\n                pNew->cds.szCompressed = nData;\n                pNew->cds.szUncompressed = (u32)sz;\n                pNew->cds.iExternalAttr = (mode << 16);\n                pNew->cds.iOffset = (u32)pTab->szCurrent;\n                pNew->cds.nFile = (u16)nPath;\n                pNew->mUnixTime = (u32)mTime;\n                rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n                zipfileAddEntry(pTab, pOld, pNew);\n            }\n        }\n    }\n    if (rc == 0 && (pOld || pOld2)) {\n        ZipfileCsr *pCsr;\n        for (pCsr = pTab->pCsrList; pCsr; pCsr = pCsr->pCsrNext) {\n            if (pCsr->pCurrent && (pCsr->pCurrent == pOld || pCsr->pCurrent == pOld2)) {\n                pCsr->pCurrent = pCsr->pCurrent->pNext;\n                pCsr->bNoop = 1;\n            }\n        }\n        zipfileRemoveEntryFromList(pTab, pOld);\n        zipfileRemoveEntryFromList(pTab, pOld2);\n    }\n  zipfile_update_done:\n    sqlite3_free(pFree);\n    sqlite3_free(zFree);\n    return rc;\n}\n"
  },
  {
    "id": "shell.c#16033:1#recoverStep",
    "nobreaks": 1,
    "body": "{\n    ((void)0);\n    switch (p->eState) {\n      case 0:\n        recoverSqlCallback(p, \"BEGIN\");\n        recoverSqlCallback(p, \"PRAGMA writable_schema = on\");\n        recoverEnterMutex();\n        recoverInstallWrapper(p);\n        recoverOpenOutput(p);\n        sqlite3_file_control(p->dbIn, p->zDb, 42, 0);\n        recoverExec(p, p->dbIn, \"PRAGMA writable_schema = on\");\n        recoverExec(p, p->dbIn, \"BEGIN\");\n        if (p->errCode == 0)\n            p->bCloseTransaction = 1;\n        recoverExec(p, p->dbIn, \"SELECT 1 FROM sqlite_schema\");\n        recoverTransferSettings(p);\n        recoverOpenRecovery(p);\n        recoverCacheSchema(p);\n        recoverUninstallWrapper(p);\n        recoverLeaveMutex();\n        recoverExec(p, p->dbOut, \"BEGIN\");\n        recoverWriteSchema1(p);\n        p->eState = 1;\n        break;\n      case 1:\n        {\n            if (p->w1.pTbls == 0) {\n                recoverWriteDataInit(p);\n            }\n            if (101 == recoverWriteDataStep(p)) {\n                recoverWriteDataCleanup(p);\n                if (p->zLostAndFound) {\n                    p->eState = 2;\n                } else {\n                    p->eState = 5;\n                }\n            }\n            break;\n        }\n      case 2:\n        {\n            if (p->laf.pUsed == 0) {\n                recoverLostAndFound1Init(p);\n            }\n            if (101 == recoverLostAndFound1Step(p)) {\n                p->eState = 3;\n            }\n            break;\n        }\n      case 3:\n        {\n            if (p->laf.pAllAndParent == 0) {\n                recoverLostAndFound2Init(p);\n            }\n            if (101 == recoverLostAndFound2Step(p)) {\n                p->eState = 4;\n            }\n            break;\n        }\n      case 4:\n        {\n            if (p->laf.pInsert == 0) {\n                recoverLostAndFound3Init(p);\n            }\n            if (101 == recoverLostAndFound3Step(p)) {\n                p->eState = 5;\n            }\n            break;\n        }\n      case 5:\n        {\n            int rc = 0;\n            recoverWriteSchema2(p);\n            p->eState = 6;\n            recoverExec(p, p->dbOut, \"COMMIT\");\n            rc = sqlite3_exec(p->dbIn, \"END\", 0, 0, 0);\n            if (p->errCode == 0)\n                p->errCode = rc;\n            recoverSqlCallback(p, \"PRAGMA writable_schema = off\");\n            recoverSqlCallback(p, \"COMMIT\");\n            p->eState = 6;\n            recoverFinalCleanup(p);\n            break;\n        }\n        ;\n      case 6:\n        {\n            break;\n        }\n        ;\n    }\n}\n"
  },
  {
    "id": "shell.c#12939:1#dbdataValue",
    "nobreaks": 1,
    "body": "{\n    if (eType >= 0 && dbdataValueBytes(eType) <= nData) {\n        switch (eType) {\n          case 0:\n          case 10:\n          case 11:\n            sqlite3_result_null(pCtx);\n            break;\n          case 8:\n            sqlite3_result_int(pCtx, 0);\n            break;\n          case 9:\n            sqlite3_result_int(pCtx, 1);\n            break;\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            {\n                sqlite3_uint64 v = (signed char)pData[0];\n                pData++;\n                switch (eType) {\n                  case 7:\n                  case 6:\n                    v = (v << 16) + (pData[0] << 8) + pData[1];\n                    pData += 2;\n                  case 5:\n                    v = (v << 16) + (pData[0] << 8) + pData[1];\n                    pData += 2;\n                  case 4:\n                    v = (v << 8) + pData[0];\n                    pData++;\n                  case 3:\n                    v = (v << 8) + pData[0];\n                    pData++;\n                  case 2:\n                    v = (v << 8) + pData[0];\n                    pData++;\n                }\n                if (eType == 7) {\n                    double r;\n                    __builtin___memcpy_chk(&r, &v, sizeof (r), __builtin_object_size(&r, 0));\n                    sqlite3_result_double(pCtx, r);\n                } else {\n                    sqlite3_result_int64(pCtx, (sqlite3_int64)v);\n                }\n                break;\n            }\n          default:\n            {\n                int n = ((eType - 12) / 2);\n                if (eType % 2) {\n                    switch (enc) {\n                      case 3:\n                        sqlite3_result_text16be(pCtx, (void *)pData, n, ((sqlite3_destructor_type)-1));\n                        break;\n                      case 2:\n                        sqlite3_result_text16le(pCtx, (void *)pData, n, ((sqlite3_destructor_type)-1));\n                        break;\n                      default:\n                        sqlite3_result_text(pCtx, (char *)pData, n, ((sqlite3_destructor_type)-1));\n                        break;\n                    }\n                } else {\n                    sqlite3_result_blob(pCtx, pData, n, ((sqlite3_destructor_type)-1));\n                }\n            }\n        }\n    }\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../tool/lemon.c#2257:1#parseonetoken",
    "nobreaks": 1,
    "body": "{\n    const char *x;\n    x = Strsafe(psp->tokenstart);\n    switch (psp->state) {\n      case INITIALIZE:\n        psp->prevrule = 0;\n        psp->preccounter = 0;\n        psp->firstrule = psp->lastrule = 0;\n        psp->gp->nrule = 0;\n      case WAITING_FOR_DECL_OR_RULE:\n        if (x[0] == '%') {\n            psp->state = WAITING_FOR_DECL_KEYWORD;\n        } else if (islower((unsigned char)(x[0]))) {\n            psp->lhs = Symbol_new(x);\n            psp->nrhs = 0;\n            psp->lhsalias = 0;\n            psp->state = WAITING_FOR_ARROW;\n        } else if (x[0] == '{') {\n            if (psp->prevrule == 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"There is no prior rule upon which to attach the code fragment which begins on this line.\");\n                psp->errorcnt++;\n            } else if (psp->prevrule->code != 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Code fragment beginning on this line is not the first to follow the previous rule.\");\n                psp->errorcnt++;\n            } else if (strcmp(x, \"{NEVER-REDUCE\") == 0) {\n                psp->prevrule->neverReduce = 1;\n            } else {\n                psp->prevrule->line = psp->tokenlineno;\n                psp->prevrule->code = &x[1];\n                psp->prevrule->noCode = 0;\n            }\n        } else if (x[0] == '[') {\n            psp->state = PRECEDENCE_MARK_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Token \\\"%s\\\" should be either \\\"%%\\\" or a nonterminal name.\", x);\n            psp->errorcnt++;\n        }\n        break;\n      case PRECEDENCE_MARK_1:\n        if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"The precedence symbol must be a terminal.\");\n            psp->errorcnt++;\n        } else if (psp->prevrule == 0) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"There is no prior rule to assign precedence \\\"[%s]\\\".\", x);\n            psp->errorcnt++;\n        } else if (psp->prevrule->precsym != 0) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Precedence mark on this line is not the first to follow the previous rule.\");\n            psp->errorcnt++;\n        } else {\n            psp->prevrule->precsym = Symbol_new(x);\n        }\n        psp->state = PRECEDENCE_MARK_2;\n        break;\n      case PRECEDENCE_MARK_2:\n        if (x[0] != ']') {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\"]\\\" on precedence mark.\");\n            psp->errorcnt++;\n        }\n        psp->state = WAITING_FOR_DECL_OR_RULE;\n        break;\n      case WAITING_FOR_ARROW:\n        if (x[0] == ':' && x[1] == ':' && x[2] == '=') {\n            psp->state = IN_RHS;\n        } else if (x[0] == '(') {\n            psp->state = LHS_ALIAS_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Expected to see a \\\":\\\" following the LHS symbol \\\"%s\\\".\", psp->lhs->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_1:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->lhsalias = x;\n            psp->state = LHS_ALIAS_2;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"\\\"%s\\\" is not a valid alias for the LHS \\\"%s\\\"\\n\", x, psp->lhs->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_2:\n        if (x[0] == ')') {\n            psp->state = LHS_ALIAS_3;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\")\\\" following LHS alias name \\\"%s\\\".\", psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_3:\n        if (x[0] == ':' && x[1] == ':' && x[2] == '=') {\n            psp->state = IN_RHS;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\"->\\\" following: \\\"%s(%s)\\\".\", psp->lhs->name, psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case IN_RHS:\n        if (x[0] == '.') {\n            struct rule *rp;\n            rp = (struct rule *)calloc(sizeof(struct rule) + sizeof(struct symbol *) * psp->nrhs + sizeof(char *) * psp->nrhs, 1);\n            if (rp == 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Can't allocate enough memory for this rule.\");\n                psp->errorcnt++;\n                psp->prevrule = 0;\n            } else {\n                int i;\n                rp->ruleline = psp->tokenlineno;\n                rp->rhs = (struct symbol **)&rp[1];\n                rp->rhsalias = (const char **)&(rp->rhs[psp->nrhs]);\n                for (i = 0; i < psp->nrhs; i++) {\n                    rp->rhs[i] = psp->rhs[i];\n                    rp->rhsalias[i] = psp->alias[i];\n                    if (rp->rhsalias[i] != 0) {\n                        rp->rhs[i]->bContent = 1;\n                    }\n                }\n                rp->lhs = psp->lhs;\n                rp->lhsalias = psp->lhsalias;\n                rp->nrhs = psp->nrhs;\n                rp->code = 0;\n                rp->noCode = 1;\n                rp->precsym = 0;\n                rp->index = psp->gp->nrule++;\n                rp->nextlhs = rp->lhs->rule;\n                rp->lhs->rule = rp;\n                rp->next = 0;\n                if (psp->firstrule == 0) {\n                    psp->firstrule = psp->lastrule = rp;\n                } else {\n                    psp->lastrule->next = rp;\n                    psp->lastrule = rp;\n                }\n                psp->prevrule = rp;\n            }\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isalpha((unsigned char)(x[0]))) {\n            if (psp->nrhs >= 1000) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Too many symbols on RHS of rule beginning at \\\"%s\\\".\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_RULE_ERROR;\n            } else {\n                psp->rhs[psp->nrhs] = Symbol_new(x);\n                psp->alias[psp->nrhs] = 0;\n                psp->nrhs++;\n            }\n        } else if ((x[0] == '|' || x[0] == '/') && psp->nrhs > 0 && isupper((unsigned char)(x[1]))) {\n            struct symbol *msp = psp->rhs[psp->nrhs - 1];\n            if (msp->type != MULTITERMINAL) {\n                struct symbol *origsp = msp;\n                msp = (struct symbol *)calloc(1, sizeof (*msp));\n                __builtin___memset_chk(msp, 0, sizeof (*msp), __builtin_object_size(msp, 0));\n                msp->type = MULTITERMINAL;\n                msp->nsubsym = 1;\n                msp->subsym = (struct symbol **)calloc(1, sizeof(struct symbol *));\n                msp->subsym[0] = origsp;\n                msp->name = origsp->name;\n                psp->rhs[psp->nrhs - 1] = msp;\n            }\n            msp->nsubsym++;\n            msp->subsym = (struct symbol **)realloc(msp->subsym, sizeof(struct symbol *) * msp->nsubsym);\n            msp->subsym[msp->nsubsym - 1] = Symbol_new(&x[1]);\n            if (islower((unsigned char)(x[1])) || islower((unsigned char)(msp->subsym[0]->name[0]))) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Cannot form a compound containing a non-terminal\");\n                psp->errorcnt++;\n            }\n        } else if (x[0] == '(' && psp->nrhs > 0) {\n            psp->state = RHS_ALIAS_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal character on RHS of rule: \\\"%s\\\".\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case RHS_ALIAS_1:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->alias[psp->nrhs - 1] = x;\n            psp->state = RHS_ALIAS_2;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"\\\"%s\\\" is not a valid alias for the RHS symbol \\\"%s\\\"\\n\", x, psp->rhs[psp->nrhs - 1]->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case RHS_ALIAS_2:\n        if (x[0] == ')') {\n            psp->state = IN_RHS;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\")\\\" following LHS alias name \\\"%s\\\".\", psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case WAITING_FOR_DECL_KEYWORD:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->declkeyword = x;\n            psp->declargslot = 0;\n            psp->decllinenoslot = 0;\n            psp->insertLineMacro = 1;\n            psp->state = WAITING_FOR_DECL_ARG;\n            if (strcmp(x, \"name\") == 0) {\n                psp->declargslot = &(psp->gp->name);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"include\") == 0) {\n                psp->declargslot = &(psp->gp->include);\n            } else if (strcmp(x, \"code\") == 0) {\n                psp->declargslot = &(psp->gp->extracode);\n            } else if (strcmp(x, \"token_destructor\") == 0) {\n                psp->declargslot = &psp->gp->tokendest;\n            } else if (strcmp(x, \"default_destructor\") == 0) {\n                psp->declargslot = &psp->gp->vardest;\n            } else if (strcmp(x, \"token_prefix\") == 0) {\n                psp->declargslot = &psp->gp->tokenprefix;\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"syntax_error\") == 0) {\n                psp->declargslot = &(psp->gp->error);\n            } else if (strcmp(x, \"parse_accept\") == 0) {\n                psp->declargslot = &(psp->gp->accept);\n            } else if (strcmp(x, \"parse_failure\") == 0) {\n                psp->declargslot = &(psp->gp->failure);\n            } else if (strcmp(x, \"stack_overflow\") == 0) {\n                psp->declargslot = &(psp->gp->overflow);\n            } else if (strcmp(x, \"extra_argument\") == 0) {\n                psp->declargslot = &(psp->gp->arg);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"extra_context\") == 0) {\n                psp->declargslot = &(psp->gp->ctx);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"token_type\") == 0) {\n                psp->declargslot = &(psp->gp->tokentype);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"default_type\") == 0) {\n                psp->declargslot = &(psp->gp->vartype);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"stack_size\") == 0) {\n                psp->declargslot = &(psp->gp->stacksize);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"start_symbol\") == 0) {\n                psp->declargslot = &(psp->gp->start);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"left\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = LEFT;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"right\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = RIGHT;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"nonassoc\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = NONE;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"destructor\") == 0) {\n                psp->state = WAITING_FOR_DESTRUCTOR_SYMBOL;\n            } else if (strcmp(x, \"type\") == 0) {\n                psp->state = WAITING_FOR_DATATYPE_SYMBOL;\n            } else if (strcmp(x, \"fallback\") == 0) {\n                psp->fallback = 0;\n                psp->state = WAITING_FOR_FALLBACK_ID;\n            } else if (strcmp(x, \"token\") == 0) {\n                psp->state = WAITING_FOR_TOKEN_NAME;\n            } else if (strcmp(x, \"wildcard\") == 0) {\n                psp->state = WAITING_FOR_WILDCARD_ID;\n            } else if (strcmp(x, \"token_class\") == 0) {\n                psp->state = WAITING_FOR_CLASS_ID;\n            } else {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Unknown declaration keyword: \\\"%%%s\\\".\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_DECL_ERROR;\n            }\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal declaration keyword: \\\"%s\\\".\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case WAITING_FOR_DESTRUCTOR_SYMBOL:\n        if (!isalpha((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol name missing after %%destructor keyword\");\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            psp->declargslot = &sp->destructor;\n            psp->decllinenoslot = &sp->destLineno;\n            psp->insertLineMacro = 1;\n            psp->state = WAITING_FOR_DECL_ARG;\n        }\n        break;\n      case WAITING_FOR_DATATYPE_SYMBOL:\n        if (!isalpha((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol name missing after %%type keyword\");\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            struct symbol *sp = Symbol_find(x);\n            if ((sp) && (sp->datatype)) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol %%type \\\"%s\\\" already defined\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_DECL_ERROR;\n            } else {\n                if (!sp) {\n                    sp = Symbol_new(x);\n                }\n                psp->declargslot = &sp->datatype;\n                psp->insertLineMacro = 0;\n                psp->state = WAITING_FOR_DECL_ARG;\n            }\n        }\n        break;\n      case WAITING_FOR_PRECEDENCE_SYMBOL:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isupper((unsigned char)(x[0]))) {\n            struct symbol *sp;\n            sp = Symbol_new(x);\n            if (sp->prec >= 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol \\\"%s\\\" has already be given a precedence.\", x);\n                psp->errorcnt++;\n            } else {\n                sp->prec = psp->preccounter;\n                sp->assoc = psp->declassoc;\n            }\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Can't assign a precedence to \\\"%s\\\".\", x);\n            psp->errorcnt++;\n        }\n        break;\n      case WAITING_FOR_DECL_ARG:\n        if (x[0] == '{' || x[0] == '\"' || isalnum((unsigned char)(x[0]))) {\n            const char *zOld, *zNew;\n            char *zBuf, *z;\n            int nOld, n, nLine = 0, nNew, nBack;\n            int addLineMacro;\n            char zLine[50];\n            zNew = x;\n            if (zNew[0] == '\"' || zNew[0] == '{')\n                zNew++;\n            nNew = ((int)strlen(zNew));\n            if (*psp->declargslot) {\n                zOld = *psp->declargslot;\n            } else {\n                zOld = \"\";\n            }\n            nOld = ((int)strlen(zOld));\n            n = nOld + nNew + 20;\n            addLineMacro = !psp->gp->nolinenosflag && psp->insertLineMacro && psp->tokenlineno > 1 && (psp->decllinenoslot == 0 || psp->decllinenoslot[0] != 0);\n            if (addLineMacro) {\n                for (z = psp->filename , nBack = 0; *z; z++) {\n                    if (*z == '\\\\')\n                        nBack++;\n                }\n                lemon_sprintf(zLine, \"#line %d \", psp->tokenlineno);\n                nLine = ((int)strlen(zLine));\n                n += nLine + ((int)strlen(psp->filename)) + nBack;\n            }\n            *psp->declargslot = (char *)realloc(*psp->declargslot, n);\n            zBuf = *psp->declargslot + nOld;\n            if (addLineMacro) {\n                if (nOld && zBuf[-1] != '\\n') {\n                    *(zBuf++) = '\\n';\n                }\n                __builtin___memcpy_chk(zBuf, zLine, nLine, __builtin_object_size(zBuf, 0));\n                zBuf += nLine;\n                *(zBuf++) = '\"';\n                for (z = psp->filename; *z; z++) {\n                    if (*z == '\\\\') {\n                        *(zBuf++) = '\\\\';\n                    }\n                    *(zBuf++) = *z;\n                }\n                *(zBuf++) = '\"';\n                *(zBuf++) = '\\n';\n            }\n            if (psp->decllinenoslot && psp->decllinenoslot[0] == 0) {\n                psp->decllinenoslot[0] = psp->tokenlineno;\n            }\n            __builtin___memcpy_chk(zBuf, zNew, nNew, __builtin_object_size(zBuf, 0));\n            zBuf += nNew;\n            *zBuf = 0;\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal argument to %%%s: %s\", psp->declkeyword, x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case WAITING_FOR_FALLBACK_ID:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%fallback argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            if (psp->fallback == 0) {\n                psp->fallback = sp;\n            } else if (sp->fallback) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"More than one fallback assigned to token %s\", x);\n                psp->errorcnt++;\n            } else {\n                sp->fallback = psp->fallback;\n                psp->gp->has_fallback = 1;\n            }\n        }\n        break;\n      case WAITING_FOR_TOKEN_NAME:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            (void)Symbol_new(x);\n        }\n        break;\n      case WAITING_FOR_WILDCARD_ID:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%wildcard argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            if (psp->gp->wildcard == 0) {\n                psp->gp->wildcard = sp;\n            } else {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Extra wildcard to token: %s\", x);\n                psp->errorcnt++;\n            }\n        }\n        break;\n      case WAITING_FOR_CLASS_ID:\n        if (!islower((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token_class must be followed by an identifier: %s\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else if (Symbol_find(x)) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol \\\"%s\\\" already used\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            psp->tkclass = Symbol_new(x);\n            psp->tkclass->type = MULTITERMINAL;\n            psp->state = WAITING_FOR_CLASS_TOKEN;\n        }\n        break;\n      case WAITING_FOR_CLASS_TOKEN:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isupper((unsigned char)(x[0])) || ((x[0] == '|' || x[0] == '/') && isupper((unsigned char)(x[1])))) {\n            struct symbol *msp = psp->tkclass;\n            msp->nsubsym++;\n            msp->subsym = (struct symbol **)realloc(msp->subsym, sizeof(struct symbol *) * msp->nsubsym);\n            if (!isupper((unsigned char)(x[0])))\n                x++;\n            msp->subsym[msp->nsubsym - 1] = Symbol_new(x);\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token_class argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case RESYNC_AFTER_RULE_ERROR:\n      case RESYNC_AFTER_DECL_ERROR:\n        if (x[0] == '.')\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        if (x[0] == '%')\n            psp->state = WAITING_FOR_DECL_KEYWORD;\n        break;\n    }\n}\n"
  }
]
[
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#1753:1#dbEvalColumnValue",
    "nobreaks": 1,
    "body": "{\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch (sqlite3_column_type(pStmt, iCol)) {\n      case 4:\n        {\n            int bytes = sqlite3_column_bytes(pStmt, iCol);\n            const char *zBlob = sqlite3_column_blob(pStmt, iCol);\n            if (!zBlob)\n                bytes = 0;\n            return (tclStubsPtr->tcl_NewByteArrayObj)((u8 *)zBlob, bytes);\n        }\n      case 1:\n        {\n            sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n            if (v >= -2147483647 && v <= 2147483647) {\n                return (tclStubsPtr->tcl_NewIntObj)((int)v);\n            } else {\n                return (tclStubsPtr->tcl_NewWideIntObj)(v);\n            }\n        }\n      case 2:\n        {\n            return (tclStubsPtr->tcl_NewDoubleObj)(sqlite3_column_double(pStmt, iCol));\n        }\n      case 5:\n        {\n            return (tclStubsPtr->tcl_NewStringObj)(p->pDb->zNull, -1);\n        }\n    }\n    return (tclStubsPtr->tcl_NewStringObj)((char *)sqlite3_column_text(pStmt, iCol), -1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#939:1#tclSqlFunc",
    "nobreaks": 1,
    "body": "{\n    SqlFunc *p = sqlite3_user_data(context);\n    Tcl_Obj *pCmd;\n    int i;\n    int rc;\n    if (argc == 0) {\n        pCmd = p->pScript;\n        ++(pCmd)->refCount;\n        rc = (tclStubsPtr->tcl_EvalObjEx)(p->interp, pCmd, 0);\n        do {\n            if (--(pCmd)->refCount <= 0)\n                (tclStubsPtr->tclFreeObj)(pCmd);\n        } while (0);\n    } else {\n        Tcl_Obj **aArg;\n        int nArg;\n        if ((tclStubsPtr->tcl_ListObjGetElements)(p->interp, p->pScript, &nArg, &aArg)) {\n            sqlite3_result_error(context, (tclStubsPtr->tcl_GetStringResult)(p->interp), -1);\n            return;\n        }\n        pCmd = (tclStubsPtr->tcl_NewListObj)(nArg, aArg);\n        ++(pCmd)->refCount;\n        for (i = 0; i < argc; i++) {\n            sqlite3_value *pIn = argv[i];\n            Tcl_Obj *pVal;\n            switch (sqlite3_value_type(pIn)) {\n              case 4:\n                {\n                    int bytes = sqlite3_value_bytes(pIn);\n                    pVal = (tclStubsPtr->tcl_NewByteArrayObj)(sqlite3_value_blob(pIn), bytes);\n                    break;\n                }\n              case 1:\n                {\n                    sqlite_int64 v = sqlite3_value_int64(pIn);\n                    if (v >= -2147483647 && v <= 2147483647) {\n                        pVal = (tclStubsPtr->tcl_NewIntObj)((int)v);\n                    } else {\n                        pVal = (tclStubsPtr->tcl_NewWideIntObj)(v);\n                    }\n                    break;\n                }\n              case 2:\n                {\n                    double r = sqlite3_value_double(pIn);\n                    pVal = (tclStubsPtr->tcl_NewDoubleObj)(r);\n                    break;\n                }\n              case 5:\n                {\n                    pVal = (tclStubsPtr->tcl_NewStringObj)(p->pDb->zNull, -1);\n                    break;\n                }\n              default:\n                {\n                    int bytes = sqlite3_value_bytes(pIn);\n                    pVal = (tclStubsPtr->tcl_NewStringObj)((char *)sqlite3_value_text(pIn), bytes);\n                    break;\n                }\n            }\n            rc = (tclStubsPtr->tcl_ListObjAppendElement)(p->interp, pCmd, pVal);\n            if (rc) {\n                do {\n                    if (--(pCmd)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pCmd);\n                } while (0);\n                sqlite3_result_error(context, (tclStubsPtr->tcl_GetStringResult)(p->interp), -1);\n                return;\n            }\n        }\n        if (!p->useEvalObjv) {\n            (tclStubsPtr->tcl_GetString)(pCmd);\n        }\n        rc = (tclStubsPtr->tcl_EvalObjEx)(p->interp, pCmd, 262144);\n        do {\n            if (--(pCmd)->refCount <= 0)\n                (tclStubsPtr->tclFreeObj)(pCmd);\n        } while (0);\n    }\n    if (rc && rc != 2) {\n        sqlite3_result_error(context, (tclStubsPtr->tcl_GetStringResult)(p->interp), -1);\n    } else {\n        Tcl_Obj *pVar = (tclStubsPtr->tcl_GetObjResult)(p->interp);\n        int n;\n        u8 *data;\n        const char *zType = (pVar->typePtr ? pVar->typePtr->name : \"\");\n        char c = zType[0];\n        int eType = p->eType;\n        if (eType == 5) {\n            if (c == 'b' && strcmp(zType, \"bytearray\") == 0 && pVar->bytes == 0) {\n                eType = 4;\n            } else if ((c == 'b' && strcmp(zType, \"boolean\") == 0) || (c == 'w' && strcmp(zType, \"wideInt\") == 0) || (c == 'i' && strcmp(zType, \"int\") == 0)) {\n                eType = 1;\n            } else if (c == 'd' && strcmp(zType, \"double\") == 0) {\n                eType = 2;\n            } else {\n                eType = 3;\n            }\n        }\n        switch (eType) {\n          case 4:\n            {\n                data = (tclStubsPtr->tcl_GetByteArrayFromObj)(pVar, &n);\n                sqlite3_result_blob(context, data, n, ((sqlite3_destructor_type)-1));\n                break;\n            }\n          case 1:\n            {\n                Tcl_WideInt v;\n                if (0 == (tclStubsPtr->tcl_GetWideIntFromObj)(0, pVar, &v)) {\n                    sqlite3_result_int64(context, v);\n                    break;\n                }\n            }\n          case 2:\n            {\n                double r;\n                if (0 == (tclStubsPtr->tcl_GetDoubleFromObj)(0, pVar, &r)) {\n                    sqlite3_result_double(context, r);\n                    break;\n                }\n            }\n          default:\n            {\n                data = (unsigned char *)(tclStubsPtr->tcl_GetStringFromObj)(pVar, &n);\n                sqlite3_result_text(context, (char *)data, n, ((sqlite3_destructor_type)-1));\n                break;\n            }\n        }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/visit-ast-cpp/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#1931:1#DbObjCmd",
    "nobreaks": 1,
    "body": "{\n    SqliteDb *pDb = (SqliteDb *)cd;\n    int choice;\n    int rc = 0;\n    static const char *DB_strs[] = {\"authorizer\", \"backup\", \"bind_fallback\", \"busy\", \"cache\", \"changes\", \"close\", \"collate\", \"collation_needed\", \"commit_hook\", \"complete\", \"config\", \"copy\", \"deserialize\", \"enable_load_extension\", \"errorcode\", \"erroroffset\", \"eval\", \"exists\", \"function\", \"incrblob\", \"interrupt\", \"last_insert_rowid\", \"nullvalue\", \"onecolumn\", \"preupdate\", \"profile\", \"progress\", \"rekey\", \"restore\", \"rollback_hook\", \"serialize\", \"status\", \"timeout\", \"total_changes\", \"trace\", \"trace_v2\", \"transaction\", \"unlock_notify\", \"update_hook\", \"version\", \"wal_hook\", 0};\n    enum DB_enum {\n        DB_AUTHORIZER,\n        DB_BACKUP,\n        DB_BIND_FALLBACK,\n        DB_BUSY,\n        DB_CACHE,\n        DB_CHANGES,\n        DB_CLOSE,\n        DB_COLLATE,\n        DB_COLLATION_NEEDED,\n        DB_COMMIT_HOOK,\n        DB_COMPLETE,\n        DB_CONFIG,\n        DB_COPY,\n        DB_DESERIALIZE,\n        DB_ENABLE_LOAD_EXTENSION,\n        DB_ERRORCODE,\n        DB_ERROROFFSET,\n        DB_EVAL,\n        DB_EXISTS,\n        DB_FUNCTION,\n        DB_INCRBLOB,\n        DB_INTERRUPT,\n        DB_LAST_INSERT_ROWID,\n        DB_NULLVALUE,\n        DB_ONECOLUMN,\n        DB_PREUPDATE,\n        DB_PROFILE,\n        DB_PROGRESS,\n        DB_REKEY,\n        DB_RESTORE,\n        DB_ROLLBACK_HOOK,\n        DB_SERIALIZE,\n        DB_STATUS,\n        DB_TIMEOUT,\n        DB_TOTAL_CHANGES,\n        DB_TRACE,\n        DB_TRACE_V2,\n        DB_TRANSACTION,\n        DB_UNLOCK_NOTIFY,\n        DB_UPDATE_HOOK,\n        DB_VERSION,\n        DB_WAL_HOOK\n    };\n    if (objc < 2) {\n        (tclStubsPtr->tcl_WrongNumArgs)(interp, 1, objv, \"SUBCOMMAND ...\");\n        return 1;\n    }\n    if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[1], DB_strs, \"option\", 0, &choice)) {\n        return 1;\n    }\n    switch ((enum DB_enum)choice) {\n      case DB_AUTHORIZER:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zAuth) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zAuth, (char *)0);\n                }\n            } else {\n                char *zAuth;\n                int len;\n                if (pDb->zAuth) {\n                    (tclStubsPtr->tcl_Free)(pDb->zAuth);\n                }\n                zAuth = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zAuth && len > 0) {\n                    pDb->zAuth = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zAuth, zAuth, len + 1, __builtin_object_size(pDb->zAuth, 0));\n                } else {\n                    pDb->zAuth = 0;\n                }\n                if (pDb->zAuth) {\n                    typedef int (*sqlite3_auth_cb)(void *, int, const char *, const char *, const char *, const char *);\n                    pDb->interp = interp;\n                    sqlite3_set_authorizer(pDb->db, (sqlite3_auth_cb)auth_callback, pDb);\n                } else {\n                    sqlite3_set_authorizer(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_BACKUP:\n        {\n            const char *zDestFile;\n            const char *zSrcDb;\n            sqlite3 *pDest;\n            sqlite3_backup *pBackup;\n            if (objc == 3) {\n                zSrcDb = \"main\";\n                zDestFile = (tclStubsPtr->tcl_GetString)(objv[2]);\n            } else if (objc == 4) {\n                zSrcDb = (tclStubsPtr->tcl_GetString)(objv[2]);\n                zDestFile = (tclStubsPtr->tcl_GetString)(objv[3]);\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? FILENAME\");\n                return 1;\n            }\n            rc = sqlite3_open_v2(zDestFile, &pDest, 2 | 4 | pDb->openFlags, 0);\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"cannot open target database: \", sqlite3_errmsg(pDest), (char *)0);\n                sqlite3_close(pDest);\n                return 1;\n            }\n            pBackup = sqlite3_backup_init(pDest, \"main\", pDb->db, zSrcDb);\n            if (pBackup == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"backup failed: \", sqlite3_errmsg(pDest), (char *)0);\n                sqlite3_close(pDest);\n                return 1;\n            }\n            while ((rc = sqlite3_backup_step(pBackup, 100)) == 0)\n                {\n                }\n            sqlite3_backup_finish(pBackup);\n            if (rc == 101) {\n                rc = 0;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"backup failed: \", sqlite3_errmsg(pDest), (char *)0);\n                rc = 1;\n            }\n            sqlite3_close(pDest);\n            break;\n        }\n      case DB_BIND_FALLBACK:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zBindFallback) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zBindFallback, (char *)0);\n                }\n            } else {\n                char *zCallback;\n                int len;\n                if (pDb->zBindFallback) {\n                    (tclStubsPtr->tcl_Free)(pDb->zBindFallback);\n                }\n                zCallback = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zCallback && len > 0) {\n                    pDb->zBindFallback = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zBindFallback, zCallback, len + 1, __builtin_object_size(pDb->zBindFallback, 0));\n                } else {\n                    pDb->zBindFallback = 0;\n                }\n            }\n            break;\n        }\n      case DB_BUSY:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"CALLBACK\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zBusy) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zBusy, (char *)0);\n                }\n            } else {\n                char *zBusy;\n                int len;\n                if (pDb->zBusy) {\n                    (tclStubsPtr->tcl_Free)(pDb->zBusy);\n                }\n                zBusy = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zBusy && len > 0) {\n                    pDb->zBusy = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zBusy, zBusy, len + 1, __builtin_object_size(pDb->zBusy, 0));\n                } else {\n                    pDb->zBusy = 0;\n                }\n                if (pDb->zBusy) {\n                    pDb->interp = interp;\n                    sqlite3_busy_handler(pDb->db, DbBusyHandler, pDb);\n                } else {\n                    sqlite3_busy_handler(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_CACHE:\n        {\n            char *subCmd;\n            int n;\n            if (objc <= 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 1, objv, \"cache option ?arg?\");\n                return 1;\n            }\n            subCmd = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            if (*subCmd == 'f' && strcmp(subCmd, \"flush\") == 0) {\n                if (objc != 3) {\n                    (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"flush\");\n                    return 1;\n                } else {\n                    flushStmtCache(pDb);\n                }\n            } else if (*subCmd == 's' && strcmp(subCmd, \"size\") == 0) {\n                if (objc != 4) {\n                    (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"size n\");\n                    return 1;\n                } else {\n                    if (1 == (tclStubsPtr->tcl_GetIntFromObj)(interp, objv[3], &n)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"cannot convert \\\"\", (tclStubsPtr->tcl_GetStringFromObj)(objv[3], 0), \"\\\" to integer\", (char *)0);\n                        return 1;\n                    } else {\n                        if (n < 0) {\n                            flushStmtCache(pDb);\n                            n = 0;\n                        } else if (n > 100) {\n                            n = 100;\n                        }\n                        pDb->maxStmt = n;\n                    }\n                }\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"bad option \\\"\", (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0), \"\\\": must be flush or size\", (char *)0);\n                return 1;\n            }\n            break;\n        }\n      case DB_CHANGES:\n        {\n            Tcl_Obj *pResult;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, sqlite3_changes64(pDb->db));\n            break;\n        }\n      case DB_CLOSE:\n        {\n            (tclStubsPtr->tcl_DeleteCommand)(interp, (tclStubsPtr->tcl_GetStringFromObj)(objv[0], 0));\n            break;\n        }\n      case DB_COLLATE:\n        {\n            SqlCollate *pCollate;\n            char *zName;\n            char *zScript;\n            int nScript;\n            if (objc != 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NAME SCRIPT\");\n                return 1;\n            }\n            zName = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            zScript = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], &nScript);\n            pCollate = (SqlCollate *)(tclStubsPtr->tcl_Alloc)(sizeof (*pCollate) + nScript + 1);\n            if (pCollate == 0)\n                return 1;\n            pCollate->interp = interp;\n            pCollate->pNext = pDb->pCollate;\n            pCollate->zScript = (char *)&pCollate[1];\n            pDb->pCollate = pCollate;\n            __builtin___memcpy_chk(pCollate->zScript, zScript, nScript + 1, __builtin_object_size(pCollate->zScript, 0));\n            if (sqlite3_create_collation(pDb->db, zName, 1, pCollate, tclSqlCollate)) {\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_errmsg(pDb->db), ((Tcl_FreeProc *)1));\n                return 1;\n            }\n            break;\n        }\n      case DB_COLLATION_NEEDED:\n        {\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SCRIPT\");\n                return 1;\n            }\n            if (pDb->pCollateNeeded) {\n                do {\n                    if (--(pDb->pCollateNeeded)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pDb->pCollateNeeded);\n                } while (0);\n            }\n            pDb->pCollateNeeded = (tclStubsPtr->tcl_DuplicateObj)(objv[2]);\n            ++(pDb->pCollateNeeded)->refCount;\n            sqlite3_collation_needed(pDb->db, pDb, tclCollateNeeded);\n            break;\n        }\n      case DB_COMMIT_HOOK:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zCommit) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zCommit, (char *)0);\n                }\n            } else {\n                const char *zCommit;\n                int len;\n                if (pDb->zCommit) {\n                    (tclStubsPtr->tcl_Free)(pDb->zCommit);\n                }\n                zCommit = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zCommit && len > 0) {\n                    pDb->zCommit = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zCommit, zCommit, len + 1, __builtin_object_size(pDb->zCommit, 0));\n                } else {\n                    pDb->zCommit = 0;\n                }\n                if (pDb->zCommit) {\n                    pDb->interp = interp;\n                    sqlite3_commit_hook(pDb->db, DbCommitHandler, pDb);\n                } else {\n                    sqlite3_commit_hook(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_COMPLETE:\n        {\n            Tcl_Obj *pResult;\n            int isComplete;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SQL\");\n                return 1;\n            }\n            isComplete = sqlite3_complete((tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0));\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetBooleanObj)(pResult, isComplete);\n            break;\n        }\n      case DB_CONFIG:\n        {\n            static const struct DbConfigChoices {\n                const char *zName;\n                int op;\n            } aDbConfig[] = {{\"defensive\", 1010}, {\"dqs_ddl\", 1014}, {\"dqs_dml\", 1013}, {\"enable_fkey\", 1002}, {\"enable_qpsg\", 1007}, {\"enable_trigger\", 1003}, {\"enable_view\", 1015}, {\"fts3_tokenizer\", 1004}, {\"legacy_alter_table\", 1012}, {\"legacy_file_format\", 1016}, {\"load_extension\", 1005}, {\"no_ckpt_on_close\", 1006}, {\"reset_database\", 1009}, {\"trigger_eqp\", 1008}, {\"trusted_schema\", 1017}, {\"writable_schema\", 1011}};\n            Tcl_Obj *pResult;\n            int ii;\n            if (objc > 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?OPTION? ?BOOLEAN?\");\n                return 1;\n            }\n            if (objc == 2) {\n                pResult = (tclStubsPtr->tcl_NewListObj)(0, 0);\n                for (ii = 0; ii < sizeof (aDbConfig) / sizeof (aDbConfig[0]); ii++) {\n                    int v = 0;\n                    sqlite3_db_config(pDb->db, aDbConfig[ii].op, -1, &v);\n                    (tclStubsPtr->tcl_ListObjAppendElement)(interp, pResult, (tclStubsPtr->tcl_NewStringObj)(aDbConfig[ii].zName, -1));\n                    (tclStubsPtr->tcl_ListObjAppendElement)(interp, pResult, (tclStubsPtr->tcl_NewIntObj)(v));\n                }\n            } else {\n                const char *zOpt = (tclStubsPtr->tcl_GetString)(objv[2]);\n                int onoff = -1;\n                int v = 0;\n                if (zOpt[0] == '-')\n                    zOpt++;\n                for (ii = 0; ii < sizeof (aDbConfig) / sizeof (aDbConfig[0]); ii++) {\n                    if (strcmp(aDbConfig[ii].zName, zOpt) == 0)\n                        break;\n                }\n                if (ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unknown config option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                    return 1;\n                }\n                if (objc == 4) {\n                    if ((tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[3], &onoff)) {\n                        return 1;\n                    }\n                }\n                sqlite3_db_config(pDb->db, aDbConfig[ii].op, onoff, &v);\n                pResult = (tclStubsPtr->tcl_NewIntObj)(v);\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, pResult);\n            break;\n        }\n      case DB_COPY:\n        {\n            char *zTable;\n            char *zFile;\n            char *zConflict;\n            sqlite3_stmt *pStmt;\n            int nCol;\n            int nByte;\n            int i, j;\n            int nSep;\n            int nNull;\n            char *zSql;\n            char *zLine;\n            char **azCol;\n            const char *zCommit;\n            FILE *in;\n            int lineno = 0;\n            char zLineNum[80];\n            Tcl_Obj *pResult;\n            const char *zSep;\n            const char *zNull;\n            if (objc < 5 || objc > 7) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\");\n                return 1;\n            }\n            if (objc >= 6) {\n                zSep = (tclStubsPtr->tcl_GetStringFromObj)(objv[5], 0);\n            } else {\n                zSep = \"\\t\";\n            }\n            if (objc >= 7) {\n                zNull = (tclStubsPtr->tcl_GetStringFromObj)(objv[6], 0);\n            } else {\n                zNull = \"\";\n            }\n            zConflict = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            zTable = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], 0);\n            zFile = (tclStubsPtr->tcl_GetStringFromObj)(objv[4], 0);\n            nSep = strlen30(zSep);\n            nNull = strlen30(zNull);\n            if (nSep == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: non-null separator required for copy\", (char *)0);\n                return 1;\n            }\n            if (strcmp(zConflict, \"rollback\") != 0 && strcmp(zConflict, \"abort\") != 0 && strcmp(zConflict, \"fail\") != 0 && strcmp(zConflict, \"ignore\") != 0 && strcmp(zConflict, \"replace\") != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \\\"\", zConflict, \"\\\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\", (char *)0);\n                return 1;\n            }\n            zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n            if (zSql == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: no such table: \", zTable, (char *)0);\n                return 1;\n            }\n            nByte = strlen30(zSql);\n            rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n            sqlite3_free(zSql);\n            if (rc) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                nCol = 0;\n            } else {\n                nCol = sqlite3_column_count(pStmt);\n            }\n            sqlite3_finalize(pStmt);\n            if (nCol == 0) {\n                return 1;\n            }\n            zSql = malloc(nByte + 50 + nCol * 2);\n            if (zSql == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: can't malloc()\", (char *)0);\n                return 1;\n            }\n            sqlite3_snprintf(nByte + 50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\", zConflict, zTable);\n            j = strlen30(zSql);\n            for (i = 1; i < nCol; i++) {\n                zSql[j++] = ',';\n                zSql[j++] = '?';\n            }\n            zSql[j++] = ')';\n            zSql[j] = 0;\n            rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);\n            free(zSql);\n            if (rc) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                sqlite3_finalize(pStmt);\n                return 1;\n            }\n            in = fopen(zFile, \"rb\");\n            if (in == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: cannot open file: \", zFile, (char *)0);\n                sqlite3_finalize(pStmt);\n                return 1;\n            }\n            azCol = malloc(sizeof (azCol[0]) * (nCol + 1));\n            if (azCol == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"Error: can't malloc()\", (char *)0);\n                fclose(in);\n                return 1;\n            }\n            (void)sqlite3_exec(pDb->db, \"BEGIN\", 0, 0, 0);\n            zCommit = \"COMMIT\";\n            while ((zLine = local_getline(0, in)) != 0)\n                {\n                    char *z;\n                    lineno++;\n                    azCol[0] = zLine;\n                    for (i = 0 , z = zLine; *z; z++) {\n                        if (*z == zSep[0] && strncmp(z, zSep, nSep) == 0) {\n                            *z = 0;\n                            i++;\n                            if (i < nCol) {\n                                azCol[i] = &z[nSep];\n                                z += nSep - 1;\n                            }\n                        }\n                    }\n                    if (i + 1 != nCol) {\n                        char *zErr;\n                        int nErr = strlen30(zFile) + 200;\n                        zErr = malloc(nErr);\n                        if (zErr) {\n                            sqlite3_snprintf(nErr, zErr, \"Error: %s line %d: expected %d columns of data but found %d\", zFile, lineno, nCol, i + 1);\n                            (tclStubsPtr->tcl_AppendResult)(interp, zErr, (char *)0);\n                            free(zErr);\n                        }\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                    for (i = 0; i < nCol; i++) {\n                        if ((nNull > 0 && strcmp(azCol[i], zNull) == 0) || strlen30(azCol[i]) == 0) {\n                            sqlite3_bind_null(pStmt, i + 1);\n                        } else {\n                            sqlite3_bind_text(pStmt, i + 1, azCol[i], -1, ((sqlite3_destructor_type)0));\n                        }\n                    }\n                    sqlite3_step(pStmt);\n                    rc = sqlite3_reset(pStmt);\n                    free(zLine);\n                    if (rc != 0) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"Error: \", sqlite3_errmsg(pDb->db), (char *)0);\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                }\n            free(azCol);\n            fclose(in);\n            sqlite3_finalize(pStmt);\n            (void)sqlite3_exec(pDb->db, zCommit, 0, 0, 0);\n            if (zCommit[0] == 'C') {\n                pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n                (tclStubsPtr->tcl_SetIntObj)(pResult, lineno);\n                rc = 0;\n            } else {\n                sqlite3_snprintf(sizeof (zLineNum), zLineNum, \"%d\", lineno);\n                (tclStubsPtr->tcl_AppendResult)(interp, \", failed while processing line: \", zLineNum, (char *)0);\n                rc = 1;\n            }\n            break;\n        }\n      case DB_DESERIALIZE:\n        {\n            const char *zSchema = 0;\n            Tcl_Obj *pValue = 0;\n            unsigned char *pBA;\n            unsigned char *pData;\n            int len, xrc;\n            sqlite3_int64 mxSize = 0;\n            int i;\n            int isReadonly = 0;\n            if (objc < 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? VALUE\");\n                rc = 1;\n                break;\n            }\n            for (i = 2; i < objc - 1; i++) {\n                const char *z = (tclStubsPtr->tcl_GetString)(objv[i]);\n                if (strcmp(z, \"-maxsize\") == 0 && i < objc - 2) {\n                    Tcl_WideInt x;\n                    rc = (tclStubsPtr->tcl_GetWideIntFromObj)(interp, objv[++i], &x);\n                    if (rc)\n                        goto deserialize_error;\n                    mxSize = x;\n                    continue;\n                }\n                if (strcmp(z, \"-readonly\") == 0 && i < objc - 2) {\n                    rc = (tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[++i], &isReadonly);\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (zSchema == 0 && i == objc - 2 && z[0] != '-') {\n                    zSchema = z;\n                    continue;\n                }\n                (tclStubsPtr->tcl_AppendResult)(interp, \"unknown option: \", z, (char *)0);\n                rc = 1;\n                goto deserialize_error;\n            }\n            pValue = objv[objc - 1];\n            pBA = (tclStubsPtr->tcl_GetByteArrayFromObj)(pValue, &len);\n            pData = sqlite3_malloc64(len);\n            if (pData == 0 && len > 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"out of memory\", (char *)0);\n                rc = 1;\n            } else {\n                int flags;\n                if (len > 0)\n                    __builtin___memcpy_chk(pData, pBA, len, __builtin_object_size(pData, 0));\n                if (isReadonly) {\n                    flags = 1 | 4;\n                } else {\n                    flags = 1 | 2;\n                }\n                xrc = sqlite3_deserialize(pDb->db, zSchema, pData, len, len, flags);\n                if (xrc) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unable to set MEMDB content\", (char *)0);\n                    rc = 1;\n                }\n                if (mxSize > 0) {\n                    sqlite3_file_control(pDb->db, zSchema, 36, &mxSize);\n                }\n            }\n          deserialize_error:\n            break;\n        }\n      case DB_ENABLE_LOAD_EXTENSION:\n        {\n            int onoff;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"BOOLEAN\");\n                return 1;\n            }\n            if ((tclStubsPtr->tcl_GetBooleanFromObj)(interp, objv[2], &onoff)) {\n                return 1;\n            }\n            sqlite3_enable_load_extension(pDb->db, onoff);\n            break;\n        }\n      case DB_ERRORCODE:\n        {\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(sqlite3_errcode(pDb->db)));\n            break;\n        }\n      case DB_ERROROFFSET:\n        {\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(sqlite3_error_offset(pDb->db)));\n            break;\n        }\n      case DB_EXISTS:\n      case DB_ONECOLUMN:\n        {\n            Tcl_Obj *pResult = 0;\n            DbEvalContext sEval;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"SQL\");\n                return 1;\n            }\n            dbEvalInit(&sEval, pDb, objv[2], 0, 0);\n            rc = dbEvalStep(&sEval);\n            if (choice == DB_ONECOLUMN) {\n                if (rc == 0) {\n                    pResult = dbEvalColumnValue(&sEval, 0);\n                } else if (rc == 3) {\n                    (tclStubsPtr->tcl_ResetResult)(interp);\n                }\n            } else if (rc == 3 || rc == 0) {\n                pResult = (tclStubsPtr->tcl_NewBooleanObj)(rc == 0);\n            }\n            dbEvalFinalize(&sEval);\n            if (pResult)\n                (tclStubsPtr->tcl_SetObjResult)(interp, pResult);\n            if (rc == 3) {\n                rc = 0;\n            }\n            break;\n        }\n      case DB_EVAL:\n        {\n            int evalFlags = 0;\n            const char *zOpt;\n            while (objc > 3 && (zOpt = (tclStubsPtr->tcl_GetString)(objv[2])) != 0 && zOpt[0] == '-')\n                {\n                    if (strcmp(zOpt, \"-withoutnulls\") == 0) {\n                        evalFlags |= 1;\n                    } else {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"unknown option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                        return 1;\n                    }\n                    objc--;\n                    objv++;\n                }\n            if (objc < 3 || objc > 5) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\");\n                return 1;\n            }\n            if (objc == 3) {\n                DbEvalContext sEval;\n                Tcl_Obj *pRet = (tclStubsPtr->tcl_NewObj)();\n                ++(pRet)->refCount;\n                dbEvalInit(&sEval, pDb, objv[2], 0, 0);\n                while (0 == (rc = dbEvalStep(&sEval)))\n                    {\n                        int i;\n                        int nCol;\n                        dbEvalRowInfo(&sEval, &nCol, 0);\n                        for (i = 0; i < nCol; i++) {\n                            (tclStubsPtr->tcl_ListObjAppendElement)(interp, pRet, dbEvalColumnValue(&sEval, i));\n                        }\n                    }\n                dbEvalFinalize(&sEval);\n                if (rc == 3) {\n                    (tclStubsPtr->tcl_SetObjResult)(interp, pRet);\n                    rc = 0;\n                }\n                do {\n                    if (--(pRet)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pRet);\n                } while (0);\n            } else {\n                ClientData cd2[2];\n                DbEvalContext *p;\n                Tcl_Obj *pArray = 0;\n                Tcl_Obj *pScript;\n                if (objc >= 5 && *(char *)(tclStubsPtr->tcl_GetString)(objv[3])) {\n                    pArray = objv[3];\n                }\n                pScript = objv[objc - 1];\n                ++(pScript)->refCount;\n                p = (DbEvalContext *)(tclStubsPtr->tcl_Alloc)(sizeof(DbEvalContext));\n                dbEvalInit(p, pDb, objv[2], pArray, evalFlags);\n                cd2[0] = (void *)p;\n                cd2[1] = (void *)pScript;\n                rc = DbEvalNextCmd(cd2, interp, 0);\n            }\n            break;\n        }\n      case DB_FUNCTION:\n        {\n            int flags = 1;\n            SqlFunc *pFunc;\n            Tcl_Obj *pScript;\n            char *zName;\n            int nArg = -1;\n            int i;\n            int eType = 5;\n            if (objc < 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NAME ?SWITCHES? SCRIPT\");\n                return 1;\n            }\n            for (i = 3; i < (objc - 1); i++) {\n                const char *z = (tclStubsPtr->tcl_GetString)(objv[i]);\n                int n = strlen30(z);\n                if (n > 1 && strncmp(z, \"-argcount\", n) == 0) {\n                    if (i == (objc - 2)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"option requires an argument: \", z, (char *)0);\n                        return 1;\n                    }\n                    if ((tclStubsPtr->tcl_GetIntFromObj)(interp, objv[i + 1], &nArg))\n                        return 1;\n                    if (nArg < 0) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"number of arguments must be non-negative\", (char *)0);\n                        return 1;\n                    }\n                    i++;\n                } else if (n > 1 && strncmp(z, \"-deterministic\", n) == 0) {\n                    flags |= 2048;\n                } else if (n > 1 && strncmp(z, \"-directonly\", n) == 0) {\n                    flags |= 524288;\n                } else if (n > 1 && strncmp(z, \"-innocuous\", n) == 0) {\n                    flags |= 2097152;\n                } else if (n > 1 && strncmp(z, \"-returntype\", n) == 0) {\n                    const char *azType[] = {\"integer\", \"real\", \"text\", \"blob\", \"any\", 0};\n                    ((void)0);\n                    ((void)0);\n                    if (i == (objc - 2)) {\n                        (tclStubsPtr->tcl_AppendResult)(interp, \"option requires an argument: \", z, (char *)0);\n                        return 1;\n                    }\n                    i++;\n                    if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[i], azType, \"type\", 0, &eType)) {\n                        return 1;\n                    }\n                    eType++;\n                } else {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"bad option \\\"\", z, \"\\\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\", (char *)0);\n                    return 1;\n                }\n            }\n            pScript = objv[objc - 1];\n            zName = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], 0);\n            pFunc = findSqlFunc(pDb, zName);\n            if (pFunc == 0)\n                return 1;\n            if (pFunc->pScript) {\n                do {\n                    if (--(pFunc->pScript)->refCount <= 0)\n                        (tclStubsPtr->tclFreeObj)(pFunc->pScript);\n                } while (0);\n            }\n            pFunc->pScript = pScript;\n            ++(pScript)->refCount;\n            pFunc->useEvalObjv = safeToUseEvalObjv(interp, pScript);\n            pFunc->eType = eType;\n            rc = sqlite3_create_function(pDb->db, zName, nArg, flags, pFunc, tclSqlFunc, 0, 0);\n            if (rc != 0) {\n                rc = 1;\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_errmsg(pDb->db), ((Tcl_FreeProc *)1));\n            }\n            break;\n        }\n      case DB_INCRBLOB:\n        {\n            int isReadonly = 0;\n            const char *zDb = \"main\";\n            const char *zTable;\n            const char *zColumn;\n            Tcl_WideInt iRow;\n            if (objc > 3 && strcmp((tclStubsPtr->tcl_GetString)(objv[2]), \"-readonly\") == 0) {\n                isReadonly = 1;\n            }\n            if (objc != (5 + isReadonly) && objc != (6 + isReadonly)) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?-readonly? ?DB? TABLE COLUMN ROWID\");\n                return 1;\n            }\n            if (objc == (6 + isReadonly)) {\n                zDb = (tclStubsPtr->tcl_GetString)(objv[2 + isReadonly]);\n            }\n            zTable = (tclStubsPtr->tcl_GetString)(objv[objc - 3]);\n            zColumn = (tclStubsPtr->tcl_GetString)(objv[objc - 2]);\n            rc = (tclStubsPtr->tcl_GetWideIntFromObj)(interp, objv[objc - 1], &iRow);\n            if (rc == 0) {\n                rc = createIncrblobChannel(interp, pDb, zDb, zTable, zColumn, (sqlite3_int64)iRow, isReadonly);\n            }\n            break;\n        }\n      case DB_INTERRUPT:\n        {\n            sqlite3_interrupt(pDb->db);\n            break;\n        }\n      case DB_NULLVALUE:\n        {\n            if (objc != 2 && objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"NULLVALUE\");\n                return 1;\n            }\n            if (objc == 3) {\n                int len;\n                char *zNull = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (pDb->zNull) {\n                    (tclStubsPtr->tcl_Free)(pDb->zNull);\n                }\n                if (zNull && len > 0) {\n                    pDb->zNull = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zNull, zNull, len, __builtin_object_size(pDb->zNull, 0));\n                    pDb->zNull[len] = '\\x00';\n                } else {\n                    pDb->zNull = 0;\n                }\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewStringObj)(pDb->zNull, -1));\n            break;\n        }\n      case DB_LAST_INSERT_ROWID:\n        {\n            Tcl_Obj *pResult;\n            Tcl_WideInt rowid;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            rowid = sqlite3_last_insert_rowid(pDb->db);\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, rowid);\n            break;\n        }\n      case DB_PROGRESS:\n        {\n            if (objc == 2) {\n                if (pDb->zProgress) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zProgress, (char *)0);\n                }\n                sqlite3_progress_handler(pDb->db, 0, 0, 0);\n            } else if (objc == 4) {\n                char *zProgress;\n                int len;\n                int N;\n                if (0 != (tclStubsPtr->tcl_GetIntFromObj)(interp, objv[2], &N)) {\n                    return 1;\n                }\n                ;\n                if (pDb->zProgress) {\n                    (tclStubsPtr->tcl_Free)(pDb->zProgress);\n                }\n                zProgress = (tclStubsPtr->tcl_GetStringFromObj)(objv[3], &len);\n                if (zProgress && len > 0) {\n                    pDb->zProgress = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zProgress, zProgress, len + 1, __builtin_object_size(pDb->zProgress, 0));\n                } else {\n                    pDb->zProgress = 0;\n                }\n                if (pDb->zProgress) {\n                    pDb->interp = interp;\n                    sqlite3_progress_handler(pDb->db, N, DbProgressHandler, pDb);\n                } else {\n                    sqlite3_progress_handler(pDb->db, 0, 0, 0);\n                }\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"N CALLBACK\");\n                return 1;\n            }\n            break;\n        }\n      case DB_PROFILE:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zProfile) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zProfile, (char *)0);\n                }\n            } else {\n                char *zProfile;\n                int len;\n                if (pDb->zProfile) {\n                    (tclStubsPtr->tcl_Free)(pDb->zProfile);\n                }\n                zProfile = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zProfile && len > 0) {\n                    pDb->zProfile = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zProfile, zProfile, len + 1, __builtin_object_size(pDb->zProfile, 0));\n                } else {\n                    pDb->zProfile = 0;\n                }\n                if (pDb->zProfile) {\n                    pDb->interp = interp;\n                    sqlite3_profile(pDb->db, DbProfileHandler, pDb);\n                } else {\n                    sqlite3_profile(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_REKEY:\n        {\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"KEY\");\n                return 1;\n            }\n            break;\n        }\n      case DB_RESTORE:\n        {\n            const char *zSrcFile;\n            const char *zDestDb;\n            sqlite3 *pSrc;\n            sqlite3_backup *pBackup;\n            int nTimeout = 0;\n            if (objc == 3) {\n                zDestDb = \"main\";\n                zSrcFile = (tclStubsPtr->tcl_GetString)(objv[2]);\n            } else if (objc == 4) {\n                zDestDb = (tclStubsPtr->tcl_GetString)(objv[2]);\n                zSrcFile = (tclStubsPtr->tcl_GetString)(objv[3]);\n            } else {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE? FILENAME\");\n                return 1;\n            }\n            rc = sqlite3_open_v2(zSrcFile, &pSrc, 1 | pDb->openFlags, 0);\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"cannot open source database: \", sqlite3_errmsg(pSrc), (char *)0);\n                sqlite3_close(pSrc);\n                return 1;\n            }\n            pBackup = sqlite3_backup_init(pDb->db, zDestDb, pSrc, \"main\");\n            if (pBackup == 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: \", sqlite3_errmsg(pDb->db), (char *)0);\n                sqlite3_close(pSrc);\n                return 1;\n            }\n            while ((rc = sqlite3_backup_step(pBackup, 100)) == 0 || rc == 5)\n                {\n                    if (rc == 5) {\n                        if (nTimeout++ >= 3)\n                            break;\n                        sqlite3_sleep(100);\n                    }\n                }\n            sqlite3_backup_finish(pBackup);\n            if (rc == 101) {\n                rc = 0;\n            } else if (rc == 5 || rc == 6) {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: source database busy\", (char *)0);\n                rc = 1;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"restore failed: \", sqlite3_errmsg(pDb->db), (char *)0);\n                rc = 1;\n            }\n            sqlite3_close(pSrc);\n            break;\n        }\n      case DB_SERIALIZE:\n        {\n            const char *zSchema = objc >= 3 ? (tclStubsPtr->tcl_GetString)(objv[2]) : \"main\";\n            sqlite3_int64 sz = 0;\n            unsigned char *pData;\n            if (objc != 2 && objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?DATABASE?\");\n                rc = 1;\n            } else {\n                int needFree;\n                pData = sqlite3_serialize(pDb->db, zSchema, &sz, 1);\n                if (pData) {\n                    needFree = 0;\n                } else {\n                    pData = sqlite3_serialize(pDb->db, zSchema, &sz, 0);\n                    needFree = 1;\n                }\n                (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewByteArrayObj)(pData, sz));\n                if (needFree)\n                    sqlite3_free(pData);\n            }\n            break;\n        }\n      case DB_STATUS:\n        {\n            int v;\n            const char *zOp;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"(step|sort|autoindex)\");\n                return 1;\n            }\n            zOp = (tclStubsPtr->tcl_GetString)(objv[2]);\n            if (strcmp(zOp, \"step\") == 0) {\n                v = pDb->nStep;\n            } else if (strcmp(zOp, \"sort\") == 0) {\n                v = pDb->nSort;\n            } else if (strcmp(zOp, \"autoindex\") == 0) {\n                v = pDb->nIndex;\n            } else if (strcmp(zOp, \"vmstep\") == 0) {\n                v = pDb->nVMStep;\n            } else {\n                (tclStubsPtr->tcl_AppendResult)(interp, \"bad argument: should be autoindex, step, sort or vmstep\", (char *)0);\n                return 1;\n            }\n            (tclStubsPtr->tcl_SetObjResult)(interp, (tclStubsPtr->tcl_NewIntObj)(v));\n            break;\n        }\n      case DB_TIMEOUT:\n        {\n            int ms;\n            if (objc != 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"MILLISECONDS\");\n                return 1;\n            }\n            if ((tclStubsPtr->tcl_GetIntFromObj)(interp, objv[2], &ms))\n                return 1;\n            sqlite3_busy_timeout(pDb->db, ms);\n            break;\n        }\n      case DB_TOTAL_CHANGES:\n        {\n            Tcl_Obj *pResult;\n            if (objc != 2) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"\");\n                return 1;\n            }\n            pResult = (tclStubsPtr->tcl_GetObjResult)(interp);\n            (tclStubsPtr->tcl_SetWideIntObj)(pResult, sqlite3_total_changes64(pDb->db));\n            break;\n        }\n      case DB_TRACE:\n        {\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zTrace) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zTrace, (char *)0);\n                }\n            } else {\n                char *zTrace;\n                int len;\n                if (pDb->zTrace) {\n                    (tclStubsPtr->tcl_Free)(pDb->zTrace);\n                }\n                zTrace = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zTrace && len > 0) {\n                    pDb->zTrace = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zTrace, zTrace, len + 1, __builtin_object_size(pDb->zTrace, 0));\n                } else {\n                    pDb->zTrace = 0;\n                }\n                if (pDb->zTrace) {\n                    pDb->interp = interp;\n                    sqlite3_trace(pDb->db, DbTraceHandler, pDb);\n                } else {\n                    sqlite3_trace(pDb->db, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRACE_V2:\n        {\n            if (objc > 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?CALLBACK? ?MASK?\");\n                return 1;\n            } else if (objc == 2) {\n                if (pDb->zTraceV2) {\n                    (tclStubsPtr->tcl_AppendResult)(interp, pDb->zTraceV2, (char *)0);\n                }\n            } else {\n                char *zTraceV2;\n                int len;\n                Tcl_WideInt wMask = 0;\n                if (objc == 4) {\n                    static const char *TTYPE_strs[] = {\"statement\", \"profile\", \"row\", \"close\", 0};\n                    enum TTYPE_enum {\n                        TTYPE_STMT,\n                        TTYPE_PROFILE,\n                        TTYPE_ROW,\n                        TTYPE_CLOSE\n                    };\n                    int i;\n                    if (0 != (tclStubsPtr->tcl_ListObjLength)(interp, objv[3], &len)) {\n                        return 1;\n                    }\n                    for (i = 0; i < len; i++) {\n                        Tcl_Obj *pObj;\n                        int ttype;\n                        if (0 != (tclStubsPtr->tcl_ListObjIndex)(interp, objv[3], i, &pObj)) {\n                            return 1;\n                        }\n                        if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, pObj, TTYPE_strs, \"trace type\", 0, &ttype) != 0) {\n                            Tcl_WideInt wType;\n                            Tcl_Obj *pError = (tclStubsPtr->tcl_DuplicateObj)((tclStubsPtr->tcl_GetObjResult)(interp));\n                            ++(pError)->refCount;\n                            if (0 == (tclStubsPtr->tcl_GetWideIntFromObj)(interp, pObj, &wType)) {\n                                do {\n                                    if (--(pError)->refCount <= 0)\n                                        (tclStubsPtr->tclFreeObj)(pError);\n                                } while (0);\n                                wMask |= wType;\n                            } else {\n                                (tclStubsPtr->tcl_SetObjResult)(interp, pError);\n                                do {\n                                    if (--(pError)->refCount <= 0)\n                                        (tclStubsPtr->tclFreeObj)(pError);\n                                } while (0);\n                                return 1;\n                            }\n                        } else {\n                            switch ((enum TTYPE_enum)ttype) {\n                              case TTYPE_STMT:\n                                wMask |= 1;\n                                break;\n                              case TTYPE_PROFILE:\n                                wMask |= 2;\n                                break;\n                              case TTYPE_ROW:\n                                wMask |= 4;\n                                break;\n                              case TTYPE_CLOSE:\n                                wMask |= 8;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    wMask = 1;\n                }\n                if (pDb->zTraceV2) {\n                    (tclStubsPtr->tcl_Free)(pDb->zTraceV2);\n                }\n                zTraceV2 = (tclStubsPtr->tcl_GetStringFromObj)(objv[2], &len);\n                if (zTraceV2 && len > 0) {\n                    pDb->zTraceV2 = (tclStubsPtr->tcl_Alloc)(len + 1);\n                    __builtin___memcpy_chk(pDb->zTraceV2, zTraceV2, len + 1, __builtin_object_size(pDb->zTraceV2, 0));\n                } else {\n                    pDb->zTraceV2 = 0;\n                }\n                if (pDb->zTraceV2) {\n                    pDb->interp = interp;\n                    sqlite3_trace_v2(pDb->db, (unsigned int)wMask, DbTraceV2Handler, pDb);\n                } else {\n                    sqlite3_trace_v2(pDb->db, 0, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRANSACTION:\n        {\n            Tcl_Obj *pScript;\n            const char *zBegin = \"SAVEPOINT _tcl_transaction\";\n            if (objc != 3 && objc != 4) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"[TYPE] SCRIPT\");\n                return 1;\n            }\n            if (pDb->nTransaction == 0 && objc == 4) {\n                static const char *TTYPE_strs[] = {\"deferred\", \"exclusive\", \"immediate\", 0};\n                enum TTYPE_enum {\n                    TTYPE_DEFERRED,\n                    TTYPE_EXCLUSIVE,\n                    TTYPE_IMMEDIATE\n                };\n                int ttype;\n                if ((tclStubsPtr->tcl_GetIndexFromObj)(interp, objv[2], TTYPE_strs, \"transaction type\", 0, &ttype)) {\n                    return 1;\n                }\n                switch ((enum TTYPE_enum)ttype) {\n                  case TTYPE_DEFERRED:\n                    ;\n                    break;\n                  case TTYPE_EXCLUSIVE:\n                    zBegin = \"BEGIN EXCLUSIVE\";\n                    break;\n                  case TTYPE_IMMEDIATE:\n                    zBegin = \"BEGIN IMMEDIATE\";\n                    break;\n                }\n            }\n            pScript = objv[objc - 1];\n            pDb->disableAuth++;\n            rc = sqlite3_exec(pDb->db, zBegin, 0, 0, 0);\n            pDb->disableAuth--;\n            if (rc != 0) {\n                (tclStubsPtr->tcl_AppendResult)(interp, sqlite3_errmsg(pDb->db), (char *)0);\n                return 1;\n            }\n            pDb->nTransaction++;\n            addDatabaseRef(pDb);\n            if (0) {\n                (void)0;\n                (void)0;\n            } else {\n                rc = DbTransPostCmd(&cd, interp, (tclStubsPtr->tcl_EvalObjEx)(interp, pScript, 0));\n            }\n            break;\n        }\n      case DB_UNLOCK_NOTIFY:\n        {\n            (tclStubsPtr->tcl_AppendResult)(interp, \"unlock_notify not available in this build\", (char *)0);\n            rc = 1;\n            break;\n        }\n      case DB_PREUPDATE:\n        {\n            (tclStubsPtr->tcl_AppendResult)(interp, \"preupdate_hook was omitted at compile-time\", (char *)0);\n            rc = 1;\n            break;\n        }\n      case DB_WAL_HOOK:\n      case DB_UPDATE_HOOK:\n      case DB_ROLLBACK_HOOK:\n        {\n            Tcl_Obj **ppHook = 0;\n            if (choice == DB_WAL_HOOK)\n                ppHook = &pDb->pWalHook;\n            if (choice == DB_UPDATE_HOOK)\n                ppHook = &pDb->pUpdateHook;\n            if (choice == DB_ROLLBACK_HOOK)\n                ppHook = &pDb->pRollbackHook;\n            if (objc > 3) {\n                (tclStubsPtr->tcl_WrongNumArgs)(interp, 2, objv, \"?SCRIPT?\");\n                return 1;\n            }\n            DbHookCmd(interp, pDb, (objc == 3 ? objv[2] : 0), ppHook);\n            break;\n        }\n      case DB_VERSION:\n        {\n            int i;\n            for (i = 2; i < objc; i++) {\n                const char *zArg = (tclStubsPtr->tcl_GetString)(objv[i]);\n                {\n                    (tclStubsPtr->tcl_AppendResult)(interp, \"unknown argument: \", zArg, (char *)0);\n                    return 1;\n                }\n            }\n            if (i == 2) {\n                (tclStubsPtr->tcl_SetResult)(interp, (char *)sqlite3_libversion(), ((Tcl_FreeProc *)0));\n            }\n            break;\n        }\n    }\n    return rc;\n}\n"
  }
]
